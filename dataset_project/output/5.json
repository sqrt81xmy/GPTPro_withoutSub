{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/5/vader-protocol",
    "external_functions": [
        [
            "Factory",
            "Synth",
            "iERC20"
        ],
        [
            "Pools",
            "iUTILS",
            "iFACTORY",
            "iERC20",
            "iVADER"
        ],
        [
            "Router",
            "iPOOLS",
            "iERC20",
            "iUTILS",
            "iSYNTH",
            "iVADER"
        ],
        [
            "USDV",
            "iVADER",
            "iERC20",
            "iROUTER"
        ],
        [
            "Utils",
            "iSYNTH",
            "iPOOLS",
            "iVADER",
            "iROUTER",
            "iFACTORY"
        ],
        [
            "Vader",
            "iUSDV",
            "iUTILS",
            "iERC20",
            "iROUTER"
        ]
    ],
    "new_contract": "contract Utils {\n\n    uint private one = 10**18;\n    uint private _10k = 10000;\n    uint private _year = 31536000; // One Year (in seconds)\n\n    bool private inited;\n\n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public POOLS;\n    address public FACTORY;\n\n    constructor () {}\n\n    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {\n        require(inited == false,  \"inited\");\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        POOLS = _pools;\n        FACTORY = _factory;\n    }\n    //====================================SYSTEM FUNCTIONS====================================//\n    // VADER FeeOnTransfer\n    function getFeeOnTransfer(uint totalSupply, uint maxSupply) external pure returns(uint){\n        return calcShare(totalSupply, maxSupply, 100); // 0->100BP\n    }\n\n    function assetChecks(address collateralAsset, address debtAsset) external {\n        if(collateralAsset == VADER){\n            require(iPOOLS(POOLS).isAnchor(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        } else if(collateralAsset == USDV){\n            require(iPOOLS(POOLS).isAsset(debtAsset), \"Bad Combo\"); // Can borrow Asset with VADER/ASSET-SYNTH\n        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAnchor(iSYNTH(collateralAsset).TOKEN())){\n            require(iPOOLS(POOLS).isAnchor(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAsset(iSYNTH(collateralAsset).TOKEN())){\n            require(iPOOLS(POOLS).isAsset(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        }\n    }\n\n    function isBase(address token) public view returns(bool base) {\n        if(token == VADER || token == USDV){\n            return true;\n        }\n    }\n    function isPool(address token) public view returns(bool pool) {\n        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\n            pool = true;\n        }\n    }\n\n    //====================================PRICING====================================//\n\n    function calcValueInBase(address token, uint amount) public view returns (uint value){\n       (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n       if(_baseAmt > 0 && _tokenAmt > 0){\n            return (amount * _baseAmt) / _tokenAmt;\n       }\n    }\n\n    function calcValueInToken(address token, uint amount) public view returns (uint value){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        if(_baseAmt > 0 && _tokenAmt > 0){\n            return (amount * _tokenAmt) / _baseAmt;\n       }\n    }\n    function calcValueOfTokenInToken(address token1, uint amount, address token2) public view returns (uint value){\n            return calcValueInToken(token2, calcValueInBase(token1, amount));\n    }\n\n    function calcSwapValueInBase(address token, uint amount) public view returns (uint){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        return calcSwapOutput(amount, _tokenAmt, _baseAmt);\n    }\n    function calcSwapValueInToken(address token, uint amount) public view returns (uint){\n        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n        return calcSwapOutput(amount, _baseAmt, _tokenAmt);\n    }\n\n    function requirePriceBounds(address token, uint bound, bool inside, uint targetPrice) external view {\n        uint _testingPrice = calcValueInBase(token, one);\n        uint _lower = calcPart((_10k - bound), targetPrice);                // ie 98% of price\n        uint _upper = (targetPrice * (_10k + bound)) / _10k;                // ie 105% of price\n        if(inside){\n            require((_testingPrice >= _lower && _testingPrice <= _upper), \"Not inside\");\n        } else {\n            require((_testingPrice <= _lower || _testingPrice >= _upper), \"Not outside\");\n        }\n    }\n\n    //====================================INCENTIVES========================================//\n\n    function getRewardShare(address token, uint rewardReductionFactor) external view returns (uint rewardShare) {\n        if(iVADER(VADER).emitting() && iROUTER(ROUTER).isCurated(token)){\n            uint _baseAmount = iPOOLS(POOLS).getBaseAmount(token);\n            if (iPOOLS(POOLS).isAsset(token)) {\n                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledUSDV(), iROUTER(ROUTER).reserveUSDV());\n                rewardShare = getReducedShare(_share, rewardReductionFactor);\n            } else if(iPOOLS(POOLS).isAnchor(token)) {\n                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledVADER(), iROUTER(ROUTER).reserveVADER());\n                rewardShare = getReducedShare(_share, rewardReductionFactor);\n            }\n        }\n    }\n\n    function getReducedShare(uint amount, uint rewardReductionFactor) public pure returns(uint) {\n        return calcShare(1, rewardReductionFactor, amount); // Reduce to stop depleting fast\n    }\n\n    //=================================IMPERMANENT LOSS=====================================//\n\n    // Actual protection with 100 day rule and Reserve balance\n    function getProtection(address member, address token, uint basisPoints, uint timeForFullProtection) public view returns(uint protection) {\n        uint _coverage = getCoverage(member, token);\n        if(iROUTER(ROUTER).isCurated(token)){\n            uint _duration = block.timestamp - iROUTER(ROUTER).getMemberLastDeposit(member, token);\n            if(_duration <= timeForFullProtection) {\n                protection = calcShare(_duration, timeForFullProtection, _coverage); // Apply 100 day rule\n            } else {\n                protection = _coverage;\n            }\n        }\n        return calcPart(basisPoints, protection);\n    }\n    // Theoretical coverage based on deposit/redemption values\n    function getCoverage(address member, address token) public view returns (uint) {\n        uint _B0 = iROUTER(ROUTER).getMemberBaseDeposit(member, token); uint _T0 = iROUTER(ROUTER).getMemberTokenDeposit(member, token);\n        uint _units = iPOOLS(POOLS).getMemberUnits(token, member);\n        uint _B1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getBaseAmount(token));\n        uint _T1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getTokenAmount(token));\n        return calcCoverage(_B0, _T0, _B1, _T1);\n    }\n\n    //==================================== LENDING ====================================//\n\n    function getCollateralValueInBase(address member, uint collateral, address collateralAsset, address debtAsset) external view returns (uint debt, uint baseValue) {\n        uint _collateralAdjusted = (collateral * 6666) / 10000; // 150% collateral Ratio\n        if(isBase(collateralAsset)){\n            baseValue = _collateralAdjusted;\n        }else if(isPool(collateralAsset)){\n            baseValue = calcAsymmetricShare(_collateralAdjusted, iPOOLS(POOLS).getMemberUnits(collateralAsset, member), iPOOLS(POOLS).getBaseAmount(collateralAsset)); // calc units to BASE\n        }else if(iFACTORY(FACTORY).isSynth(collateralAsset)){\n            baseValue = calcSwapValueInBase(iSYNTH(collateralAsset).TOKEN(), _collateralAdjusted); // Calc swap value\n        }\n        debt = calcSwapValueInToken(debtAsset, baseValue);        // get debt output\n        return (debt, baseValue);\n    }\n\n    function getDebtValueInCollateral(address member, uint debt, address collateralAsset, address debtAsset) external view returns(uint, uint) {\n        uint _memberDebt = iROUTER(ROUTER).getMemberDebt(member, collateralAsset, debtAsset); // Outstanding Debt\n        uint _memberCollateral = iROUTER(ROUTER).getMemberCollateral(member, collateralAsset, debtAsset); // Collateral\n        uint _collateral = iROUTER(ROUTER).getSystemCollateral(collateralAsset, debtAsset);\n        uint _interestPaid = iROUTER(ROUTER).getSystemInterestPaid(collateralAsset, debtAsset);\n        uint _memberInterestShare = calcShare(_memberCollateral, _collateral, _interestPaid); // Share of interest based on collateral\n        uint _collateralUnlocked = calcShare(debt, _memberDebt, _memberCollateral); \n        return (_collateralUnlocked, _memberInterestShare);\n    }\n\n    function getInterestOwed(address collateralAsset, address debtAsset, uint timeElapsed) external view returns(uint interestOwed) {\n        uint _interestPayment = calcShare(timeElapsed, _year, getInterestPayment(collateralAsset, debtAsset)); // Share of the payment over 1 year\n        if(isBase(collateralAsset)){\n            interestOwed = calcValueInBase(debtAsset, _interestPayment); // Back to base\n        } else if(iFACTORY(FACTORY).isSynth(collateralAsset)) {\n            interestOwed = calcValueOfTokenInToken(debtAsset, _interestPayment, collateralAsset); // Get value of Synth in debtAsset (doubleSwap)\n        }\n    }\n    function getInterestPayment(address collateralAsset, address debtAsset) public view returns(uint) {\n        uint _debtLoading = getDebtLoading(collateralAsset, debtAsset);\n        return (_debtLoading * iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset)) / 10000; \n    }\n    function getDebtLoading(address collateralAsset, address debtAsset) public view returns(uint) {\n        uint _debtIssued = iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset);\n        uint _debtDepth = iPOOLS(POOLS).getTokenAmount(debtAsset);\n        return (_debtIssued * 10000) / _debtDepth; \n    }\n\n    //====================================CORE-MATH====================================//\n\n    function calcPart(uint bp, uint total) public pure returns (uint){\n        // 10,000 basis points = 100.00%\n        require((bp <= 10000) && (bp >= 0), \"Must be correct BP\");\n        return calcShare(bp, 10000, total);\n    }\n\n    function calcShare(uint part, uint total, uint amount) public pure returns (uint share){\n        // share = amount * part/total\n        if(part > total){\n            part = total;\n        }\n        if(total > 0){\n            share = (amount * part) / total;\n        }\n    }\n\n    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint){\n        // y = (x * X * Y )/(x + X)^2\n        uint numerator = (x * X * Y);\n        uint denominator = (x + X) * (x + X);\n        return (numerator / denominator);\n    }\n\n    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint){\n        // fee = (x * x * Y) / (x + X)^2\n        uint numerator = (x * x * Y);\n        uint denominator = (x + X) * (x + X);\n        return (numerator / denominator);\n    }\n    function calcSwapSlip(uint x, uint X) external pure returns (uint){\n        // slip = (x) / (x + X)\n        return (x*10000) / (x + X);\n    }\n\n    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint){\n        if(P == 0){\n            return b;\n        } else {\n            // units = ((P (t B + T b))/(2 T B)) * slipAdjustment\n            // P * (part1 + part2) / (part3) * slipAdjustment\n            uint slipAdjustment = getSlipAdustment(b, B, t, T);\n            uint part1 = (t * B);\n            uint part2 = (T * b);\n            uint part3 = (T * B) * 2;\n            uint _units = (((P * part1) + part2) / part3);\n            return (_units * slipAdjustment) / one;  // Divide by 10**18\n        }\n    }\n\n    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint){\n        // slipAdjustment = (1 - ABS((B t - b T)/((2 b + B) (t + T))))\n        // 1 - ABS(part1 - part2)/(part3 * part4))\n        uint part1 = B * t;\n        uint part2 = b * T;\n        uint part3 = (b * 2) + B;\n        uint part4 = t + T;\n        uint numerator;\n        if(part1 > part2){\n            numerator = (part1 - part2);\n        } else {\n            numerator = (part2 - part1);\n        }\n        uint denominator = (part3 * part4);\n        return one - (numerator * one) / denominator; // Multiply by 10**18\n    }\n\n    function calcSynthUnits(uint b, uint B, uint P) external pure returns(uint){\n        // (P * b)/(2*(b + B))\n        return (P * b) / (2 * (b + B));\n    }\n\n    function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint){\n        // share = (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3\n        // (part1 * (part2 - part3 + part4)) / part5\n        uint part1 = (u * A);\n        uint part2 = ((U * U) * 2);\n        uint part3 = ((U * u) * 2);\n        uint part4 = (u * u);\n        uint numerator = ((part1 * part2) - part3) + part4;\n        uint part5 = ((U * U) * U);\n        return (numerator / part5);\n    }\n    function calcCoverage(uint B0, uint T0, uint B1, uint T1) public pure returns(uint coverage){\n        if(B0 > 0 && T1 > 0){\n            uint _depositValue = B0 + (T0 * B1) / T1; // B0+(T0*B1/T1)\n            uint _redemptionValue = B1 + (T1 * B1) / T1; // B1+(T1*B1/T1)\n            if(_redemptionValue <= _depositValue){\n                coverage = (_depositValue - _redemptionValue);\n            }\n        }\n    }\n\n    // Sorts array in memory from low to high, returns in-memory (Does not need to modify storage)\n    function sortArray(uint[] memory array) external pure returns (uint[] memory) {\n        uint l = array.length;\n        for(uint i = 0; i < l; i++){\n            for(uint j = i+1; j < l; j++){\n                if(array[i] > array[j]){\n                    uint temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n        }\n        return array;\n    }\n\n}contract Factory {\n\n    bool private inited;\n    address public VADER;\n    address public USDV;\n    address public POOLS;\n\n    address[] public arraySynths;\n    mapping(address => address) public getSynth;\n    mapping(address => bool) public isSynth;\n\n    event CreateSynth(address indexed token, address indexed pool);\n\n    modifier onlyPOOLS() {\n        require(msg.sender == POOLS, \"!POOLS\");\n        _;\n    }\n    \n    constructor(){\n    }\n    function init(address _pool) public {\n        require(inited == false);\n        inited = true;\n        POOLS = _pool;\n    }\n\n    //Create a synth asset\n    function deploySynth(address token) external onlyPOOLS returns(address synth) {\n        require(getSynth[token] == address(0), \"CreateErr\");\n        Synth newSynth;\n        newSynth = new Synth(token);  \n        synth = address(newSynth);\n        _addSynth(token, synth);\n        emit CreateSynth(token, synth);\n    }\n\n    function mintSynth(address synth, address member, uint amount) external onlyPOOLS returns(bool) {\n         Synth(synth).mint(member, amount); \n        return true;\n    }\n\n    // function getSynth(address token) public view returns (address synth){\n    //     return mapToken_Synth[token];\n    // }\n    // function isSynth(address token) public view returns (bool _isSynth){\n    //     if(_isListedSynth[token] == true){\n    //         return true;\n    //     }\n    // }\n\n    function _addSynth(address _token, address _synth) internal {\n        getSynth[_token] = _synth;\n        arraySynths.push(_synth); \n        isSynth[_synth] = true;\n    }\n\n}contract Vader is iERC20 {\n\n    // ERC-20 Parameters\n    string public override name; string public override symbol;\n    uint public override decimals; uint public override totalSupply;\n\n    // ERC-20 Mappings\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    // Parameters\n    bool private inited;\n    bool public emitting;\n    bool public minting;\n    uint _1m;\n    uint public baseline;\n    uint public emissionCurve;\n    uint public maxSupply;\n    uint public secondsPerEra;\n    uint public currentEra;\n    uint public nextEraTime;\n    uint public feeOnTransfer;\n\n    address public VETHER;\n    address public USDV;\n    address public UTILS;\n    address public burnAddress;\n    address public rewardAddress;\n    address public DAO;\n\n    event NewEra(uint currentEra, uint nextEraTime, uint emission);\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO, \"Not DAO\");\n        _;\n    }\n    // Stop flash attacks\n    modifier flashProof() {\n        require(isMature(), \"No flash\");\n        _;\n    }\n    function isMature() public view returns(bool){\n        return iUSDV(USDV).isMature();\n    }\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {\n        name = 'VADER PROTOCOL TOKEN';\n        symbol = 'VADER';\n        decimals = 18;\n        _1m = 10**6 * 10 ** decimals; //1m\n        baseline = _1m;\n        totalSupply = 0;\n        maxSupply = 2 * _1m;\n        currentEra = 1;\n        secondsPerEra = 1; //86400;\n        nextEraTime = block.timestamp + secondsPerEra;\n        emissionCurve = 900;\n        DAO = msg.sender;\n        burnAddress = 0x0111011001100001011011000111010101100101;\n    }\n    // Can only be called once\n    function init(address _vether, address _USDV, address _utils) external {\n        require(inited == false);\n        inited = true;\n        VETHER = _vether;\n        USDV = _USDV;\n        UTILS = _utils;\n        rewardAddress = _USDV;\n    }\n\n    //========================================iERC20=========================================//\n    function balanceOf(address account) external view override returns (uint) {\n        return _balances[account];\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint) {\n        return _allowances[owner][spender];\n    }\n    // iERC20 Transfer function\n    function transfer(address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    // iERC20 Approve, change allowance functions\n    function approve(address spender, uint amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function _approve(address owner, address spender, uint amount) internal virtual {\n        require(owner != address(0), \"sender\");\n        require(spender != address(0), \"spender\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    // iERC20 TransferFrom function\n    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    // TransferTo function\n    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. \n    function transferTo(address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(tx.origin, recipient, amount);\n        return true;\n    }\n\n    // Internal transfer function\n    function _transfer(address sender, address recipient, uint amount) internal virtual {\n        require(sender != address(0), \"sender\");\n        require(recipient != address(this), \"recipient\");\n        _balances[sender] -= amount;\n        uint _fee = iUTILS(UTILS).calcPart(feeOnTransfer, amount);  // Critical functionality\n        if(_fee >= 0 && _fee <= amount){                            // Stops reverts if UTILS corrupted\n            amount -= _fee;\n            _burn(msg.sender, _fee);\n        }\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        _checkEmission();\n    }\n    // Internal mint (upgrading and daily emissions)\n    function _mint(address account, uint amount) internal virtual {\n        require(account != address(0), \"recipient\");\n        if((totalSupply + amount) >= maxSupply){\n            amount = maxSupply - totalSupply;       // Safety, can't mint above maxSupply\n        }\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n    // Burn supply\n    function burn(uint amount) public virtual override {\n        _burn(msg.sender, amount);\n    }\n    function burnFrom(address account, uint amount) external virtual override {\n        uint decreasedAllowance = allowance(account, msg.sender) - amount;\n        _approve(account, msg.sender, decreasedAllowance);\n        _burn(account, amount);\n    }\n    function _burn(address account, uint amount) internal virtual {\n        require(account != address(0), \"address err\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    //=========================================DAO=========================================//\n    // Can start\n    function flipEmissions() external onlyDAO {\n        if(emitting){\n            emitting = false;\n        } else {\n            emitting = true;\n        }\n    }\n    // Can stop\n    function flipMinting() external onlyDAO {\n        if(minting){\n            minting = false;\n        } else {\n            minting = true;\n        }\n    }\n    // Can set params\n    function setParams(uint newEra, uint newCurve) external onlyDAO {\n        secondsPerEra = newEra;\n        emissionCurve = newCurve;\n    }\n    // Can set reward address\n    function setRewardAddress(address newAddress) external onlyDAO {\n        rewardAddress = newAddress;\n    }\n    // Can change UTILS\n    function changeUTILS(address newUTILS) external onlyDAO {\n        require(newUTILS != address(0), \"address err\");\n        UTILS = newUTILS;\n    }\n    // Can change DAO\n    function changeDAO(address newDAO) external onlyDAO {\n        require(newDAO != address(0), \"address err\");\n        DAO = newDAO;\n    }\n    // Can purge DAO\n    function purgeDAO() external onlyDAO{\n        DAO = address(0);\n    }\n\n   //======================================EMISSION========================================//\n    // Internal - Update emission function\n    function _checkEmission() private {\n        if ((block.timestamp >= nextEraTime) && emitting) {                                // If new Era and allowed to emit\n            currentEra += 1;                                                               // Increment Era\n            nextEraTime = block.timestamp + secondsPerEra;                                 // Set next Era time\n            uint _emission = getDailyEmission();                                           // Get Daily Dmission\n            _mint(rewardAddress, _emission);                                               // Mint to the Rewad Address\n            feeOnTransfer = iUTILS(UTILS).getFeeOnTransfer(totalSupply, maxSupply);        // UpdateFeeOnTransfer\n            if(feeOnTransfer > 1000){feeOnTransfer = 1000;}                                // Max 10% if UTILS corrupted\n            emit NewEra(currentEra, nextEraTime, _emission);                               // Emit Event\n        }\n    }\n    // Calculate Daily Emission\n    function getDailyEmission() public view returns (uint) {\n        uint _adjustedMax;\n        if(totalSupply <= baseline){ // If less than 1m, then adjust cap down\n            _adjustedMax = (maxSupply * totalSupply) / baseline; // 2m * 0.5m / 1m = 2m * 50% = 1.5m\n        } else {\n            _adjustedMax = maxSupply;  // 2m\n        }\n        return (_adjustedMax - totalSupply) / (emissionCurve); // outstanding / curve \n    }\n\n    //======================================ASSET MINTING========================================//\n    // VETHER Owners to Upgrade\n    function upgrade(uint amount) external {\n        require(iERC20(VETHER).transferFrom(msg.sender, burnAddress, amount));\n        _mint(msg.sender, amount);\n    }\n    // Directly redeem back to VADER (must have sent USDV first)\n    function redeem() external returns (uint redeemAmount){\n        return redeemToMember(msg.sender);\n    }\n    // Redeem on behalf of member (must have sent USDV first)\n    function redeemToMember(address member) public flashProof returns (uint redeemAmount){\n        if(minting){\n            uint _amount = iERC20(USDV).balanceOf(address(this)); \n            iERC20(USDV).burn(_amount);\n            redeemAmount = iROUTER(iUSDV(USDV).ROUTER()).getVADERAmount(_amount); // Critical pricing functionality\n            _mint(member, redeemAmount);\n        }\n    }\n}contract Router {\n\n    // Parameters\n    bool private inited;\n    uint one = 10**18;\n    uint public rewardReductionFactor;\n    uint public timeForFullProtection;\n\n    uint public curatedPoolLimit;\n    uint public curatedPoolCount;\n    mapping(address => bool) private _isCurated;\n    \n    address public VADER;\n    address public USDV;\n    address public POOLS;\n\n    uint public anchorLimit;\n    uint public insidePriceLimit;\n    uint public outsidePriceLimit;\n    address[] public arrayAnchors;\n    uint[] public arrayPrices;\n\n    uint public repayDelay = 3600;\n\n    mapping(address => mapping(address => uint)) public mapMemberToken_depositBase;\n    mapping(address => mapping(address => uint)) public mapMemberToken_depositToken;\n    mapping(address => mapping(address => uint)) public mapMemberToken_lastDeposited;\n\n    mapping(address => CollateralDetails) private mapMember_Collateral;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_Collateral;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_Debt;\n    mapping(address => mapping(address => uint)) private mapCollateralDebt_interestPaid; \n    mapping(address => mapping(address => uint)) private mapCollateralAsset_NextEra;\n\n    struct CollateralDetails {\n        uint ID;\n        mapping(address => DebtDetails) mapCollateral_Debt;\n    }\n    struct DebtDetails{\n        uint ID;\n        mapping(address =>uint) debt; //assetC > AssetD > AmountDebt\n        mapping(address =>uint) collateral; //assetC > AssetD > AmountCol\n        // mapping(address =>uint) assetCollateralDeposit; //assetC > AssetD > AmountCol\n        // mapping(address =>uint) timeBorrowed; // assetC > AssetD > time\n        // mapping(address =>uint) currentDay; // assetC > AssetD > time\n    }\n\n    event PoolReward(address indexed base, address indexed token, uint amount);\n    event Protection(address indexed member, uint amount);\n    event Curated(address indexed curator, address indexed token);\n\n    event AddCollateral(address indexed member, address indexed collateralAsset, uint collateralLocked, address indexed debtAsset, uint debtIssued);\n    event RemoveCollateral(address indexed member, address indexed collateralAsset, uint collateralUnlocked, address indexed debtAsset, uint debtReturned);\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO(), \"Not DAO\");\n        _;\n    }\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n    // Init\n    function init(address _vader, address _usdv, address _pool) public {\n        require(inited == false,  \"inited\");\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        POOLS = _pool;\n        rewardReductionFactor = 1;\n        timeForFullProtection = 1;//8640000; //100 days\n        curatedPoolLimit = 1;\n        anchorLimit = 5;\n        insidePriceLimit = 200;\n        outsidePriceLimit = 500;\n    }\n\n    //=========================================DAO=========================================//\n    // Can set params\n    function setParams(uint newFactor, uint newTime, uint newLimit) external onlyDAO {\n        rewardReductionFactor = newFactor;\n        timeForFullProtection = newTime;\n        curatedPoolLimit = newLimit;\n    }\n    function setAnchorParams(uint newLimit, uint newInside, uint newOutside) external onlyDAO {\n        anchorLimit = newLimit;\n        insidePriceLimit = newInside;\n        outsidePriceLimit = newOutside;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, uint inputBase, address token, uint inputToken) external returns(uint){\n        uint _actualInputBase = moveTokenToPools(base, inputBase);\n        uint _actualInputToken = moveTokenToPools(token, inputToken);\n        addDepositData(msg.sender, token, _actualInputBase, _actualInputToken); \n        return iPOOLS(POOLS).addLiquidity(base, token, msg.sender);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint amountBase, uint amountToken) {\n        (amountBase, amountToken) = iPOOLS(POOLS).removeLiquidity(base, token, basisPoints);\n        uint _protection = getILProtection(msg.sender, base, token, basisPoints);\n        removeDepositData(msg.sender, token, basisPoints, _protection); \n        iERC20(base).transfer(msg.sender, _protection);\n    }\n\n      //=======================================SWAP===========================================//\n    \n    function swap(uint inputAmount, address inputToken, address outputToken) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, 10000);\n    }\n    function swapWithLimit(uint inputAmount, address inputToken, address outputToken, uint slipLimit) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, slipLimit);\n    }\n\n    function swapWithSynths(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth) external returns (uint outputAmount) {\n        return swapWithSynthsWithLimit(inputAmount, inputToken, inSynth, outputToken, outSynth, 10000);\n    }\n\n    function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {\n        address _member = msg.sender;\n        if(!inSynth){\n            moveTokenToPools(inputToken, inputAmount);\n        } else {\n            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);\n        }\n        address _base;\n        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {\n            _base = VADER;\n        } else {\n            _base = USDV;\n        }\n        if (isBase(outputToken)) {\n            // Token||Synth -> BASE\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);\n            } else {\n                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);\n            }\n        } else if (isBase(inputToken)) {\n            // BASE -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        } else if (!isBase(inputToken) && !isBase(outputToken)) {\n            // Token||Synth -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);\n            } else {\n                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);\n            }\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        }\n        _handlePoolReward(_base, inputToken);\n        _handlePoolReward(_base, outputToken);\n        _handleAnchorPriceUpdate(inputToken);\n        _handleAnchorPriceUpdate(outputToken); \n    }\n\n    //====================================INCENTIVES========================================//\n\n    function _handlePoolReward(address _base, address _token) internal{\n        if(!isBase(_token)){                        // USDV or VADER is never a pool\n            uint _reward = iUTILS(UTILS()).getRewardShare(_token, rewardReductionFactor);\n            iERC20(_base).transfer(POOLS, _reward);\n            iPOOLS(POOLS).sync(_base, _token);\n            emit PoolReward(_base, _token, _reward);\n        }\n    }\n\n    //=================================IMPERMANENT LOSS=====================================//\n    \n    function addDepositData(address member, address token, uint amountBase, uint amountToken) internal {\n        mapMemberToken_depositBase[member][token] += amountBase;\n        mapMemberToken_depositToken[member][token] += amountToken;\n        mapMemberToken_lastDeposited[member][token] = block.timestamp;\n    }\n    function removeDepositData(address member, address token, uint basisPoints, uint protection) internal {\n        mapMemberToken_depositBase[member][token] += protection;\n        uint _baseToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositBase[member][token]);\n        uint _tokenToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositToken[member][token]);\n        mapMemberToken_depositBase[member][token] -= _baseToRemove;\n        mapMemberToken_depositToken[member][token] -= _tokenToRemove;\n    }\n\n    function getILProtection(address member, address base, address token, uint basisPoints) public view returns(uint protection) {\n        protection = iUTILS(UTILS()).getProtection(member, token, basisPoints, timeForFullProtection);\n        if(base == VADER){\n            if(protection >= reserveVADER()){\n                protection = reserveVADER(); // In case reserve is running out\n            }\n        } else {\n            if(protection >= reserveUSDV()){\n                protection = reserveUSDV(); // In case reserve is running out\n            }\n        }\n    }\n    \n    //=====================================CURATION==========================================//\n\n    function curatePool(address token) external {\n        require(iPOOLS(POOLS).isAsset(token) || iPOOLS(POOLS).isAnchor(token));\n        if(!isCurated(token)){\n            if(curatedPoolCount < curatedPoolLimit){ // Limit\n                _isCurated[token] = true;\n                curatedPoolCount += 1;\n            }\n        }\n        emit Curated(msg.sender, token);\n    }\n    function replacePool(address oldToken, address newToken) external {\n        require(iPOOLS(POOLS).isAsset(newToken));\n        if(iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)){ // Must be deeper\n            _isCurated[oldToken] = false;\n            _isCurated[newToken] = true;\n            emit Curated(msg.sender, newToken);\n        }\n    }\n\n    //=====================================ANCHORS==========================================//\n\n    function listAnchor(address token) external {\n        require(arrayAnchors.length < anchorLimit); // Limit\n        require(iPOOLS(POOLS).isAnchor(token));     // Must be anchor\n        arrayAnchors.push(token);                   // Add\n        arrayPrices.push(iUTILS(UTILS()).calcValueInBase(token, one));\n        _isCurated[token] = true; \n        updateAnchorPrice(token);\n    }\n\n    function replaceAnchor(address oldToken, address newToken) external {\n        require(iPOOLS(POOLS).isAnchor(newToken), \"Not anchor\");\n        require((iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)), \"Not deeper\");\n        iUTILS(UTILS()).requirePriceBounds(oldToken, outsidePriceLimit, false, getAnchorPrice());                             // if price oldToken >5%\n        iUTILS(UTILS()).requirePriceBounds(newToken, insidePriceLimit, true, getAnchorPrice());                               // if price newToken <2%\n        _isCurated[oldToken] = false; \n        _isCurated[newToken] = true; \n        for(uint i = 0; i<arrayAnchors.length; i++){\n            if(arrayAnchors[i] == oldToken){\n                arrayAnchors[i] = newToken;\n            }\n        }\n        updateAnchorPrice(newToken);\n    }\n\n    // Anyone to update prices\n    function updateAnchorPrice(address token) public {\n        for(uint i = 0; i<arrayAnchors.length; i++){\n            if(arrayAnchors[i] == token){\n                arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);\n            }\n        }\n    }\n\n    function _handleAnchorPriceUpdate(address _token) internal{\n        if(iPOOLS(POOLS).isAnchor(_token)){\n            updateAnchorPrice(_token);\n        }\n    }\n\n    // Price of 1 VADER in USD\n    function getAnchorPrice() public view returns (uint anchorPrice) {\n        if(arrayPrices.length > 0){\n            uint[] memory _sortedAnchorFeed = iUTILS(UTILS()).sortArray(arrayPrices);  // Sort price array, no need to modify storage\n            anchorPrice = _sortedAnchorFeed[2];                         // Return the middle\n        } else {\n            anchorPrice = one;          // Edge case for first USDV mint\n        }\n    }\n\n    // The correct amount of Vader for an input of USDV\n    function getVADERAmount(uint USDVAmount) public view returns (uint vaderAmount){\n        uint _price = getAnchorPrice();\n        return (_price * USDVAmount) / one;\n    }\n\n    // The correct amount of USDV for an input of VADER\n    function getUSDVAmount(uint vaderAmount) public view returns (uint USDVAmount){\n        uint _price = getAnchorPrice();\n        return (vaderAmount * one) / _price;\n    }\n    \n    \n    //======================================LENDING=========================================//\n\n    // Draw debt for self\n    function borrow(uint amount, address collateralAsset, address debtAsset) public returns (uint) {\n        return borrowForMember(msg.sender, amount, collateralAsset, debtAsset);\n    }\n\n    function borrowForMember(address member, uint amount, address collateralAsset, address debtAsset) public returns(uint) {\n        iUTILS(UTILS()).assetChecks(collateralAsset, debtAsset);\n        uint _collateral = _handleTransferIn(member, collateralAsset, amount);                  // get collateral \n        (uint _debtIssued, uint _baseBorrowed) = iUTILS(UTILS()).getCollateralValueInBase(member, _collateral, collateralAsset, debtAsset);\n        mapCollateralDebt_Collateral[collateralAsset][debtAsset] += _collateral;               // Record collateral \n        mapCollateralDebt_Debt[collateralAsset][debtAsset] += _debtIssued;                            // Record debt\n        _addDebtToMember(member, _collateral, collateralAsset, _debtIssued, debtAsset);    // Update member details\n        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){\n            iERC20(VADER).transfer(POOLS, _baseBorrowed);                                  // Send to pools\n            iPOOLS(POOLS).swap(VADER, debtAsset, member, false);                         // Execute swap to member\n        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {\n            iERC20(USDV).transfer(POOLS, _baseBorrowed);                                  // Send to pools\n            iPOOLS(POOLS).swap(USDV, debtAsset, member, false);                         // Execute swap to member\n        }\n        emit AddCollateral(member, collateralAsset, amount, debtAsset, _debtIssued);               // Event\n        payInterest(collateralAsset, debtAsset);\n        return _debtIssued;\n    }\n\n    // Repay for self\n    function repay(uint amount, address collateralAsset, address debtAsset) public returns (uint){\n        return repayForMember(msg.sender, amount, collateralAsset, debtAsset);\n    }\n     // Repay for member\n    function repayForMember(address member, uint basisPoints, address collateralAsset, address debtAsset) public returns (uint){\n        uint _amount = iUTILS(UTILS()).calcPart(basisPoints, getMemberDebt(member, collateralAsset, debtAsset));\n        uint _debt = moveTokenToPools(debtAsset, _amount);    // Get Debt\n        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){\n            iPOOLS(POOLS).swap(VADER, debtAsset, address(this), true);           // Swap Debt to Base back here\n        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {\n            iPOOLS(POOLS).swap(USDV, debtAsset, address(this), true);           // Swap Debt to Base back here\n        }\n        (uint _collateralUnlocked,  uint _memberInterestShare) = iUTILS(UTILS()).getDebtValueInCollateral(member, _debt, collateralAsset, debtAsset); // Unlock collateral that is pro-rata to re-paid debt ($50/$100 = 50%)\n        mapCollateralDebt_Collateral[collateralAsset][debtAsset] -= _collateralUnlocked;               // Update collateral \n        mapCollateralDebt_Debt[collateralAsset][debtAsset] -= _debt;                   // Update debt \n        mapCollateralDebt_interestPaid[collateralAsset][debtAsset] -= _memberInterestShare;\n        _removeDebtFromMember(member, _collateralUnlocked, collateralAsset, _debt, debtAsset);  // Remove\n        emit RemoveCollateral(member, collateralAsset, _collateralUnlocked, debtAsset, _debt);\n        _handleTransferOut(member, collateralAsset, _collateralUnlocked);\n        payInterest(collateralAsset, debtAsset);\n        return _collateralUnlocked;\n    }\n\n    // Called once a day to pay interest\n    function payInterest(address collateralAsset, address debtAsset) internal {\n        if (block.timestamp >= getNextEraTime(collateralAsset, debtAsset) && emitting()) {                              // If new Era\n            uint _timeElapsed = block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];\n            mapCollateralAsset_NextEra[collateralAsset][debtAsset] = block.timestamp + iVADER(VADER).secondsPerEra(); \n            uint _interestOwed = iUTILS(UTILS()).getInterestOwed(collateralAsset, debtAsset, _timeElapsed);\n            mapCollateralDebt_interestPaid[collateralAsset][debtAsset] += _interestOwed;\n            _removeCollateral(_interestOwed, collateralAsset, debtAsset);\n            if(isBase(collateralAsset)){\n                iERC20(collateralAsset).transfer(POOLS, _interestOwed);\n                iPOOLS(POOLS).sync(collateralAsset, debtAsset);\n            } else if(iPOOLS(POOLS).isSynth(collateralAsset)){\n                iERC20(collateralAsset).transfer(POOLS, _interestOwed);\n                iPOOLS(POOLS).syncSynth(iSYNTH(collateralAsset).TOKEN());\n            }\n        }\n    }\n\n    function checkLiquidate() public {\n        // get member remaining Collateral: originalDeposit - shareOfInterestPayments\n        // if remainingCollateral <= 101% * debtValueInCollateral\n        // purge, send remaining collateral to liquidator\n    }\n\n    // function purgeMember() public {\n\n    // }\n\n    // Get Collateral\n    function _handleTransferIn(address _member, address _collateralAsset, uint _amount) internal returns(uint _inputAmount){\n        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){\n            _inputAmount = _getFunds(_collateralAsset, _amount); // Get funds\n        }else if(isPool(_collateralAsset)){\n             iPOOLS(POOLS).lockUnits(_amount, _collateralAsset, _member); // Lock units to protocol\n             _inputAmount = _amount;\n        }\n    }\n    // Send Collateral\n    function _handleTransferOut(address _member, address _collateralAsset, uint _amount) internal{\n        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){\n            _sendFunds(_collateralAsset, _member, _amount); // Send Base\n        }else if(isPool(_collateralAsset)){\n            iPOOLS(POOLS).unlockUnits(_amount, _collateralAsset, _member); // Unlock units to member\n        }\n    }\n\n    function _getFunds(address _token, uint _amount) internal returns(uint) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(tx.origin==msg.sender){\n            require(iERC20(_token).transferTo(address(this), _amount));\n        }else{\n            require(iERC20(_token).transferFrom(msg.sender, address(this), _amount));\n        }\n        return iERC20(_token).balanceOf(address(this)) - _balance;\n    }\n\n    function _sendFunds(address _token, address _member, uint _amount) internal {\n        require(iERC20(_token).transfer(_member, _amount));\n    }\n\n    function _addDebtToMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] += _debt;\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] += _collateral;\n    }\n    function _removeDebtFromMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] -= _debt;\n        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] -= _collateral;\n    }\n    function _removeCollateral(uint _collateral, address _collateralAsset, address _debtAsset) internal {\n        mapCollateralDebt_Collateral[_collateralAsset][_debtAsset] -= _collateral;               // Record collateral \n    }\n\n\n\n    //======================================HELPERS=========================================//\n\n    function isBase(address token) public view returns(bool base) {\n        if(token == VADER || token == USDV){\n            return true;\n        }\n    }\n\n    function reserveVADER() public view returns(uint) {\n        return iERC20(VADER).balanceOf(address(this));\n    }\n    function reserveUSDV() public view returns(uint) {\n        return iERC20(USDV).balanceOf(address(this));\n    }\n\n    // Optionality\n    function moveTokenToPools(address _token, uint _amount) internal returns(uint safeAmount) {\n        if(_token == VADER || _token == USDV || iPOOLS(POOLS).isSynth(_token)){\n            safeAmount = _amount;\n            if(tx.origin==msg.sender){\n                iERC20(_token).transferTo(POOLS, _amount);\n            }else{\n                iERC20(_token).transferFrom(msg.sender, POOLS, _amount);\n            }\n        } else {\n            uint _startBal = iERC20(_token).balanceOf(POOLS);\n            iERC20(_token).transferFrom(msg.sender, POOLS, _amount);\n            safeAmount = iERC20(_token).balanceOf(POOLS) - _startBal;\n        }\n    }\n\n    \n\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n    function DAO() public view returns(address){\n        return iVADER(VADER).DAO();\n    }\n    function emitting() public view returns(bool){\n        return iVADER(VADER).emitting();\n    }\n    function isCurated(address token) public view returns(bool curated) {\n        if(_isCurated[token]){\n            curated = true;\n        }\n    }\n    function isPool(address token) public view returns(bool pool) {\n        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\n            pool = true;\n        }\n    }\n\n    function getMemberBaseDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_depositBase[member][token];\n    }\n    function getMemberTokenDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_depositToken[member][token];\n    }\n    function getMemberLastDeposit(address member, address token) external view returns(uint) {\n        return mapMemberToken_lastDeposited[member][token];\n    }\n    function getMemberCollateral(address member, address collateralAsset, address debtAsset) external view returns(uint) {\n        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].collateral[debtAsset];\n    }\n    function getMemberDebt(address member, address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].debt[debtAsset];\n    }\n    function getSystemCollateral(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_Collateral[collateralAsset][debtAsset];\n    }\n    function getSystemDebt(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_Debt[collateralAsset][debtAsset];\n    }\n    function getSystemInterestPaid(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralDebt_interestPaid[collateralAsset][debtAsset];\n    }\n    function getNextEraTime(address collateralAsset, address debtAsset) public view returns(uint) {\n        return mapCollateralAsset_NextEra[collateralAsset][debtAsset];\n    }\n}contract Synth is iERC20 {\n\n    address public FACTORY;\n    address public TOKEN;\n\n    // Coin Defaults\n    string public override name;\n    string public override symbol;\n    uint public override decimals  = 18;\n    uint public override totalSupply;\n\n    // ERC-20 Mappings\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    modifier onlyFACTORY() {\n        require(msg.sender == FACTORY, \"!FACTORY\");\n        _;\n    }\n    \n    // Minting event\n    constructor(address _token){\n        TOKEN = _token;\n        FACTORY = msg.sender;\n        string memory synthName = \" - vSynth\";\n        string memory synthSymbol = \".v\";\n        name = string(abi.encodePacked(iERC20(_token).name(), synthName));\n        symbol = string(abi.encodePacked(iERC20(_token).symbol(), synthSymbol));\n    }\n\n    \n    //========================================iERC20=========================================//\n    function balanceOf(address account) public view override returns (uint) {\n        return _balances[account];\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint) {\n        return _allowances[owner][spender];\n    }\n    // iERC20 Transfer function\n    function transfer(address recipient, uint amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    // iERC20 Approve, change allowance functions\n    function approve(address spender, uint amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function _approve(address owner, address spender, uint amount) internal virtual {\n        require(owner != address(0), \"sender\");\n        require(spender != address(0), \"spender\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    // iERC20 TransferFrom function\n    function transferFrom(address sender, address recipient, uint amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    // TransferTo function\n    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. \n    function transferTo(address recipient, uint amount) public virtual override returns (bool) {\n        _transfer(tx.origin, recipient, amount);\n        return true;\n    }\n\n    // Internal transfer function\n    function _transfer(address sender, address recipient, uint amount) internal virtual {\n        require(sender != address(0), \"sender\");\n        require(recipient != address(this), \"recipient\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n    // Only FACTORY can mint\n    function mint(address account, uint amount) external virtual onlyFACTORY {\n        require(account != address(0), \"recipient\");\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n    // Burn supply\n    function burn(uint amount) public virtual override {\n        _burn(msg.sender, amount);\n    }\n    function burnFrom(address account, uint amount) public virtual override {\n        uint decreasedAllowance = allowance(account, msg.sender) - amount;\n        _approve(account, msg.sender, decreasedAllowance);\n        _burn(account, amount);\n    }\n    function _burn(address account, uint amount) internal virtual {\n        require(account != address(0), \"address err\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n}contract Pools {\n\n    // Parameters\n    bool private inited;\n    uint public pooledVADER;\n    uint public pooledUSDV;\n    \n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public FACTORY;\n\n    mapping(address => bool) _isMember;\n    mapping(address => bool) _isAsset;\n    mapping(address => bool) _isAnchor;\n\n    mapping(address => uint) public mapToken_Units;\n    mapping(address => mapping(address => uint)) public mapTokenMember_Units;\n    mapping(address => uint) public mapToken_baseAmount;\n    mapping(address => uint) public mapToken_tokenAmount;\n\n    // Events\n    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);\n    event RemoveLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits, uint totalUnits);\n    event Swap(address indexed member, address indexed inputToken, uint inputAmount, address indexed outputToken, uint outputAmount, uint swapFee);\n    event Sync(address indexed token, address indexed pool, uint addedAmount);\n    event SynthSync(address indexed token, uint burntSynth, uint deletedUnits);\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {}\n\n    // Init\n    function init(address _vader, address _usdv, address _router, address _factory) public {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        FACTORY = _factory;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {\n        require(token != USDV && token != VADER); // Prohibited\n        uint _actualInputBase;\n        if(base == VADER){\n            if(!isAnchor(token)){               // If new Anchor\n                _isAnchor[token] = true;\n            }\n            _actualInputBase = getAddedAmount(VADER, token);\n        } else if (base == USDV) {\n            if(!isAsset(token)){               // If new Asset\n                _isAsset[token] = true;\n            }\n            _actualInputBase = getAddedAmount(USDV, token);\n        }\n        uint _actualInputToken = getAddedAmount(token, token);\n        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);\n        mapTokenMember_Units[token][member] += liquidityUnits;  // Add units to member\n        mapToken_Units[token] += liquidityUnits;                // Add in total\n        mapToken_baseAmount[token] += _actualInputBase;         // Add BASE\n        mapToken_tokenAmount[token] += _actualInputToken;       // Add token\n        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);\n    }\n\n    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, tx.origin); // Because this contract is wrapped by a router\n    }\n    function removeLiquidityDirectly(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {\n        return _removeLiquidity(base, token, basisPoints, msg.sender); // If want to interact directly\n    }\n    function _removeLiquidity(address base, address token, uint basisPoints, address member) internal returns (uint outputBase, uint outputToken) {\n        require(base == USDV || base == VADER);\n        uint _units = iUTILS(UTILS()).calcPart(basisPoints, mapTokenMember_Units[token][member]);\n        outputBase = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_baseAmount[token]);\n        outputToken = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_tokenAmount[token]);\n        mapToken_Units[token] -=_units;\n        mapTokenMember_Units[token][member] -= _units;\n        mapToken_baseAmount[token] -= outputBase;\n        mapToken_tokenAmount[token] -= outputToken;\n        emit RemoveLiquidity(member, base, outputBase, token, outputToken, _units, mapToken_Units[token]);\n        transferOut(base, outputBase, member);\n        transferOut(token, outputToken, member);\n        return (outputBase, outputToken);\n    }\n    \n    //=======================================SWAP===========================================//\n    \n    // Designed to be called by a router, but can be called directly\n    function swap(address base, address token, address member, bool toBase) external returns (uint outputAmount) {\n        if(toBase){\n            uint _actualInput = getAddedAmount(token, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);\n            mapToken_tokenAmount[token] += _actualInput;\n            mapToken_baseAmount[token] -= outputAmount;\n            emit Swap(member, token, _actualInput, base, outputAmount, _swapFee);\n            transferOut(base, outputAmount, member);\n        } else {\n            uint _actualInput = getAddedAmount(base, token);\n            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);\n            mapToken_baseAmount[token] += _actualInput;\n            mapToken_tokenAmount[token] -= outputAmount;\n            emit Swap(member, base, _actualInput, token, outputAmount, _swapFee);\n            transferOut(token, outputAmount, member);\n        }\n    }\n\n    // Add to balances directly (must send first)\n    function sync(address token, address pool) external {\n        uint _actualInput = getAddedAmount(token, pool);\n        if (token == VADER || token == USDV){\n            mapToken_baseAmount[pool] += _actualInput;\n        } else {\n            mapToken_tokenAmount[pool] += _actualInput;\n        // } else if(isSynth()){\n        //     //burnSynth && deleteUnits\n        }\n        emit Sync(token, pool, _actualInput);\n    }\n\n    //======================================SYNTH=========================================//\n\n    // Should be done with intention, is gas-intensive\n    function deploySynth(address token) external {\n        require(token != VADER || token != USDV);\n        iFACTORY(FACTORY).deploySynth(token);\n    }\n\n    // Mint a Synth against its own pool\n    function mintSynth(address base, address token, address member) external returns (uint outputAmount) {\n        require(iFACTORY(FACTORY).isSynth(getSynth(token)), \"!synth\");\n        uint _actualInputBase = getAddedAmount(base, token);                    // Get input\n        uint _synthUnits = iUTILS(UTILS()).calcSynthUnits(_actualInputBase, mapToken_baseAmount[token], mapToken_Units[token]);     // Get Units\n        outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInputBase, mapToken_baseAmount[token], mapToken_tokenAmount[token]);   // Get output\n        mapTokenMember_Units[token][address(this)] += _synthUnits;                  // Add units for self\n        mapToken_Units[token] += _synthUnits;                                       // Add supply\n        mapToken_baseAmount[token] += _actualInputBase;                             // Add BASE \n        emit AddLiquidity(member, base, _actualInputBase, token, 0, _synthUnits);   // Add Liquidity Event\n        iFACTORY(FACTORY).mintSynth(getSynth(token), member, outputAmount);         // Ask factory to mint to member\n    }\n    // Burn a Synth to get out BASE\n    function burnSynth(address base, address token, address member) external returns (uint outputBase) {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        outputBase = iUTILS(UTILS()).calcSwapOutput(_actualInputSynth, mapToken_tokenAmount[token], mapToken_baseAmount[token]);    // Get output\n        mapToken_baseAmount[token] -= outputBase;                                   // Remove BASE\n        emit RemoveLiquidity(member, base, outputBase, token, 0, _unitsToDelete, mapToken_Units[token]);        // Remove liquidity event\n        transferOut(base, outputBase, member);                                      // Send BASE to member\n    }\n    // Remove a synth, make other LPs richer\n    function syncSynth(address token) external {\n        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input\n        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata\n        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it\n        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self\n        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units\n        emit SynthSync(token, _actualInputSynth, _unitsToDelete);\n    }\n\n    //======================================LENDING=========================================//\n    \n    // Assign units to callee (ie, a LendingRouter)\n    function lockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][member] -= units;\n        mapTokenMember_Units[token][msg.sender] += units;       // Assign to protocol\n    }\n    // Assign units to callee (ie, a LendingRouter)\n    function unlockUnits(uint units, address token, address member) external {\n        mapTokenMember_Units[token][msg.sender] -= units;      \n        mapTokenMember_Units[token][member] += units;\n    }\n\n    //======================================HELPERS=========================================//\n\n    // Safe adds\n    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(_token == VADER && _pool != VADER){  // Want to know added VADER\n            addedAmount = _balance - pooledVADER;\n            pooledVADER = pooledVADER + addedAmount;\n        } else if(_token == USDV) {             // Want to know added USDV\n            addedAmount = _balance - pooledUSDV;\n            pooledUSDV = pooledUSDV + addedAmount;\n        } else {                                // Want to know added Asset/Anchor\n            addedAmount = _balance - mapToken_tokenAmount[_pool];\n        }\n    }\n    function transferOut(address _token, uint _amount, address _recipient) internal {\n        if(_token == VADER){\n            pooledVADER = pooledVADER - _amount; // Accounting\n        } else if(_token == USDV) {\n            pooledUSDV = pooledUSDV - _amount;  // Accounting\n        }\n        if(_recipient != address(this)){\n            iERC20(_token).transfer(_recipient, _amount);\n        }\n    }\n\n    function isMember(address member) public view returns(bool) {\n        return _isMember[member];\n    }\n    function isAsset(address token) public view returns(bool) {\n        return _isAsset[token];\n    }\n    function isAnchor(address token) public view returns(bool) {\n        return _isAnchor[token];\n    }\n    function getPoolAmounts(address token) external view returns(uint, uint) {\n        return (getBaseAmount(token), getTokenAmount(token));\n    }\n    function getBaseAmount(address token) public view returns(uint) {\n        return mapToken_baseAmount[token];\n    }\n    function getTokenAmount(address token) public view returns(uint) {\n        return mapToken_tokenAmount[token];\n    }\n    function getUnits(address token) external view returns(uint) {\n        return mapToken_Units[token];\n    }\n    function getMemberUnits(address token, address member) external view returns(uint) {\n        return mapTokenMember_Units[token][member];\n    }\n    function getSynth(address token) public view returns (address) {\n        return iFACTORY(FACTORY).getSynth(token);\n    }\n    function isSynth(address token) public view returns (bool) {\n        return iFACTORY(FACTORY).isSynth(token);\n    }\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n}contract USDV is iERC20 {\n\n    // ERC-20 Parameters\n    string public override name; string public override symbol;\n    uint public override decimals; uint public override totalSupply;\n\n    // ERC-20 Mappings\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    // Parameters\n    bool private inited;\n    uint public nextEraTime;\n    uint public blockDelay;\n\n    address public VADER;\n    address public VAULT;\n    address public ROUTER;\n\n    mapping(address => uint) public lastBlock;\n\n    // Only DAO can execute\n    modifier onlyDAO() {\n        require(msg.sender == DAO(), \"Not DAO\");\n        _;\n    }\n    // Stop flash attacks\n    modifier flashProof() {\n        require(isMature(), \"No flash\");\n        _;\n    }\n    function isMature() public view returns(bool isMatured){\n        if(lastBlock[tx.origin] + blockDelay <= block.number){ // Stops an EOA doing a flash attack in same block\n            return true;\n        }\n    }\n\n    //=====================================CREATION=========================================//\n    // Constructor\n    constructor() {\n        name = 'VADER STABLE DOLLAR';\n        symbol = 'USDV';\n        decimals = 18;\n        totalSupply = 0;\n    }\n    function init(address _vader, address _vault, address _router) external {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        VAULT = _vault;\n        ROUTER = _router;\n        nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra();\n    }\n\n    //========================================iERC20=========================================//\n    function balanceOf(address account) public view override returns (uint) {\n        return _balances[account];\n    }\n    function allowance(address owner, address spender) public view virtual override returns (uint) {\n        return _allowances[owner][spender];\n    }\n    // iERC20 Transfer function\n    function transfer(address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    // iERC20 Approve, change allowance functions\n    function approve(address spender, uint amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function _approve(address owner, address spender, uint amount) internal virtual {\n        require(owner != address(0), \"sender\");\n        require(spender != address(0), \"spender\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    // iERC20 TransferFrom function\n    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        return true;\n    }\n\n    // TransferTo function\n    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. \n    function transferTo(address recipient, uint amount) external virtual override returns (bool) {\n        _transfer(tx.origin, recipient, amount);\n        return true;\n    }\n\n    // Internal transfer function\n    function _transfer(address sender, address recipient, uint amount) internal virtual {\n        if(amount > 0){                                     // Due to design, this function may be called with 0\n            require(sender != address(0), \"sender\");\n            _balances[sender] -= amount;\n            _balances[recipient] += amount;\n            emit Transfer(sender, recipient, amount);\n            _checkIncentives();\n        }\n    }\n    // Internal mint (upgrading and daily emissions)\n    function _mint(address account, uint amount) internal virtual {\n        if(amount > 0){                                     // Due to design, this function may be called with 0\n            require(account != address(0), \"recipient\");\n            totalSupply += amount;\n            _balances[account] += amount;\n            emit Transfer(address(0), account, amount);\n        }\n    }\n    // Burn supply\n    function burn(uint amount) external virtual override {\n        _burn(msg.sender, amount);\n    }\n    function burnFrom(address account, uint amount) external virtual override {\n        uint decreasedAllowance = allowance(account, msg.sender)- amount;\n        _approve(account, msg.sender, decreasedAllowance);\n        _burn(account, amount);\n    }\n    function _burn(address account, uint amount) internal virtual {\n        if(amount > 0){                                     // Due to design, this function may be called with 0\n            require(account != address(0), \"address err\");\n            _balances[account] -= amount;\n            totalSupply -= amount;\n            emit Transfer(account, address(0), amount);\n        }\n    }\n\n    //=========================================DAO=========================================//\n    // Can set params\n    function setParams(uint newDelay) external onlyDAO {\n        blockDelay = newDelay;\n    }\n\n   //======================================INCENTIVES========================================//\n    // Internal - Update incentives function\n    function _checkIncentives() private {\n        if (block.timestamp >= nextEraTime && emitting()) {                 // If new Era\n            nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra(); \n            uint _balance = iERC20(VADER).balanceOf(address(this));         // Get spare VADER\n            if(_balance > 4){\n                uint _USDVShare = _balance/2;                                   // Get 50%\n                _convert(address(this), _USDVShare);                            // Convert it\n                if(balanceOf(address(this)) > 2){\n                    _transfer(address(this), ROUTER, balanceOf(address(this)) / 2);              // Send half USDV to ROUTER\n                    _transfer(address(this), VAULT, balanceOf(address(this)));                   // Send rest to VAULT\n                }\n                iERC20(VADER).transfer(ROUTER, iERC20(VADER).balanceOf(address(this))/2);   // Send half VADER to ROUTER\n                iERC20(VADER).transfer(VAULT, iERC20(VADER).balanceOf(address(this)));      // Send rest to VAULT\n            }\n        }\n    }\n    \n    //======================================ASSET MINTING========================================//\n    // Convert to USDV\n    function convert(uint amount) external returns(uint) {\n        return convertForMember(msg.sender, amount);\n    }\n    // Convert for members\n    function convertForMember(address member, uint amount) public returns(uint) {\n        getFunds(VADER, amount);\n        return _convert(member, amount);\n    }\n    // Internal convert\n    function _convert(address _member, uint amount) internal flashProof returns(uint _convertAmount){\n        if(minting()){\n            lastBlock[tx.origin] = block.number;                    // Record first\n            iERC20(VADER).burn(amount);\n            _convertAmount = iROUTER(ROUTER).getUSDVAmount(amount); // Critical pricing functionality\n            _mint(_member, _convertAmount);\n        }\n    }\n    // Redeem to VADER\n    function redeem(uint amount) external returns(uint) {\n        return redeemForMember(msg.sender, amount);\n    }\n    // Contracts to redeem for members\n    function redeemForMember(address member, uint amount) public returns(uint redeemAmount) {\n        _transfer(msg.sender, VADER, amount);                   // Move funds\n        redeemAmount = iVADER(VADER).redeemToMember(member);    // Ask VADER to redeem\n        lastBlock[tx.origin] = block.number;                    // Must record block AFTER the tx\n    }\n\n    //============================== ASSETS ================================//\n\n    function getFunds(address token, uint amount) internal {\n        if(token == address(this)){\n            _transfer(msg.sender, address(this), amount);\n        } else {\n            if(tx.origin==msg.sender){\n                require(iERC20(token).transferTo(address(this), amount));\n            }else{\n                require(iERC20(token).transferFrom(msg.sender, address(this), amount));\n            }\n        }\n    }\n\n    //============================== HELPERS ================================//\n\n    function DAO() public view returns(address){\n        return iVADER(VADER).DAO();\n    }\n    function emitting() public view returns(bool){\n        return iVADER(VADER).emitting();\n    }\n    function minting() public view returns(bool){\n        return iVADER(VADER).minting();\n    }\n\n}",
    "bin": []
}