{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/57/ibbtc",
    "external_functions": [
        [
            "Core",
            "BadgerGuestListAPI",
            "IbBTC",
            "IERC20",
            "IPeak"
        ],
        [
            "Zap",
            "IBadgerSettPeak",
            "ISett",
            "IbyvWbtc",
            "IByvWbtcPeak",
            "IERC20",
            "ICurveFi",
            "IController",
            "IStrategy"
        ],
        [
            "bBTC",
            "ICore"
        ]
    ],
    "new_contract": "contract Core is GovernableProxy, ICore {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n    using Math for uint;\n\n    uint constant PRECISION = 1e4;\n\n    IbBTC public immutable bBTC;\n\n    BadgerGuestListAPI public guestList;\n\n    enum PeakState { Extinct, Active, Dormant }\n    mapping(address => PeakState) public peaks;\n\n    address[] public peakAddresses;\n    address public feeSink;\n    uint public mintFee;\n    uint public redeemFee;\n    uint public accumulatedFee;\n\n    uint256[50] private __gap;\n\n    // END OF STORAGE VARIABLES\n\n    event PeakWhitelisted(address indexed peak);\n    event FeeCollected(uint amount);\n\n    /**\n    * @param _bBTC bBTC token address\n    */\n    constructor(address _bBTC) public {\n        require(_bBTC != address(0), \"NULL_ADDRESS\");\n        bBTC = IbBTC(_bBTC);\n    }\n\n    /**\n    * @notice Mint bBTC\n    * @dev Only whitelisted peaks can call this function\n    * @param btc BTC amount supplied, scaled by 1e18\n    * @return bBtc Badger BTC that was minted\n    */\n    function mint(uint btc, address account, bytes32[] calldata merkleProof)\n        override\n        external\n        returns(uint)\n    {\n        require(peaks[msg.sender] == PeakState.Active, \"PEAK_INACTIVE\");\n        if (address(guestList) != address(0)) {\n            require(\n                guestList.authorized(account, btc, merkleProof),\n                \"guest-list-authorization\"\n            );\n        }\n        (uint bBtc, uint fee) = btcToBbtc(btc);\n        require(bBtc > 0, \"MINTING_0_bBTC\");\n        accumulatedFee = accumulatedFee.add(fee);\n        bBTC.mint(account, bBtc);\n        return bBtc;\n    }\n\n    /**\n    * @param btc BTC amount supplied\n    */\n    function btcToBbtc(uint btc) override public view returns (uint bBtc, uint fee) {\n        uint _totalSupply = IERC20(address(bBTC)).totalSupply().add(accumulatedFee);\n        if (_totalSupply > 0) {\n            bBtc = btc.mul(_totalSupply).div(totalSystemAssets());\n        } else {\n            bBtc = btc;\n        }\n        fee = bBtc.mul(mintFee).div(PRECISION);\n        bBtc = bBtc.sub(fee);\n    }\n\n    /**\n    * @notice Redeem bBTC\n    * @dev Only whitelisted peaks can call this function\n    * @param bBtc bBTC amount to redeem\n    * @return btc amount redeemed, scaled by 1e36\n    */\n    function redeem(uint bBtc, address account) override external returns (uint) {\n        require(bBtc > 0, \"REDEEMING_0_bBTC\");\n        require(peaks[msg.sender] != PeakState.Extinct, \"PEAK_EXTINCT\");\n        (uint btc, uint fee) = bBtcToBtc(bBtc);\n        accumulatedFee = accumulatedFee.add(fee);\n        bBTC.burn(account, bBtc);\n        return btc;\n    }\n\n    /**\n    * @return btc amount redeemed, scaled by 1e36\n    */\n    function bBtcToBtc(uint bBtc) override public view returns (uint btc, uint fee) {\n        fee = bBtc.mul(redeemFee).div(PRECISION);\n        btc = bBtc.sub(fee).mul(pricePerShare());\n    }\n\n    function pricePerShare() override public view returns (uint) {\n        uint _totalSupply = IERC20(address(bBTC)).totalSupply().add(accumulatedFee);\n        if (_totalSupply > 0) {\n            return totalSystemAssets().mul(1e18).div(_totalSupply);\n        }\n        return 1e18;\n    }\n\n    /**\n    * @notice Collect all the accumulated fee (denominated in bBTC)\n    */\n    function collectFee() external {\n        require(feeSink != address(0), \"NULL_ADDRESS\");\n        uint _fee = accumulatedFee;\n        require(_fee > 0, \"NO_FEE\");\n        accumulatedFee = 0;\n        bBTC.mint(feeSink, _fee);\n        emit FeeCollected(_fee);\n    }\n\n    function totalSystemAssets() public view returns (uint totalAssets) {\n        address[] memory _peakAddresses = peakAddresses;\n        uint numPeaks = _peakAddresses.length;\n        for (uint i = 0; i < numPeaks; i++) {\n            if (peaks[_peakAddresses[i]] == PeakState.Extinct) {\n                continue;\n            }\n            totalAssets = totalAssets.add(\n                IPeak(_peakAddresses[i]).portfolioValue()\n            );\n        }\n    }\n\n    /* ##### Governance ##### */\n\n    /**\n    * @notice Whitelist a new peak\n    * @param peak Address of the contract that interfaces with the 3rd-party protocol\n    */\n    function whitelistPeak(address peak)\n        external\n        onlyGovernance\n    {\n        require(\n            peaks[peak] == PeakState.Extinct,\n            \"DUPLICATE_PEAK\"\n        );\n\n        address[] memory _peakAddresses = peakAddresses;\n        uint numPeaks = _peakAddresses.length;\n        for (uint i = 0; i < numPeaks; i++) {\n            require(_peakAddresses[i] != peak, \"USE_setPeakStatus\");\n        }\n\n        IPeak(peak).portfolioValue(); // sanity check\n        peakAddresses.push(peak);\n        peaks[peak] = PeakState.Active;\n        emit PeakWhitelisted(peak);\n    }\n\n    /**\n    * @notice Change a peaks status\n    */\n    function setPeakStatus(address peak, PeakState state)\n        external\n        onlyGovernance\n    {\n        require(\n            peaks[peak] != PeakState.Extinct,\n            \"Peak is extinct\"\n        );\n        if (state == PeakState.Extinct) {\n            require(IPeak(peak).portfolioValue() <= 1e15, \"NON_TRIVIAL_FUNDS_IN_PEAK\");\n        }\n        peaks[peak] = state;\n    }\n\n    /**\n    * @notice Set config\n    * @param _mintFee Mint Fee\n    * @param _redeemFee Redeem Fee\n    * @param _feeSink Address of the EOA/contract where accumulated fee will be transferred\n    */\n    function setConfig(\n        uint _mintFee,\n        uint _redeemFee,\n        address _feeSink\n    )\n        external\n        onlyGovernance\n    {\n        require(\n            _mintFee <= PRECISION\n            && _redeemFee <= PRECISION,\n            \"INVALID_PARAMETERS\"\n        );\n        require(_feeSink != address(0), \"NULL_ADDRESS\");\n\n        mintFee = _mintFee;\n        redeemFee = _redeemFee;\n        feeSink = _feeSink;\n    }\n\n    function setGuestList(address _guestList) external onlyGovernance {\n        guestList = BadgerGuestListAPI(_guestList);\n    }\n}\ncontract GovernableProxy {\n    bytes32 constant OWNER_SLOT = keccak256(\"proxy.owner\");\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() internal {\n        _transferOwnership(msg.sender);\n    }\n\n    modifier onlyGovernance() {\n        require(owner() == msg.sender, \"NOT_OWNER\");\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns(address _owner) {\n        bytes32 position = OWNER_SLOT;\n        assembly {\n            _owner := sload(position)\n        }\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function transferOwnership(address newOwner) external onlyGovernance {\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"OwnableProxy: new owner is the zero address\");\n        emit OwnershipTransferred(owner(), newOwner);\n        bytes32 position = OWNER_SLOT;\n        assembly {\n            sstore(position, newOwner)\n        }\n    }\n}\ncontract AccessControlDefendedBase {\n    mapping (address => bool) public approved;\n    mapping(address => uint256) public blockLock;\n\n    modifier defend() {\n        require(msg.sender == tx.origin || approved[msg.sender], \"ACCESS_DENIED\");\n        _;\n    }\n\n    modifier blockLocked() {\n        require(approved[msg.sender] || blockLock[msg.sender] < block.number, \"BLOCK_LOCKED\");\n        _;\n    }\n\n    function _lockForBlock(address account) internal {\n        blockLock[account] = block.number;\n    }\n\n    function _approveContractAccess(address account) internal {\n        approved[account] = true;\n    }\n\n    function _revokeContractAccess(address account) internal {\n        approved[account] = false;\n    }\n}\ncontract bBTC is ERC20, IbBTC {\n    address public core;\n\n    constructor(address _core)\n        public\n        ERC20(\"Interest-Bearing BTC\", \"ibBTC\")\n    {\n        require(_core != address(0), \"NULL_ADDRESS\");\n        core = _core;\n    }\n\n    modifier onlyCore() {\n        require(msg.sender == core, \"bBTC: NO_AUTH\");\n        _;\n    }\n\n    function mint(address account, uint amount) override external onlyCore {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint amount) override external onlyCore {\n        _burn(account, amount);\n    }\n\n    function switchCore(address _core) external onlyCore {\n        require(_core != address(0), \"NULL_ADDRESS\");\n        core = _core;\n    }\n\n    function pricePerShare() external view returns (uint) {\n        return ICore(core).pricePerShare();\n    }\n}\ncontract Zap is Initializable, Pausable, AccessControlDefendedBase {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    IBadgerSettPeak public constant settPeak = IBadgerSettPeak(0x41671BA1abcbA387b9b2B752c205e22e916BE6e3);\n    IByvWbtcPeak public constant byvWbtcPeak = IByvWbtcPeak(0x825218beD8BE0B30be39475755AceE0250C50627);\n    IERC20 public constant ibbtc = IERC20(0xc4E15973E6fF2A35cC804c2CF9D2a1b817a8b40F);\n    IERC20 public constant ren = IERC20(0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D);\n    IERC20 public constant wbtc = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\n    IController public constant controller = IController(0x63cF44B2548e4493Fd099222A1eC79F3344D9682);\n\n    struct Pool {\n        IERC20 lpToken;\n        ICurveFi deposit;\n        ISett sett;\n    }\n    Pool[4] public pools;\n\n    address public governance;\n\n    modifier onlyGovernance() {\n        require(governance == msg.sender, \"NOT_OWNER\");\n        _;\n    }\n\n    function init(address _governance) initializer external {\n        _setGovernance(_governance);\n        pools[0] = Pool({ // crvRenWBTC [ ren, wbtc ]\n            lpToken: IERC20(0x49849C98ae39Fff122806C06791Fa73784FB3675),\n            deposit: ICurveFi(0x93054188d876f558f4a66B2EF1d97d16eDf0895B),\n            sett: ISett(0x6dEf55d2e18486B9dDfaA075bc4e4EE0B28c1545)\n        });\n        pools[1] = Pool({ // crvRenWSBTC [ ren, wbtc, sbtc ]\n            lpToken: IERC20(0x075b1bb99792c9E1041bA13afEf80C91a1e70fB3),\n            deposit: ICurveFi(0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714),\n            sett: ISett(0xd04c48A53c111300aD41190D63681ed3dAd998eC)\n        });\n        pools[2] = Pool({ // tbtc-sbtcCrv [ tbtc, ren, wbtc, sbtc ]\n            lpToken: IERC20(0x64eda51d3Ad40D56b9dFc5554E06F94e1Dd786Fd),\n            deposit: ICurveFi(0xaa82ca713D94bBA7A89CEAB55314F9EfFEdDc78c),\n            sett: ISett(0xb9D076fDe463dbc9f915E5392F807315Bf940334)\n        });\n        pools[3] = Pool({ // Exclusive to wBTC\n            lpToken: wbtc,\n            deposit: ICurveFi(0x0),\n            sett: ISett(0x4b92d19c11435614CD49Af1b589001b7c08cD4D5) // byvWbtc\n        });\n\n        // Since we don't hold any tokens in this contract, we can optimize gas usage in mint calls by providing infinite approvals\n        for (uint i = 0; i < pools.length; i++) {\n            Pool memory pool = pools[i];\n            pool.lpToken.safeApprove(address(pool.sett), uint(-1));\n            if (i < 3) {\n                ren.safeApprove(address(pool.deposit), uint(-1));\n                wbtc.safeApprove(address(pool.deposit), uint(-1));\n                IERC20(address(pool.sett)).safeApprove(address(settPeak), uint(-1));\n            } else {\n                IERC20(address(pool.sett)).safeApprove(address(byvWbtcPeak), uint(-1));\n            }\n        }\n        pools[2].lpToken.safeApprove(address(pools[2].deposit), uint(-1));\n    }\n\n    /**\n    * @notice Mint ibbtc with wBTC / renBTC\n    * @param token wBTC or renBTC address\n    * @param amount wBTC or renBTC amount\n    * @param poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv, 3=yvWbtc\n    * @param idx Index of the token in the curve pool while adding liquidity; redundant for yvWbtc\n    * @param minOut Minimum amount of ibbtc to mint. Use for capping slippage while adding liquidity to curve pool.\n    * @return _ibbtc Minted ibbtc amount\n    */\n    function mint(IERC20 token, uint amount, uint poolId, uint idx, uint minOut)\n        external\n        defend\n        blockLocked\n        whenNotPaused\n        returns(uint _ibbtc)\n    {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        Pool memory pool = pools[poolId];\n        if (poolId < 3) { // setts\n            _addLiquidity(pool.deposit, amount, poolId + 2, idx); // pools are such that the #tokens they support is +2 from their poolId.\n            pool.sett.deposit(pool.lpToken.balanceOf(address(this)));\n            _ibbtc = settPeak.mint(poolId, pool.sett.balanceOf(address(this)), new bytes32[](0));\n        } else if (poolId == 3) { // byvwbtc\n            IbyvWbtc(address(pool.sett)).deposit(new bytes32[](0)); // pulls all available\n            _ibbtc = byvWbtcPeak.mint(pool.sett.balanceOf(address(this)), new bytes32[](0));\n        } else {\n            revert(\"INVALID_POOL_ID\");\n        }\n\n        require(_ibbtc >= minOut, \"INSUFFICIENT_IBBTC\"); // used for capping slippage in curve pools\n        ibbtc.safeTransfer(msg.sender, _ibbtc);\n    }\n\n    /**\n    * @dev Add liquidity to curve btc pools\n    * @param amount wBTC / renBTC amount\n    * @param pool Curve btc pool\n    * @param numTokens # supported tokens for the curve pool\n    * @param idx Index of the supported token in the curve pool in question\n    */\n    function _addLiquidity(ICurveFi pool, uint amount, uint numTokens, uint idx) internal {\n        if (numTokens == 2) {\n            uint[2] memory amounts;\n            amounts[idx] = amount;\n            pool.add_liquidity(amounts, 0);\n        }\n\n        if (numTokens == 3) {\n            uint[3] memory amounts;\n            amounts[idx] = amount;\n            pool.add_liquidity(amounts, 0);\n        }\n\n        if (numTokens == 4) {\n            uint[4] memory amounts;\n            amounts[idx] = amount;\n            pool.add_liquidity(amounts, 0);\n        }\n    }\n\n    /**\n    * @notice Calculate the most optimal route and expected ibbtc amount when minting with wBTC / renBtc.\n    * @dev Use returned params poolId, idx and bBTC in the call to mint(...)\n           The last param `minOut` in mint(...) should be a bit less than the returned bBTC value.\n           For instance 0.2% - 1% lesser depending on slippage tolerange.\n    * @param amount renBTC amount\n    * @return poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv, 3=byvwbtc\n    * @return idx Index of the supported token in the curve pool (poolId). Should be ignored for poolId=3\n    * @return bBTC Expected ibbtc. Not for precise calculations. Doesn't factor in (deposit) fee charged by the curve pool / byvwbtc.\n    * @return fee Fee being charged by ibbtc system. Denominated in corresponding sett token\n    */\n    function calcMint(address token, uint amount) external view returns(uint poolId, uint idx, uint bBTC, uint fee) {\n        if (token == address(ren)) {\n            return calcMintWithRen(amount);\n        }\n        if (token == address(wbtc)) {\n            return calcMintWithWbtc(amount);\n        }\n        revert(\"INVALID_TOKEN\");\n    }\n\n    /**\n    * @notice Calculate mint through renWBTC pool route and expected ibbtc amount when minting with renBTC.\n    * @dev Use returned params poolId, idx and bBTC in the call to mint(...)\n           The last param `minOut` in mint(...) should be a bit more than the returned bBTC value.\n           For instance 0.2% - 1% higher depending on slippage tolerange.\n    * @param amount renBTC amount\n    * @return poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv\n    * @return idx Index of the supported token in the curve pool (poolId)\n    * @return bBTC Expected ibbtc. Not for precise calculations. Doesn't factor in fee charged by the curve pool\n    * @return fee Fee being charged by ibbtc system. Denominated in corresponding sett token\n    */\n    function calcMintWithRen(uint amount) public view returns(uint poolId, uint idx, uint bBTC, uint fee) {\n        uint _ibbtc;\n        uint _fee;\n\n        // poolId=0, idx=0\n        (bBTC, fee) = curveLPToIbbtc(0, pools[0].deposit.calc_token_amount([amount,0], true));\n    }\n\n    /**\n    * @notice Calculate mint through renWBTC pool route and expected ibbtc amount when minting with wBTC.\n    * @dev Use returned params poolId, idx and bBTC in the call to mint(...)\n           The last param `minOut` in mint(...) should be a bit more than the returned bBTC value.\n           For instance 0.2% - 1% higher depending on slippage tolerange.\n    * @param amount renBTC amount\n    * @return poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv, 3=byvwbtc\n    * @return idx Index of the supported token in the curve pool (poolId). Should be ignored for poolId=3\n    * @return bBTC Expected ibbtc. Not for precise calculations. Doesn't factor in (deposit) fee charged by the curve pool / byvwbtc.\n    * @return fee Fee being charged by ibbtc system. Denominated in corresponding sett token\n    */\n    function calcMintWithWbtc(uint amount) public view returns(uint poolId, uint idx, uint bBTC, uint fee) {\n        uint _ibbtc;\n        uint _fee;\n\n        // poolId=0\n        (bBTC, fee) = curveLPToIbbtc(0, pools[0].deposit.calc_token_amount([0,amount], true));\n        idx = 1;\n    }\n\n    /**\n    * @dev Curve LP token amount to expected ibbtc amount\n    */\n    function curveLPToIbbtc(uint poolId, uint _lp) public view returns(uint bBTC, uint fee) {\n        Pool memory pool = pools[poolId];\n        uint _sett = _lp.mul(1e18).div(pool.sett.getPricePerFullShare());\n        return settPeak.calcMint(poolId, _sett);\n    }\n\n    // Redeem Methods\n\n    function redeem(IERC20 token, uint amount, uint poolId, int128 idx, uint minOut)\n        external\n        defend\n        blockLocked\n        whenNotPaused\n        returns(uint out)\n    {\n        ibbtc.safeTransferFrom(msg.sender, address(this), amount);\n\n        Pool memory pool = pools[poolId];\n        if (poolId < 3) { // setts\n            settPeak.redeem(poolId, amount);\n            pool.sett.withdrawAll();\n            pool.deposit.remove_liquidity_one_coin(pool.lpToken.balanceOf(address(this)), idx, minOut);\n        } else if (poolId == 3) { // byvwbtc\n            byvWbtcPeak.redeem(amount);\n            IbyvWbtc(address(pool.sett)).withdraw(); // withdraws all available\n        } else {\n            revert(\"INVALID_POOL_ID\");\n        }\n        out = token.balanceOf(address(this));\n        token.safeTransfer(msg.sender, out);\n    }\n\n    /**\n    * @notice Calculate redeem through renWBTC pool route and expected token amount when redeeming ibbtc.\n    * @dev Use returned params poolId, idx and out in the call to redeem(...)\n           The last param `redeem` in mint(...) should be a bit less than the returned `out` value.\n           For instance 0.2% - 1% lesser depending on slippage tolerange.\n    * @param amount ibbtc amount\n    * @return poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv, 3=byvwbtc\n    * @return idx Index of the supported token in the curve pool (poolId). Should be ignored for poolId=3\n    * @return out Expected amount for token. Not for precise calculations. Doesn't factor in (deposit) fee charged by the curve pool / byvwbtc.\n    * @return fee Fee being charged by ibbtc + setts. Denominated in corresponding sett token\n    */\n    function calcRedeem(address token, uint amount) external view returns(uint poolId, uint idx, uint out, uint fee) {\n        if (token == address(ren)) {\n            return calcRedeemInRen(amount);\n        }\n        if (token == address(wbtc)) {\n            return calcRedeemInWbtc(amount);\n        }\n        revert(\"INVALID_TOKEN\");\n    }\n\n    /**\n    * @notice Calculate redeem through renWBTC pool route and expected renbtc amount when redeeming ibbtc.\n    * @dev Use returned params poolId, idx and renAmount in the call to redeem(...)\n           The last param `minOut` in redeem(...) should be a bit less than the returned renAmount value.\n           For instance 0.2% - 1% lesser depending on slippage tolerange.\n    * @param amount ibbtc amount\n    * @return poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv\n    * @return idx Index of the supported token in the curve pool (poolId)\n    * @return renAmount Expected renBtc. Not for precise calculations. Doesn't factor in fee charged by the curve pool\n    * @return fee Fee being charged by ibbtc system. Denominated in corresponding sett token\n    */\n    function calcRedeemInRen(uint amount) public view returns(uint poolId, uint idx, uint renAmount, uint fee) {\n        uint _lp;\n        uint _fee;\n        uint _ren;\n\n        // poolId=0, idx=0\n        (_lp, fee) = ibbtcToCurveLP(0, amount);\n        renAmount = pools[0].deposit.calc_withdraw_one_coin(_lp, 0);\n    }\n\n    /**\n    * @notice Calculate the most optimal route and expected wbtc amount when redeeming ibbtc.\n    * @dev Use returned params poolId, idx and wbtc in the call to redeem(...)\n           The last param `minOut` in redeem(...) should be a bit less than the returned wbtc value.\n           For instance 0.2% - 1% lesser depending on slippage tolerange.\n    * @param amount ibbtc amount\n    * @return poolId 0=crvRenWBTC, 1=crvRenWSBTC, 2=tbtc-sbtcCrv, 3=byvwbtc\n    * @return idx Index of the supported token in the curve pool (poolId)\n    * @return wBTCAmount Expected wbtc. Not for precise calculations. Doesn't factor in fee charged by the curve pool\n    * @return fee Fee being charged by ibbtc system. Denominated in corresponding sett token\n    */\n    function calcRedeemInWbtc(uint amount) public view returns(uint poolId, uint idx, uint wBTCAmount, uint fee) {\n        uint _lp;\n        uint _fee;\n        uint _wbtc;\n\n        // poolId=0, idx=0\n        (_lp, fee) = ibbtcToCurveLP(0, amount);\n        wBTCAmount = pools[0].deposit.calc_withdraw_one_coin(_lp, 1);\n        idx = 1;\n    }\n\n    function ibbtcToCurveLP(uint poolId, uint bBtc) public view returns(uint lp, uint fee) {\n        uint sett;\n        uint max;\n        (sett,fee,max) = settPeak.calcRedeem(poolId, bBtc);\n        Pool memory pool = pools[poolId];\n        if (bBtc > max) {\n            return (0,fee);\n        } else {\n            // pesimistically charge 0.5% on the withdrawal.\n            // Actual fee might be lesser if the vault keeps keeps a buffer\n            uint strategyFee = sett.mul(controller.strategies(pool.lpToken).withdrawalFee()).div(10000);\n            lp = sett.sub(strategyFee).mul(pool.sett.getPricePerFullShare()).div(1e18);\n            fee = fee.add(strategyFee);\n        }\n    }\n\n    // Governance controls\n\n    function setGovernance(address _governance) external onlyGovernance {\n        _setGovernance(_governance);\n    }\n\n    function _setGovernance(address _governance) internal {\n        require(_governance != address(0), \"NULL_ADDRESS\");\n        governance = _governance;\n    }\n\n    function approveContractAccess(address account) external onlyGovernance {\n        _approveContractAccess(account);\n    }\n\n    function revokeContractAccess(address account) external onlyGovernance {\n        _revokeContractAccess(account);\n    }\n\n    function pause() external onlyGovernance {\n        _pause();\n    }\n\n    function unpause() external onlyGovernance {\n        _unpause();\n    }\n}\n",
    "bin": []
}