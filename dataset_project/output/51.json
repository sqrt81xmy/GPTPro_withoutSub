{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/51/vesting",
    "external_functions": [
        [
            "AirdropDistribution",
            "IERC20",
            "IVesting"
        ],
        [
            "InvestorDistribution",
            "IERC20",
            "IVesting"
        ],
        [
            "Vesting",
            "IERC20"
        ]
    ],
    "new_contract": "contract Vesting is Ownable, Pausable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // State variables===================================================================================\n    IERC20 public vestingToken;\n    address public multiSig;\n\n    // uint256 public maxVestingAmount;\n    uint256 public totalVestedAmount;\n    uint256 public totalClaimedAmount;\n    uint256 private unixYear = 52 * 7 * 24 * 60 * 60;\n\n    struct Timelock {\n        uint256 amount;\n        uint256 releaseTimestamp;\n    }\n\n    mapping(address => Timelock[]) public timelocks;\n    mapping(address => uint256) public benClaimed;      //total tokens claimed\n    mapping(address => uint256[2]) public benVested;       //total tokens vested\n    mapping(address => uint256) public benTotal;        //total locked in contract for user\n    mapping(address => uint256) public benVestingIndex;     //index to start the for loop for the user ignoring completely vested timelock\n\n    // map revocability at address level vs individual timelock\n    mapping(address => bool[2]) public benRevocable;         // key: beneficiary address, value: revokeTimestamp\n\n    // ===============EVENTS============================================================================================\n    event TokenVested(address indexed sender, uint256 amount, uint256 releaseTimestamp, uint256 currentTimestamp);\n    event TokenClaimed(address indexed beneficiary, uint256 amount, uint256 currentTimestamp);\n    event TokenRevoked(address indexed beneficiary, uint256 amount, uint256 currentTimestamp);\n    event Revoke(address indexed account, uint256 currentTimestamp);\n\n    //================CONSTRUCTOR================================================================\n    /// @notice Constructor\n    /// @param _token ERC20 token\n    constructor(\n        IERC20 _token,\n        address _multiSig\n    ) {\n        require(address(_token) != address(0) && address(_multiSig) != address(0), \"Invalid address\");\n        vestingToken = _token;\n        multiSig = _multiSig;\n\n        totalVestedAmount = 0;\n        totalClaimedAmount = 0;\n    }\n    \n\n    //=================FUNCTIONS=================================================================\n    /// @notice Vest function accessed by anyone\n    /// @param _beneficiary beneficiary address\n    /// @param _amount vesting amount\n    /// @param _isRevocable revocable value either 0 or 1\n    function vest(address _beneficiary, uint256 _amount, uint256 _isRevocable) external payable whenNotPaused {\n        require(_beneficiary != address(0), \"Invalid address\");\n        require( _amount > 0, \"amount must be positive\");\n        // require(totalVestedAmount.add(_amount) <= maxVestingAmount, 'maxVestingAmount is already vested');\n        require(_isRevocable == 0 || _isRevocable == 1, \"revocable must be 0 or 1\");\n        uint256 _unlockTimestamp = block.timestamp.add(unixYear);\n\n        Timelock memory newVesting = Timelock(_amount, _unlockTimestamp);\n        timelocks[_beneficiary].push(newVesting);\n\n        if(_isRevocable == 0){\n            benRevocable[_beneficiary] = [false,false];\n        }\n        else if(_isRevocable == 1){\n            benRevocable[_beneficiary] = [true,false];\n        }\n\n        totalVestedAmount = totalVestedAmount.add(_amount);\n        benTotal[_beneficiary] = benTotal[_beneficiary].add(_amount);\n\n        // transfer to SC using delegate transfer\n        // NOTE: the tokens has to be approved first by the caller to the SC using `approve()` method.\n        vestingToken.transferFrom(msg.sender, address(this), _amount);\n\n        emit TokenVested(_beneficiary, _amount, _unlockTimestamp, block.timestamp);\n    }\n\n    // ------------------------------------------------------------------------------------------\n    /// @notice Revoke vesting\n    /// @param _addr beneficiary address\n\n    function revoke(address _addr) public onlyOwner whenNotPaused {\n        require(benRevocable[_addr][0] == true && benRevocable[_addr][1] == false, 'Account must be revokable and not already revoked.');\n\n        uint256 amount = _claimableAmount(_addr).sub(benClaimed[_addr]);\n        assert(amount <= benTotal[_addr]);\n    \n        benClaimed[_addr] = benClaimed[_addr].add(amount);\n        totalClaimedAmount = totalClaimedAmount.add(amount);\n\n        emit TokenClaimed(_addr, amount, block.timestamp);\n\n        uint256 locked = 0;\n        for (uint256 i = 0; i < timelocks[_addr].length; i++) {\n            locked = locked.add(timelocks[_addr][i].amount);\n        }\n        delete timelocks[_addr];\n\n        uint256 bal = locked.sub(benClaimed[_addr]);\n        benRevocable[_addr][1] = true;\n        emit Revoke(_addr, block.timestamp);\n        \n        //clean slate\n        benClaimed[_addr] = 0;\n        benVested[_addr] = [0, 0];\n        benTotal[_addr] = 0;\n        benVestingIndex[_addr] = 0;\n        \n        vestingToken.safeTransfer(_addr, amount); //send vested\n\n        if (bal > 0) {\n            vestingToken.safeTransfer(multiSig, bal); //send revoked to multisig\n            emit TokenRevoked(_addr, bal, block.timestamp);\n        }\n    }\n\n    // ------------------------------------------------------------------------------------------\n    /// @notice Calculate claimable amount for a beneficiary\n    /// @param _addr beneficiary address\n    function calcClaimableAmount(address _addr) public view returns (uint256) {\n        uint256 sum = 0;\n\n        // iterate across all the vestings\n        // & check if the releaseTimestamp is elapsed\n        // then, add all the amounts as claimable amount\n        for (uint256 i = 0; i < timelocks[_addr].length; i++) {\n            if (block.timestamp >= timelocks[_addr][i].releaseTimestamp) {\n                sum = sum.add(timelocks[_addr][i].amount);\n            }\n            else {\n                uint256 iTimeStamp = timelocks[_addr][i].releaseTimestamp.sub(unixYear);\n                uint256 claimable = block.timestamp.sub(iTimeStamp).mul(timelocks[_addr][i].amount).div(unixYear);\n                sum = sum.add(claimable);\n            }\n        }\n        return sum;\n    }\n    \n    //Calculate amount claimable by a particular address\n    function _claimableAmount(address _addr) private returns (uint256) {\n        uint256 completely_vested = 0;\n        uint256 partial_sum = 0;\n        uint256 inc = 0;\n\n        // iterate across all the vestings\n        // & check if the releaseTimestamp is elapsed\n        // then, add all the amounts as claimable amount\n        for (uint256 i = benVestingIndex[_addr]; i < timelocks[_addr].length; i++) {\n            if (block.timestamp >= timelocks[_addr][i].releaseTimestamp) {\n                inc += 1;\n                completely_vested = completely_vested.add(timelocks[_addr][i].amount);\n            }\n            else {\n                uint256 iTimeStamp = timelocks[_addr][i].releaseTimestamp.sub(unixYear);\n                uint256 claimable = block.timestamp.sub(iTimeStamp).mul(timelocks[_addr][i].amount).div(unixYear);\n                partial_sum = partial_sum.add(claimable);\n            }\n        }\n\n        benVestingIndex[_addr] +=inc;\n        benVested[_addr][0] = benVested[_addr][0].add(completely_vested);\n        benVested[_addr][1] = partial_sum;\n        uint256 s = benVested[_addr][0].add(partial_sum);\n        assert(s <= benTotal[_addr]);\n        return s;\n    }\n\n    // ------------------------------------------------------------------------------------------\n    /// @notice Claim vesting\n    /// Beneficiary can claim claimableAmount which was vested\n    function claim() external whenNotPaused nonReentrant {\n        require(benRevocable[msg.sender][1] == false, 'Account must not already be revoked.');\n        uint256 amount = _claimableAmount(msg.sender).sub(benClaimed[msg.sender]);\n        require(amount > 0, \"Claimable amount must be positive\");\n        require(amount <= benTotal[msg.sender], \"Cannot withdraw more than total vested amount\");\n\n        // transfer from SC\n        benClaimed[msg.sender] = benClaimed[msg.sender].add(amount);\n        totalClaimedAmount = totalClaimedAmount.add(amount);\n        vestingToken.safeTransfer(msg.sender, amount);\n\n        emit TokenClaimed(msg.sender, amount, block.timestamp);\n    }\n\n    // ------------------------------------------------------------------------------------------\n    /// @notice Pause contract \n    function pause() public onlyOwner whenNotPaused {\n        _pause();\n    }\n\n    /// @notice Unpause contract\n    function unpause() public onlyOwner whenPaused {\n        _unpause();\n    }\n}contract InvestorDistribution is Pausable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    //Investor Shares (Angel + Seed Round)\n    struct Investors {\n        uint256 amount;\n        uint256 claimed;\n        uint256 total_tokens;\n        uint256 fraction;     // with 10**18 precision\n    }\n\n    address public admin;\n    mapping(address => Investors) public investors;\n\n    uint256 private investors_supply = 11088000 * 10 ** 18;\n\n    // General constants\n    uint256 constant HOUR = 3600;\n    uint256 constant DAY = 86400;\n    uint256 constant WEEK = 86400 * 7;\n    uint256 constant YEAR = WEEK * 52;\n\n    //INITIAL_SUPPLY: constant(uint256) = 0\n    // INFLATION_DELAY: constant(uint256) = 3 * HOUR # Three Hour delay before minting may begin\n    // RATE_DENOMINATOR: constant(uint256) = 10 ** 18\n    uint256 constant RATE_TIME = WEEK;                                         // How often the rate goes to the next epoch\n    uint256 constant INITIAL_RATE = 135_994 * 10 ** 18 / WEEK;                // 2,474,410 for the first week\n    uint256 constant EPOCH_INFLATION = 98_831;                                  // 98.831 % of last week\n    uint256 constant INITIAL_RATE_EPOCH_CUTTOF = 260;                          // After 260 Weeks use the late rate\n\n    // Supply variables\n    uint256 public miningEpoch;\n    uint256 public startEpochTime;\n    uint256 public rate;\n    uint256 public initTime;\n\n    uint256 public startEpochSupply;\n   \n    event updateMiningParameters(uint256 time, uint256 rate, uint256 supply);\n    event InvestorAdded(address indexed investor, uint256 amount, uint256 timeStamp);\n    event InvestorModified(address indexed investor, address newinvestor, uint256 timeStamp);\n    event Vested(address indexed investor, uint256 amount, uint256 timeStamp);\n    event Rugged(uint256 amount, uint256 timeStamp);\n    event AdminChanged(address newAdmin, uint256 timeStamp);\n\n    IERC20 public mainToken;\n    IVesting public vestLock;\n\n    // define all the mining calculations here so that it doesn't have to\n    // called from MainToken contract\n    constructor(IERC20 _mainToken, IVesting _vestLock) {\n        require(address(_mainToken) != address(0), \"Invalid address\");\n        require(address(_vestLock) != address(0), \"Invalid address\");\n        mainToken = _mainToken;\n        vestLock = _vestLock;\n        rate = INITIAL_RATE;\n        initTime = block.timestamp;\n        startEpochTime = block.timestamp;\n        startEpochSupply = 0;\n        admin = msg.sender;\n\n        mainToken.approve(address(vestLock), 2**256-1);\n    }\n\n\n    //Address of contributor\n    function addInvestor(address _investor, uint256 _amount) external whenNotPaused {\n        require(_investor != address(0), \"Invalid address\");\n        require(_amount > 0, \"Amount must be positive\");\n        require(msg.sender == admin, \"Unauthorized\");\n\n        Investors memory newInvestor = Investors(_amount, 0, _amount, 10**18 * _amount / investors_supply);\n        investors[_investor] = newInvestor;\n\n        emit InvestorAdded(_investor, _amount, block.timestamp);\n    }\n\n    //Fallback in case a contributor loses keys, or cannot access wallet for any other reason\n    function modifyInvestor(address _investor, address _new) external whenNotPaused nonReentrant {\n        require(_investor != address(0), \"Invalid old address\");\n        require(_new != address(0), \"Invalid new address\");\n        require(investors[_investor].amount != 0);\n        require(msg.sender == admin, \"Unauthorized\");\n\n        Investors memory newInvestor = Investors(investors[_investor].amount, investors[_investor].claimed, investors[_investor].total_tokens, investors[_investor].fraction);\n        investors[_new] = newInvestor;\n\n        Investors memory oldInvestor = Investors(0, 0, 0, 0);\n        investors[_investor] = oldInvestor;\n\n        emit InvestorModified(_investor, _new, block.timestamp);\n    }\n\n    //Claim function to calculate and withdraw claimable tokens, also lock 70% in vesting contract\n    function claim() external nonReentrant {\n        require(msg.sender != address(0));\n        require(investors[msg.sender].amount != 0);\n        \n        uint256 avail = _available_supply();\n        require(avail > 0, \"Nothing claimable (yet?)\");\n\n        uint256 claimable = avail * investors[msg.sender].fraction / 10**18;\n        assert(claimable > 0);\n        if (investors[msg.sender].claimed != 0) {\n            claimable -= investors[msg.sender].claimed;\n        }\n\n        require(investors[msg.sender].amount - claimable != 0);\n\n        investors[msg.sender].amount -= claimable;\n        investors[msg.sender].claimed += claimable;\n\n        uint256 claimable_to_send = claimable * 3 / 10;         //30% released instantly\n        mainToken.transfer(msg.sender, claimable_to_send);\n        uint256 claimable_not_yet_vested = claimable - claimable_to_send;\n        vestLock.vest(msg.sender, claimable_not_yet_vested, 0); //70% locked in vesting contract\n\n        emit Vested(msg.sender, claimable, block.timestamp);\n    }\n\n    //Allow users to claim a specific amount instead of the entire amount\n    function claimExact(uint256 _value) external nonReentrant {\n        require(msg.sender != address(0));\n        require(investors[msg.sender].amount != 0);\n        \n        uint256 avail = _available_supply();\n        uint256 claimable = avail * investors[msg.sender].fraction / 10**18;\n        if (investors[msg.sender].claimed != 0) {\n            claimable -= investors[msg.sender].claimed;\n        }\n\n        require(investors[msg.sender].amount >= claimable);\n        require(_value <= claimable);\n        investors[msg.sender].amount -= _value;\n        investors[msg.sender].claimed += _value;\n\n        uint256 claimable_to_send = _value * 3 / 10;\n        mainToken.transfer(msg.sender, claimable_to_send);\n        uint256 claimable_not_yet_vested = _value - claimable_to_send;\n        vestLock.vest(msg.sender, claimable_not_yet_vested, 0);\n\n        emit Vested(msg.sender, _value, block.timestamp);\n    }\n\n    /// @notice release of BOOT public sale tokens from this contract \n    /// based on emission rules\n    /// updates the rate the mining parameters for public sale tokens\n    /// \n\n    function _updateEmission() private {\n        if (block.timestamp >= startEpochTime + RATE_TIME) {\n            miningEpoch += 1;\n            startEpochTime = startEpochTime.add(RATE_TIME);\n            startEpochSupply = startEpochSupply.add(rate.mul(RATE_TIME));\n\n            if (miningEpoch < INITIAL_RATE_EPOCH_CUTTOF) {\n                rate = rate.mul(EPOCH_INFLATION).div(100000);\n            }\n            else {\n                rate = 0;\n            }\n            emit updateMiningParameters(block.timestamp, rate, startEpochSupply);\n        }\n    }\n\n    //Update emission to be called at every step change to update emission inflation\n    function updateEmission() public {\n        require(block.timestamp >= startEpochTime + RATE_TIME, \"Too soon\");\n        _updateEmission();\n    }\n\n    //Internal function to calculate current available supply\n    function _available_supply() private view returns(uint256) {\n        assert(block.timestamp - startEpochTime <= RATE_TIME);\n        return startEpochSupply + (block.timestamp - startEpochTime) * rate;\n    }\n\n    //Public function to calculate current available supply\n    function available_supply() public view returns(uint256) {\n        assert(block.timestamp - startEpochTime <= RATE_TIME);\n        return startEpochSupply + (block.timestamp - startEpochTime) * rate;\n    }\n\n    //Dev can access all tokens in the contract after 5 year period, to take care of fringe cases of lost or unclaimed tokens\n    function dev_rugpull() public {\n        assert(block.timestamp - initTime >= YEAR * 5); //dev can rug the unclaimed tokens 5 years later, assuming someone lost their key, or forgot about it or whatever and figure what to do with them.\n        require(msg.sender == admin, \"Unauthorized\");   //admin-only\n        uint256 bal = mainToken.balanceOf(address(this));\n        mainToken.transfer(msg.sender, bal);\n        emit Rugged(bal, block.timestamp);\n    }\n\n    //Change admin of the contract\n    function setAdmin(address _newAdmin) public {\n        require(msg.sender == admin, \"Unauthorized\");\n        require(address(_newAdmin) != address(0), \"Invalid address\");\n        admin = _newAdmin;\n        emit AdminChanged(_newAdmin, block.timestamp);\n    }\n\n}contract AirdropDistribution is Pausable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address[210] airdropArray = [\n    0x28d6037EDEAf8ec2c91c9b2cF9A1643111d8F198,\n    0xcfc50541c3dEaf725ce738EF87Ace2Ad778Ba0C5,\n    0xF9e11762d522ea29Dd78178c9BAf83b7B093aacc,\n    0xED60d8590019e5E145ea81455c01F3e817Fe54EB,\n    0x052564eB0fd8b340803dF55dEf89c25C432f43f4,\n    0x21F3B2C8646B4fFA809406BB31dE325a3E5E9b9F,\n    0xd9A93390c487b954EB1Ad4c8a4Acc73840409869,\n    0xe15DD1510E39E9980C0dC47e404eb7298872bc64,\n    0x3BA21b6477F48273f41d241AA3722FFb9E07E247,\n    0x2326D4fb2737666DDA96bd6314e3D4418246cFE8,\n    0xa0f75491720835b36edC92D06DDc468D201e9b73,\n    0xAc6559dF1F410Feba9a6cbf395272189461D8463,\n    0xAE60C874eE07f44fB7BBbD1a5087cDB66E90BEd8,\n    0x600b8A34ec1CfD8B8aF78cFC49708419A16ea2e8,\n    0x89689dB564BF4b67BD7116B3f71e68A379FAad98,\n    0xCaEDCaaFE4C596e89704c5e6B499B8D3474F750f,\n    0xbC90B3Ce40fc3Ed921D910f3e046C65954fFF7cB,\n    0x303985ba2209b5c0c745885Fa6fdd2eC1FEB81A5,\n    0x3991ADBDf461D6817734555efDC8ef056fEfBF21,\n    0xADEEb9d09B8Bcee10943198FB6F6a4229bAB3675,\n    0xb9a954BF995bDEAcBDfE4B1F5f85cD6122c6E341,\n    0x86aF94E5E8d3D583575bBafDD2DcB6b898A555e4,\n    0x270d2924cA13F54632601647FB225DB8eb61fB49,\n    0x02e05dbBF4df5d17cb3A0140F9643fE68cc4Ae39,\n    0xd8D3d8ab22E30c5402AB2A2E216a4A53F4e09e9E,\n    0x28a55C4b4f9615FDE3CDAdDf6cc01FcF2E38A6b0,\n    0x78Bc49be7bae5e0eeC08780c86F0e8278B8B035b,\n    0xf0E12c7218cB38DF7A3A231Bb91EE82F732625b6,\n    0x99eb33756a2eAa32f5964A747722c4b59e6aF351,\n    0xB0ff496dF3860504ebdFF61590A13c1D810C97cc,\n    0x40d2Ce4C14f04bD91c59c6A1CD6e28F2A0fc81F8,\n    0xF07F2B6C340d8D303615710451C11e93fe56774D,\n    0x6979B914f3A1d8C0fec2C1FD602f0e674cdf9862,\n    0x90be4e1Da4BB2F464576749abAc99774148bC9a2,\n    0x681148725731F213b0187A3CBeF215C291D85a3E,\n    0x1678b549Be696b1DfCe9F0639D996a82409E1Ea1,\n    0x4f58985B75EeC8f14C536878A19EAdF4a1960D6c,\n    0x55b9c56668365d11f5aF18E8b7232bC6e4d20658,\n    0xA423fE4CFb811E9CF6a61a02e80E372c0970d4b0,\n    0x7432b5212F19af018b33b73a55d1996960E59c51,\n    0x0Af14239FAA4f19034f3334502ED592B0083e108,\n    0x9fA933f60BCc5E63F75F210929839f91F55b919C,\n    0xB680f628C56C8Fa368Dacbb0C27beEf8C98355b9,\n    0x4EC7CdF61405758f5cED5E454c0B4b0F4F043DF0,\n    0xFCa7C5CF95821f3D45b9949De6E2846D66aF819F,\n    0xA7758B30e93d2ED6CEA7c85e5B12a1d46F0f091f,\n    0x84740F97Aea62C5dC36756DFD9F749412534220E,\n    0xcE968c0fC101C4FB8e08EB5dB73E7E169A2A3562,\n    0xC151AE135F50AaBE78e0b9D13A90FBb2d648AAbB,\n    0x975f5ffB9C3B624351634889944355D47Ab8a367,\n    0x9B5ea8C719e29A5bd0959FaF79C9E5c8206d0499,\n    0xF1fb5dEa21337FEB46963C29d04A95F6CA8B71e6,\n    0x71F12a5b0E60d2Ff8A87FD34E7dcff3c10c914b0,\n    0x918A97AD195DD111C54Ea82E2F8B8D22E9f48726,\n    0x25431341A5800759268a6aC1d3CD91C029D7d9CA,\n    0x52Ad87832400485DE7E7dC965D8Ad890f4e82699,\n    0xF38140985B5a5746F160F133049E83F79cc0B819,\n    0xbE93d14C5dEFb8F41aF8FB092F58e3C71C712b85,\n    0xa0a6Dc36041fb386378458006FEcbDdD02555DdD,\n    0x5F82C97e9b1755237692a946aE814998Bc0e2124,\n    0xdD709cAE362972cb3B92DCeaD77127f7b8D58202,\n    0x8b7B509c01838a0D197a8154C5BF00A3F56fF615,\n    0x640E0118b2C5a3C0Ea29B94A62d9108ce2c6ced7,\n    0x1B51cCe51E2531C478daA9b68eb80D47247dCbec,\n    0xcCa71809E8870AFEB72c4720d0fe50d5C3230e05,\n    0x2dE640a18fE3480aa802aca91f70177aDA103391,\n    0x14Ce500a86F1e3aCE039571e657783E069643617,\n    0x6019D32e59Ef480F2215eE9773AE507645B47bdc,\n    0xB67D92DC830F1a24E4BFfd1a6794fCf8f497c7de,\n    0x6f9BB7e454f5B3eb2310343f0E99269dC2BB8A1d,\n    0xE95d3DAbA7495d42DCC20810f33eeb5207512a9f,\n    0x39c09fdc4E5C5AB72F6319dDbc2CAe40E67b2A60,\n    0xFadAFCE89EA2221fa33005640Acf2C923312F2b9,\n    0x7122FC3588fB9E9B93b7c42Ba02FC85ef15c442b,\n    0x25AfD857C7831C91951Cd94ba63AF237d28604D0,\n    0x6fcF92925e0281D957B0076d3751caD76916C96B,\n    0xd026bFdB74fe1bAF1E1F1058f0d008cD1EEEd8B5,\n    0xbdC38612397355e10A2d6DD697a92f35BF1C9935,\n    0x339Dab47bdD20b4c05950c4306821896CFB1Ff1A,\n    0x1EBb814C9EF016E6012bE299ED834f1dDcEd1529,\n    0xF625DCa051B5AE56f684C072c09969C9Aa91478a,\n    0x5eBdC5C097F9378c3113DC2f9E8B51246E641896,\n    0xD45FBD8F2B0A84743D2606DE8094f86Fac5B6ed3,\n    0x3e89F0eCACDC9b1f8BB892367610cAd0cE421C92,\n    0xC77C0EDc7067a76972481484B87c1226E410547C,\n    0x0F763341b448bb0f02370F4037FE4A2c84c9283f,\n    0x0035Fc5208eF989c28d47e552E92b0C507D2B318,\n    0xB8C30017B375bf675c2836c4c6B6ed5BE214739d,\n    0x286ed1111c29592cC6240194b8d66E64B1c05e50,\n    0x4Cd52B37fdDD19CcD24B0d0e9a048785C7aaFCEf,\n    0x0D779D67a428457CAbEC145A0f94703D14cd496B,\n    0x0000A441fBB1fBAADF246539BF253A42ABD31494,\n    0xECB949c68C825650fD9D0Aebe0cd3796FD126e66,\n    0x8C4d5F3eaC04072245654E0BA480f1a5e1d91Dd5,\n    0xFca32B89d0981e69C8dadCDcc0668b0E01c810CF,\n    0x22fa8Cc33a42320385Cbd3690eD60a021891Cb32,\n    0x23Be060093Db74f38B1a3daF57AfDc1a23dB0077,\n    0xfc80d0867822b8eD010bafcC195c21617C01f943,\n    0x526C7665C5dd9cD7102C6d42D407a0d9DC1e431d,\n    0x6c5384bBaE7aF65Ed1b6784213A81DaE18e528b2,\n    0xAE667Ed58c0d9198fc0b9261156d48296C1bB3da,\n    0xe1DE283EAb72A68f7Ff972fcA13f8953c6e15e51,\n    0xdae88e81e10d848BA6b0Ad64B19783e807064696,\n    0x0a8A06071c878DF9Ec2B5f9663A4b08B0F8c08f4,\n    0x3E95fEF1176acF5e5d2EF67D9C856E4ECAc73E1F,\n    0x9C3c75c9D269aa8282BDE7BE3352D81CC91C2b6A,\n    0xD72B03B7F2E0b8D92b868E73e12b1f888BEFBeDA,\n    0xC23ef3AdF050f4Ca50b30998D37Eb6464e387577,\n    0xD56705548111F08CCB3e1A73806c53Dc706F2e75,\n    0x32802F989B4348A51DD0E61D23B78BE1a0543469,\n    0xc7ca02DC88A2750031DC04515438C3a505bcC994,\n    0x1eccd61c9fa53a8D2e823A26cD72A7efD7D0E92e,\n    0xa53A6fE2d8Ad977aD926C485343Ba39f32D3A3F6,\n    0x6b30E020E9517c519C408f51C2593E12D55B55fA,\n    0x57d1E246D2E32F6F9D10EC55Fc41E8B2E2988308,\n    0xEd557994671DddA053a582e73F2e8aa32bDE7D68,\n    0xceA077172675bf31e879Bba71fb46C3188591070,\n    0x3fC925E779F148f2d843cfD63296E5E12C36d632,\n    0xC369B30c8eC960260631E20081A32e4c61E5Ea9d,\n    0x8d4BfE71379a197ae0c3ea8B41b75f30294d6afb,\n    0x455d7Eb74860d0937423b9184f9e8461aa354Ebb,\n    0x14559df3FBe66Cab6F893D8dD53F7BFE68DE9C65,\n    0x238F24101876377E9178d125D0747DE7fad9C3b2,\n    0x4BB633f0e7E0F3FbC95a7f7fd223652882977573,\n    0x9BdFAeB9CB28DC05b09B37c0F14ECBc9A876CEe0,\n    0x7904aDB48351aF7b835Cb061316795d5226b7f1a,\n    0xF96dA4775776ea43c42795b116C7a6eCcd6e71b5,\n    0x418Efa84214F9810AF9119909D5bEe2c56ebd5Eb,\n    0x2c9dB5597a4a9d2ba6780CD9722e25A9140552EE,\n    0xe1163DCFb598F74da146a83CC878731d553abBfe,\n    0x0991D02f28a5283338e9591CBf7dE2eb25da46Cd,\n    0x7374bB48A5FDc16C9b216F3fCc60b105c73D1806,\n    0xe4f9E812Fe379128f17258A2b3Db7CF28613f190,\n    0x2CA3a2b525E75b2F20f59dEcCaE3ffa4bdf3EAa2,\n    0x8522885d735F75b3FAEEa5CD39ab3d1291dA2C77,\n    0xA4bd4E4D2e8c72720839823f6c20f411f7DDb1f1,\n    0x1729f93e3c3C74B503B8130516984CED70bF47D9,\n    0x94Da725DBA289B96f115ec955aDcAAA806d2085d,\n    0x38857Ed3a8fC5951289E58e20fB56A00e88f0BBD,\n    0x767D222a509D107522e50161CA17FfCF0e5AA3dE,\n    0xA4f2b2557D78E31D48E1ffa8AF8b25Db8524Ea3c,\n    0xDEC1BcdF22A6e77F10e3bF7df8a5F6A6a38E6376,\n    0xC1a0fC4a40253B04a1aE2F40655d73b16CAf268c,\n    0x285E4f019a531e20f673B634D31922d408970798,\n    0x2848b9f2D4FaEBaA4838c41071684c70688B455d,\n    0xa734288DA3aCE7F9a5e5CAa6Df929126f2e67d52,\n    0xD18001F022154654149ed45888C9c29Def6d3CE6,\n    0x7ea1a45f0657D2Dbd77839a916AB83112bdB5590,\n    0x058B10CbE1872ad139b00326686EE8CCef274C58,\n    0xc78CE4E51611ed720eC96bf584bf1b1658FD2379,\n    0xFbEd5277E524113Df313F9f6B29fDE8677F4E936,\n    0xA652565dB815Ad3B138fD98830D14Cfd1826693A,\n    0x43E553fC1D064C125764E9D534a4F7D89B9bb1BE,\n    0x1712fdDC84EFa346D51261f0fa5a809fF457aBDc,\n    0xD0a5266b2515c3b575e30cBC0cfC775FA4fC6660,\n    0x507E964A2fabE1921278b640b0813a5626844145,\n    0x51A7EaD10340AF963C3124b026b86dd2807c2b1C,\n    0x215D67998DaCd9DA4118E4a4899bec60b79987A0,\n    0x8fC548B6B071bf0f2Fe64aD1Aa6032A6d2037366,\n    0x102902245322aAd61D55cfAD8213472A5702a593,\n    0x4B4De68ef03aE45c0d1026801Da71258DDC6BCF6,\n    0x32a59b87352e980dD6aB1bAF462696D28e63525D,\n    0xE582794320FA7424A1f9db360A46446244065Cb5,\n    0xD71C552a4954673a30893BF1Db0A77f1aFA1accD,\n    0xEE4a267E98260aCf829Ca9dC6c9f3d5d82183Bce,\n    0x54683a50f0D2B3F3d1b32780524AE01AA1A583c2,\n    0xdc34F2a567dFE0E7512108b24EcEa2d92754751C,\n    0xD09c6b71b1a7841e7dFb244D90d2a146201BF78B,\n    0xbB48c430C3cA821755547E514A8Fe9CC82BDD975,\n    0x7F326eA697EF0dd2BbD628B62F569017c1D43FCB,\n    0x7f048Fe4176AB39E225907F777F658a6eFDD42ce,\n    0x66EA1467282FFf8df570a1f732F0C6Ab8749154E,\n    0xc1cAd6df277106222Dd45cF5B0300fBd4d1193D5,\n    0x963D071201275fD5FA3dC9bB34fd3d0275ba97a7,\n    0x0707FD320C96b54182475B22a9D47b4045E74668,\n    0xfE2353C808F2409cCb81508005A62cef29457706,\n    0xE580aB95EBE6156c9717e20D513dD788B341934c,\n    0x4EC355d5780c9554EbdF1B40e9734A573D81052C,\n    0x3DdbbbB4C18f1e745A3F65ffC84E9197629Ac6B4,\n    0x05c0F2d1978a1Da91E5D82B8935c610b3F93f36B,\n    0x5221ce255906a61cf3DC2506143cd38D46A92be1,\n    0x573fA57407Bb0e4b761DBe801b5cbD160A8E8C21,\n    0x4Dacd010e15e220bC6C5C3210d166505d2b6c63A,\n    0x2FA26aD1BfAE9e66b5c3F364a9E8EcEc8520dB4a,\n    0xa357Cb3CE710a4f90fB9d56979C2C3634E3965bA,\n    0x1b74fcf3A084d13a9D910DB12469251988985413,\n    0xa948DE8A9205f1fE473490d2114c6616a90fD8d6,\n    0x101D5810f8841BcE68cB3e8CFbadB3f8C71fdff0,\n    0x9F7610115501abD147d1d82Ce92cea2A716690ED,\n    0xf600fd970Bc2054d81AFb1646B50531D7567b22c,\n    0x59cc72743488Aa24Caa92a521E74e633bb1f9096,\n    0x20BFFFdB086D35e1eE06b1e0Beb849eE0a0E945c,\n    0xa2040D6b10595EcBa2F751737b4A931A868f0655,\n    0x0900a13FB9382c6668a74500cccE70Eb96385e0C,\n    0x33d01F8BaA2319882440FE8Cf2978fb137B59Dc1,\n    0x7329c9ead9b5BB0AD240B75C3CFdc2828AC2EFCf,\n    0x77CB8c64e42ea076594A0C1E08115D8444Fa9fAc,\n    0x228a671629bE7a9436019AF909a1629c94bF4cAf,\n    0x7FF3552031C441f3F01AeDEb0C2C680FBA6dD5Df,\n    0x2D52F7BaE61912f7217351443eA8a226996a3Def,\n    0x6bac48867BC94Ff20B4C62b21d484a44D04d342C,\n    0xA42830eE059c77cAF8c8200B44AA9813CB0720c5,\n    0xf88d3412764873872aB1FdED5F168a6c1A3bF7bB,\n    0x3AA667D05a6aa1115cF4A533C29Bb538ACD1300c,\n    0xb92667E34cB6753449ADF464f18ce1833Caf26e0,\n    0x7BFEe91193d9Df2Ac0bFe90191D40F23c773C060,\n    0x1f0a6d7Db80E0C5Af146FDb836e04FAC0B1E8202,\n    0x2053e0218793eEc7107ec50b09B696D4431C1Ff8,\n    0xB8C2C00cC883d087C0Cbd443CeC51a4D04f8b147,\n    0xc8e99dd497ae1fc981c1dd48f49FB804FBFCB99D\n    ];\n\n    uint256[210] airdropBalances = \n\n    [\n    4297396,\n    1728358,\n    1505261,\n    1332003,\n    727506,\n    182291,\n    750722,\n    625052,\n    505013,\n    465932,\n    485597,\n    395709,\n    63621,\n    282190,\n    339931,\n    65686,\n    184250,\n    262345,\n    239002,\n    206374,\n    210330,\n    192425,\n    197415,\n    66379,\n    172905,\n    158272,\n    152257,\n    166385,\n    168117,\n    36747,\n    4760,\n    117953,\n    111187,\n    109898,\n    89898,\n    94390,\n    85323,\n    82567,\n    81233,\n    80992,\n    68640,\n    64138,\n    62431,\n    59644,\n    62799,\n    61129,\n    55179,\n    51915,\n    48305,\n    47379,\n    45361,\n    44710,\n    43459,\n    43725,\n    42692,\n    40472,\n    43858,\n    36506,\n    601,\n    33822,\n    32612,\n    542,\n    31773,\n    28432,\n    21291,\n    25655,\n    25360,\n    25258,\n    23591,\n    23366,\n    23422,\n    21365,\n    20012,\n    19919,\n    19240,\n    19638,\n    18884,\n    17133,\n    16639,\n    15337,\n    14773,\n    14824,\n    14644,\n    12760,\n    12503,\n    9,\n    12208,\n    2092,\n    11859,\n    11672,\n    11192,\n    10321,\n    1629,\n    10303,\n    9539,\n    9200,\n    9115,\n    3925,\n    8894,\n    8531,\n    8399,\n    8151,\n    7665,\n    7634,\n    165,\n    595,\n    6865,\n    6522,\n    6496,\n    6454,\n    6374,\n    3960,\n    622,\n    5993,\n    5971,\n    5930,\n    5930,\n    5722,\n    5645,\n    123,\n    5105,\n    5040,\n    813,\n    2220,\n    4618,\n    4482,\n    4448,\n    4447,\n    233,\n    4121,\n    3863,\n    3833,\n    3875,\n    3836,\n    3638,\n    3558,\n    3241,\n    2965,\n    2965,\n    34,\n    2965,\n    2965,\n    2699,\n    2687,\n    139,\n    2372,\n    2130,\n    384,\n    2172,\n    2092,\n    2083,\n    314,\n    2075,\n    475,\n    1769,\n    1769,\n    1559,\n    1511,\n    1490,\n    1482,\n    248,\n    1361,\n    1251,\n    1245,\n    1180,\n    1180,\n    222,\n    1010,\n    965,\n    947,\n    889,\n    620,\n    28,\n    810,\n    767,\n    619,\n    96,\n    593,\n    494,\n    221,\n    474,\n    84,\n    320,\n    445,\n    362,\n    56,\n    331,\n    280,\n    272,\n    38,\n    34,\n    5,\n    118,\n    17,\n    89,\n    88,\n    59,\n    8,\n    1,\n    30,\n    29,\n    504793,\n    430006,\n    39045,\n    15187,\n    8275,\n    141303,\n    195,\n    113110,\n    82615\n    ];\n\n    //Airdrop Shares\n    struct Airdrop {\n        uint256 amount;\n        uint256 claimed;\n        uint256 total_tokens;\n        uint256 fraction;     // with 10**18 precision\n    }\n\n    mapping(address => Airdrop) public airdrop;\n    mapping(address => uint256) public validated; //Are they validated to claim?\n\n    uint256 private airdrop_supply = 20160000 * 10 ** 18; //Total Allocation for Airdrop\n\n    // General constants\n    uint256 constant HOUR = 3600;\n    uint256 constant DAY = 86400;\n    uint256 constant WEEK = 86400 * 7;\n    uint256 constant YEAR = WEEK * 52;\n\n    uint256 constant RATE_TIME = WEEK;                          // How often the rate goes to the next epoch\n    uint256 constant INITIAL_RATE = 247_262 * 10 ** 18 / WEEK;  // per week\n    uint256 constant EPOCH_INFLATION = 98_831;                  // 98.831 % of prior week\n    uint256 constant INITIAL_RATE_EPOCH_CUTTOF = 260;           // airdrop stops after this many weeks\n\n    // Supply variables\n    uint256 public miningEpoch;\n    uint256 public startEpochTime;\n    uint256 public rate;\n\n    uint256 startEpochSupply;\n   \n    event updateMiningParameters(uint256 time, uint256 rate, uint256 supply);\n    event Validated(address indexed investor, uint256 amount, uint256 timeStamp);\n    event Vested(address indexed investor, uint256 amount, uint256 timeStamp);\n\n    IERC20 public mainToken;    //BOOT token address\n    IVesting public vestLock;   //Vesting contract address\n\n    // define all the mining calculations here so that it doesn't have to\n    // called from MainToken contract\n    constructor(IERC20 _mainToken, IVesting _vestLock) {\n        require(address(_mainToken) != address(0), \"Invalid address\");\n        require(address(_vestLock) != address(0), \"Invalid address\");\n        mainToken = _mainToken;\n        vestLock = _vestLock;\n        rate = INITIAL_RATE;\n        startEpochTime = block.timestamp;\n\n        mainToken.approve(address(vestLock), 2**256-1);\n    }\n\n    //At first run, user has to validate - it checks if they are indeed in the airdrop, if yes, set the internal mappings for their address so they can claim.\n\n    function validate() external nonReentrant {\n        require(msg.sender != address(0));\n        require(airdrop[msg.sender].amount == 0, \"Already validated.\");\n        for (uint i = 0; i < airdropArray.length; i++) {\n            if (airdropArray[i] == msg.sender) {\n                uint256 airdroppable = airdropBalances[i] * 10 ** 18;\n                Airdrop memory newAirdrop = Airdrop(airdroppable, 0, airdroppable, 10**18 * airdroppable / airdrop_supply);\n                airdrop[msg.sender] = newAirdrop;\n                validated[msg.sender] = 1;\n                emit Validated(msg.sender, airdroppable, block.timestamp);\n                break;\n            }\n        }\n    }\n\n    \n    //Claim function can only be called if validated, and found to exist in hardcoded array.\n     \n    function claim() external nonReentrant {\n        require(msg.sender != address(0));\n        require(validated[msg.sender] == 1, \"Address not validated to claim.\");\n        require(airdrop[msg.sender].amount != 0);\n        \n        uint256 avail = _available_supply();\n        require(avail > 0, \"Nothing claimable (yet?)\");\n    \n        uint256 claimable = avail * airdrop[msg.sender].fraction / 10**18;\n        assert(claimable > 0);\n        if (airdrop[msg.sender].claimed != 0) {\n            claimable -= airdrop[msg.sender].claimed;\n        }\n\n        assert(airdrop[msg.sender].amount - claimable != 0);\n\n        airdrop[msg.sender].amount -= claimable;\n        airdrop[msg.sender].claimed += claimable;\n\n        uint256 claimable_to_send = claimable * 3 / 10;         //30% released instantly\n        mainToken.transfer(msg.sender, claimable_to_send);\n        uint256 claimable_not_yet_vested = claimable - claimable_to_send; \n        vestLock.vest(msg.sender, claimable_not_yet_vested, 0); //70% locked in vesting contract\n\n        emit Vested(msg.sender, claimable, block.timestamp);\n    }\n\n\n    //Allow users to claim a specific amount instead of the entire amount\n    function claimExact(uint256 _value) external nonReentrant {\n        require(msg.sender != address(0));\n        require(airdrop[msg.sender].amount != 0);\n        \n        uint256 avail = _available_supply();\n        uint256 claimable = avail * airdrop[msg.sender].fraction / 10**18; //\n        if (airdrop[msg.sender].claimed != 0){\n            claimable -= airdrop[msg.sender].claimed;\n        }\n\n        require(airdrop[msg.sender].amount >= claimable);\n        require(_value <= claimable);\n        airdrop[msg.sender].amount -= _value;\n        airdrop[msg.sender].claimed += _value;\n\n        uint256 claimable_to_send = _value * 3 / 10;\n        mainToken.transfer(msg.sender, claimable_to_send);\n        uint256 claimable_not_yet_vested = _value - claimable_to_send;\n        vestLock.vest(msg.sender, claimable_not_yet_vested, 0);\n\n        emit Vested(msg.sender, _value, block.timestamp);\n    }\n\n    /// @notice release of BOOT public sale tokens from this contract \n    /// based on emission rules\n    ///\n\n    function _updateEmission() private {\n        if (block.timestamp >= startEpochTime + RATE_TIME) {\n            miningEpoch += 1;\n            startEpochTime = startEpochTime.add(RATE_TIME);\n            startEpochSupply = startEpochSupply.add(rate.mul(RATE_TIME));\n\n            if (miningEpoch < INITIAL_RATE_EPOCH_CUTTOF) {\n                rate = rate.mul(EPOCH_INFLATION).div(100000);\n            }\n            else {\n                rate = 0;\n            }\n            emit updateMiningParameters(block.timestamp, rate, startEpochSupply);\n        }\n    }\n\n    //Update emission to be called at every step change to update emission inflation\n    function updateEmission() public {\n        require(block.timestamp >= startEpochTime + RATE_TIME, \"Too soon\");\n        _updateEmission();\n    }\n\n     //Internal function to calculate current available supply\n    function _available_supply() private view returns(uint256) {\n        assert(block.timestamp - startEpochTime <= RATE_TIME);\n        return startEpochSupply + (block.timestamp - startEpochTime) * rate;\n    }\n\n    //Public function to calculate current available supply\n    function available_supply() public view returns(uint256) {\n        assert(block.timestamp - startEpochTime <= RATE_TIME);\n        return startEpochSupply + (block.timestamp - startEpochTime) * rate;\n    }\n\n}",
    "bin": []
}