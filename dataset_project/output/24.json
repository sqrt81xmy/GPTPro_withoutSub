{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/24/pooltogether-mstable",
    "external_functions": [
        [
            "MStableYieldSource",
            "ISavingsContractV2",
            "IERC20"
        ]
    ],
    "new_contract": "contract MStableYieldSource is IYieldSource, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    ISavingsContractV2 public immutable savings;\n    IERC20 public immutable mAsset;\n\n    /// @notice mapping of account addresses to interest-bearing mAsset balances. eg imUSD\n    mapping(address => uint256) public imBalances;\n\n    /// @notice Emitted on init\n    /// @param savings The ISavingsContractV2 to bind to\n    event Initialized(ISavingsContractV2 indexed savings);\n\n    /// @notice Emitted when asset tokens are supplied to sponsor the yield source\n    /// @param sponsor The address who sponsored\n    /// @param mAssetAmount The amount of deposit token that was sponsored\n    event Sponsored(address indexed sponsor, uint256 mAssetAmount);\n\n    /// @notice Emitted when asset tokens are supplied to earn yield\n    /// @param from The address who supplied the assets\n    /// @param to The new owner of the assets\n    /// @param amount The amount of assets supplied\n    event Supplied(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice Emitted when asset tokens are redeemed from the yield source\n    /// @param from The address who is redeeming\n    /// @param requestedAmount The amount that was requested to withdraw\n    /// @param actualAmount The actual amount of assets transferred to the address\n    event Redeemed(address indexed from, uint256 requestedAmount, uint256 actualAmount);\n\n    /// @notice Approves max spend by the mAsset\n    /// @param from The user who triggered approve max\n    event ApprovedMax(address indexed from);\n\n    constructor(ISavingsContractV2 _savings) ReentrancyGuard() {\n        // As immutable storage variables can not be accessed in the constructor,\n        // create in-memory variables that can be used instead.\n        IERC20 mAssetMemory = IERC20(_savings.underlying());\n\n        // infinite approve Savings Contract to transfer mAssets from this contract\n        mAssetMemory.safeApprove(address(_savings), type(uint256).max);\n\n        // save to immutable storage\n        savings = _savings;\n        mAsset = mAssetMemory;\n\n        emit Initialized(_savings);\n    }\n\n    /// @notice Approves of the max spend amount for the Savings contract.\n    function approveMax() public {\n        IERC20(savings.underlying()).safeApprove(address(savings), type(uint256).max);\n\n        emit ApprovedMax(msg.sender);\n    }\n\n    /// @notice Returns the ERC20 mAsset token used for deposits\n    /// @return underlyingMasset Underlying mAsset token address. eg mUSD\n    function depositToken() public view override returns (address underlyingMasset) {\n        underlyingMasset = address(mAsset);\n    }\n\n    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.\n    /// @return mAssets The underlying balance of mAsset tokens. eg mUSD\n    function balanceOfToken(address addr) external view override returns (uint256 mAssets) {\n        uint256 exchangeRate = savings.exchangeRate();\n        mAssets = (imBalances[addr] * exchangeRate) / 1e18;\n    }\n\n    /// @notice Deposits mAsset tokens to the savings contract.\n    /// @param mAssetAmount The amount of mAsset tokens to be deposited. eg mUSD\n    function supplyTokenTo(uint256 mAssetAmount, address to) external override nonReentrant {\n        mAsset.safeTransferFrom(msg.sender, address(this), mAssetAmount);\n        uint256 creditsIssued = savings.depositSavings(mAssetAmount);\n        imBalances[to] += creditsIssued;\n\n        emit Supplied(msg.sender, to, mAssetAmount);\n    }\n\n    /// @notice Redeems mAsset tokens from the interest-beaing mAsset.\n    ///         eg. redeems mUSD from imUSD.\n    /// @param mAssetAmount The amount of mAsset tokens requested to be redeemed. eg mUSD\n    /// @return mAssetsActual The actual amount of mAsset tokens that were received from the redeem. eg mUSD\n    function redeemToken(uint256 mAssetAmount)\n        external\n        override\n        nonReentrant\n        returns (uint256 mAssetsActual)\n    {   \n        uint256 mAssetBalanceBefore = mAsset.balanceOf(address(this));\n\n        uint256 creditsBurned = savings.redeemUnderlying(mAssetAmount);\n\n        imBalances[msg.sender] -= creditsBurned;\n        uint256 mAssetBalanceAfter = mAsset.balanceOf(address(this));\n        mAssetsActual = mAssetBalanceAfter - mAssetBalanceBefore;\n\n        mAsset.safeTransfer(msg.sender, mAssetsActual);\n\n        emit Redeemed(msg.sender, mAssetAmount, mAssetsActual);\n    }\n}\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n",
    "bin": []
}