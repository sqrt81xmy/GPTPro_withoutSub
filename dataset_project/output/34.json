{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/34/v4-timelocks",
    "external_functions": [
        [
            "DrawCalculatorTimelock",
            "IDrawCalculator"
        ]
    ],
    "new_contract": "contract DrawCalculatorTimelock is IDrawCalculatorTimelock, Manageable {\n    /* ============ Global Variables ============ */\n\n    /// @notice Internal DrawCalculator reference.\n    IDrawCalculator internal immutable calculator;\n\n    /// @notice Seconds required to elapse before newest Draw is available.\n    uint32 internal timelockDuration;\n\n    /// @notice Internal Timelock struct reference.\n    Timelock internal timelock;\n\n    /* ============ Events ============ */\n\n    /**\n     * @notice Deployed event when the constructor is called\n     * @param drawCalculator DrawCalculator address bound to this timelock\n     * @param timelockDuration Initial timelock duration\n     */\n    event Deployed(IDrawCalculator indexed drawCalculator, uint32 timelockDuration);\n\n    /* ============ Deploy ============ */\n\n    /**\n     * @notice Initialize DrawCalculatorTimelockTrigger smart contract.\n     * @param _owner                       Address of the DrawCalculator owner.\n     * @param _calculator                 DrawCalculator address.\n     * @param _timelockDuration           Elapsed seconds before new Draw is available.\n     */\n    constructor(\n        address _owner,\n        IDrawCalculator _calculator,\n        uint32 _timelockDuration\n    ) Ownable(_owner) {\n        calculator = _calculator;\n        _setTimelockDuration(_timelockDuration);\n\n        emit Deployed(_calculator, _timelockDuration);\n    }\n\n    /* ============ External Functions ============ */\n\n    /// @inheritdoc IDrawCalculatorTimelock\n    function calculate(\n        address user,\n        uint32[] calldata drawIds,\n        bytes calldata data\n    ) external view override returns (uint256[] memory, bytes memory) {\n        Timelock memory _timelock = timelock;\n\n        for (uint256 i = 0; i < drawIds.length; i++) {\n            // if draw id matches timelock and not expired, revert\n            if (drawIds[i] == _timelock.drawId) {\n                _requireTimelockElapsed(_timelock);\n            }\n        }\n\n        return calculator.calculate(user, drawIds, data);\n    }\n\n    /// @inheritdoc IDrawCalculatorTimelock\n    function lock(uint32 _drawId) external override onlyManagerOrOwner returns (bool) {\n        Timelock memory _timelock = timelock;\n        require(_drawId == _timelock.drawId + 1, \"OM/not-drawid-plus-one\");\n\n        _requireTimelockElapsed(_timelock);\n\n        uint128 _timestamp = uint128(block.timestamp);\n        timelock = Timelock({ drawId: _drawId, timestamp: _timestamp });\n        emit LockedDraw(_drawId, uint32(_timestamp));\n\n        return true;\n    }\n\n    /// @inheritdoc IDrawCalculatorTimelock\n    function getDrawCalculator() external view override returns (IDrawCalculator) {\n        return calculator;\n    }\n\n    /// @inheritdoc IDrawCalculatorTimelock\n    function getTimelock() external view override returns (Timelock memory) {\n        return timelock;\n    }\n\n    /// @inheritdoc IDrawCalculatorTimelock\n    function getTimelockDuration() external view override returns (uint32) {\n        return timelockDuration;\n    }\n\n    /// @inheritdoc IDrawCalculatorTimelock\n    function setTimelock(Timelock memory _timelock) external override onlyOwner {\n        timelock = _timelock;\n\n        emit TimelockSet(_timelock);\n    }\n\n    /// @inheritdoc IDrawCalculatorTimelock\n    function setTimelockDuration(uint32 _timelockDuration) external override onlyOwner {\n        _setTimelockDuration(_timelockDuration);\n    }\n\n    /// @inheritdoc IDrawCalculatorTimelock\n    function hasElapsed() external view override returns (bool) {\n        return _timelockHasElapsed(timelock);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Set global timelockDuration variable.\n     */\n    function _setTimelockDuration(uint32 _timelockDuration) internal {\n        timelockDuration = _timelockDuration;\n        emit TimelockDurationSet(_timelockDuration);\n    }\n\n    /**\n     * @notice Read global DrawCalculator variable.\n     * @return IDrawCalculator\n     */\n    function _timelockHasElapsed(Timelock memory _timelock) internal view returns (bool) {\n        // If the timelock hasn't been initialized, then it's elapsed\n        if (_timelock.timestamp == 0) {\n            return true;\n        }\n\n        // Otherwise if the timelock has expired, we're good.\n        return (block.timestamp > _timelock.timestamp + timelockDuration);\n    }\n\n    /**\n     * @notice Require the timelock \"cooldown\" period has elapsed\n     * @param _timelock the Timelock to check\n     */\n    function _requireTimelockElapsed(Timelock memory _timelock) internal view {\n        require(_timelockHasElapsed(_timelock), \"OM/timelock-not-expired\");\n    }\n}\n",
    "bin": []
}