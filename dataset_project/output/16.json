{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/16/src",
    "external_functions": [
        [
            "Insurance",
            "ITracerPerpetualSwaps",
            "InsurancePoolToken",
            "IERC20"
        ],
        [
            "Liquidation",
            "ITracerPerpetualSwaps",
            "IOracle",
            "IPricing",
            "ITrader",
            "IInsurance"
        ],
        [
            "Pricing",
            "IOracle",
            "ITracerPerpetualSwaps",
            "IInsurance"
        ],
        [
            "TracerPerpetualSwaps",
            "IERC20",
            "IInsurance",
            "IPricing",
            "ITrader",
            "IOracle"
        ],
        [
            "TracerPerpetualsFactory",
            "ILiquidation",
            "ITracerPerpetualSwaps",
            "IPerpsDeployer",
            "ILiquidationDeployer",
            "IInsuranceDeployer",
            "IPricingDeployer",
            "Ownable"
        ],
        [
            "Trader"
        ],
        [
            "OracleAdapter",
            "IChainlinkOracle"
        ],
        [
            "GasOracle",
            "IChainlinkOracle"
        ]
    ],
    "new_contract": "contract Insurance is IInsurance {\n    using LibMath for uint256;\n    using LibMath for int256;\n    ITracerPerpetualsFactory public perpsFactory;\n\n    address public collateralAsset; // Address of collateral asset\n    uint256 public override publicCollateralAmount; // amount of underlying collateral in public pool, in WAD format\n    uint256 public override bufferCollateralAmount; // amount of collateral in buffer pool, in WAD format\n    address public token; // token representation of a users holding in the pool\n\n    ITracerPerpetualSwaps public tracer; // Tracer associated with Insurance Pool\n\n    event InsuranceDeposit(address indexed market, address indexed user, uint256 indexed amount);\n    event InsuranceWithdraw(address indexed market, address indexed user, uint256 indexed amount);\n    event InsurancePoolDeployed(address indexed market, address indexed asset);\n\n    constructor(address _tracer) {\n        tracer = ITracerPerpetualSwaps(_tracer);\n        InsurancePoolToken _token = new InsurancePoolToken(\"Tracer Pool Token\", \"TPT\");\n        token = address(_token);\n        collateralAsset = tracer.tracerQuoteToken();\n\n        emit InsurancePoolDeployed(_tracer, tracer.tracerQuoteToken());\n    }\n\n    /**\n     * @notice Allows a user to deposit to a given tracer market insurance pool\n     * @dev Mints amount of the pool token to the user\n     * @param amount the amount of tokens to deposit. Provided in WAD format\n     */\n    function deposit(uint256 amount) external override {\n        IERC20 collateralToken = IERC20(collateralAsset);\n\n        // convert token amount to WAD\n        uint256 quoteTokenDecimals = tracer.quoteTokenDecimals();\n        uint256 rawTokenAmount = Balances.wadToToken(quoteTokenDecimals, amount);\n        collateralToken.transferFrom(msg.sender, address(this), rawTokenAmount);\n\n        // amount in wad format after being converted from token format\n        uint256 wadAmount = uint256(Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount));\n\n        // Update pool balances and user\n        updatePoolAmount();\n        InsurancePoolToken poolToken = InsurancePoolToken(token);\n\n        // tokens to mint = (pool token supply / collateral holdings) * collateral amount to stake\n        uint256 tokensToMint = LibInsurance.calcMintAmount(poolToken.totalSupply(), publicCollateralAmount, wadAmount);\n\n        // mint pool tokens, hold collateral tokens\n        poolToken.mint(msg.sender, tokensToMint);\n        publicCollateralAmount = publicCollateralAmount + wadAmount;\n        emit InsuranceDeposit(address(tracer), msg.sender, wadAmount);\n    }\n\n    /**\n     * @notice Allows a user to withdraw their assets from a given insurance pool\n     * @dev burns amount of tokens from the pool token\n     * @param amount the amount of pool tokens to burn. Provided in WAD format\n     */\n    function withdraw(uint256 amount) external override {\n        updatePoolAmount();\n        uint256 balance = getPoolUserBalance(msg.sender);\n        require(balance >= amount, \"INS: balance < amount\");\n\n        IERC20 collateralToken = IERC20(collateralAsset);\n        InsurancePoolToken poolToken = InsurancePoolToken(token);\n\n        // tokens to return = (collateral holdings / pool token supply) * amount of pool tokens to withdraw\n        uint256 wadTokensToSend = LibInsurance.calcWithdrawAmount(\n            poolToken.totalSupply(),\n            publicCollateralAmount,\n            amount\n        );\n\n        // convert token amount to raw amount from WAD\n        uint256 rawTokenAmount = Balances.wadToToken(tracer.quoteTokenDecimals(), wadTokensToSend);\n\n        // pool amount is always in WAD format\n        publicCollateralAmount = publicCollateralAmount - wadTokensToSend;\n\n        // burn pool tokens, return collateral tokens\n        poolToken.burnFrom(msg.sender, amount);\n        collateralToken.transfer(msg.sender, rawTokenAmount);\n\n        emit InsuranceWithdraw(address(tracer), msg.sender, wadTokensToSend);\n    }\n\n    /**\n     * @notice Internally updates a given tracer's pool amount according to the tracer contract\n     * @dev Withdraws from tracer, and adds amount to the pool's amount field.\n     */\n    function updatePoolAmount() public override {\n        uint256 quote = uint256((tracer.getBalance(address(this))).position.quote);\n\n        tracer.withdraw(quote);\n\n        if (publicCollateralAmount > 0) {\n            // Amount to pay to public is the ratio of public collateral amount to total funds\n            uint256 payToPublic = PRBMathUD60x18.mul(\n                quote,\n                PRBMathUD60x18.div(publicCollateralAmount, getPoolHoldings())\n            );\n\n            publicCollateralAmount = publicCollateralAmount + payToPublic;\n\n            // Amount to pay to buffer is the remainder\n            bufferCollateralAmount = bufferCollateralAmount + quote - payToPublic;\n        } else {\n            // Pay to buffer if nothing in public insurance\n            bufferCollateralAmount = bufferCollateralAmount + quote;\n        }\n    }\n\n    /**\n     * @notice Deposits some of the insurance pool's amount into the tracer contract\n     * @dev If amount is greater than the insurance pool's balance, deposit total balance.\n     *      This was done because in such an emergency situation, we want to recover as much as possible\n     * @param amount The desired amount to take from the insurance pool\n     */\n    function drainPool(uint256 amount) external override onlyLiquidation() {\n        IERC20 tracerMarginToken = IERC20(tracer.tracerQuoteToken());\n\n        uint256 poolHoldings = getPoolHoldings();\n\n        if (amount >= poolHoldings) {\n            // If public collateral left after draining is less than 1 token, we want to keep it at 1 token\n            if (publicCollateralAmount > 10**18) {\n                // Leave 1 token for the public pool\n                amount = poolHoldings - 10**18;\n                publicCollateralAmount = 10**18;\n            } else {\n                amount = bufferCollateralAmount;\n            }\n\n            // Drain buffer\n            bufferCollateralAmount = 0;\n        } else if (amount > bufferCollateralAmount) {\n            if (publicCollateralAmount < 10**18) {\n                // If there's not enough public collateral for there to be 1 token, cap amount being drained at the buffer\n                amount = bufferCollateralAmount;\n            } else if (poolHoldings - amount < 10**18) {\n                // If the amount of collateral left in the public insurance would be less than 1 token, cap amount being drained\n                // from the public insurance such that 1 token is left in the public buffer\n                amount = poolHoldings - 10**18;\n                publicCollateralAmount = 10**18;\n            } else {\n                // Take out what you need from the public pool; there's enough for there to be >= 1 token left\n                publicCollateralAmount = publicCollateralAmount - (amount - bufferCollateralAmount);\n            }\n\n            // Drain buffer\n            bufferCollateralAmount = 0;\n        } else {\n            // Only need to take part of buffer pool out\n            bufferCollateralAmount = bufferCollateralAmount - amount;\n        }\n\n        tracerMarginToken.approve(address(tracer), amount);\n        tracer.deposit(amount);\n    }\n\n    /**\n     * @notice gets a users balance in a given insurance pool\n     * @param user the user whose balance is being retrieved\n     */\n    function getPoolUserBalance(address user) public view override returns (uint256) {\n        return InsurancePoolToken(token).balanceOf(user);\n    }\n\n    /**\n     * @notice Get total holdings of the insurance pool (= public + buffer collateral)\n     */\n    function getPoolHoldings() public view override returns (uint256) {\n        return bufferCollateralAmount + publicCollateralAmount;\n    }\n\n    /**\n     * @notice Gets the target fund amount for a given insurance pool\n     * @dev The target amount is 1% of the leveraged notional value of the tracer being insured.\n     */\n    function getPoolTarget() public view override returns (uint256) {\n        return tracer.leveragedNotionalValue() / 100;\n    }\n\n    /**\n     * @notice Gets the 8 hour funding rate for an insurance pool\n     * @dev the funding rate is represented as\n     *      0.0036523 * (insurance_fund_target - insurance_fund_holdings) / leveraged_notional_value)\n     */\n    function getPoolFundingRate() external view override returns (uint256) {\n        // 0.0036523 as a WAD = 36523 * (10**11)\n        uint256 multiplyFactor = 36523 * (10**11);\n\n        uint256 levNotionalValue = tracer.leveragedNotionalValue();\n\n        // Traders only pay the insurance funding rate if the market has leverage\n        if (levNotionalValue == 0) {\n            return 0;\n        }\n\n        uint256 poolHoldings = getPoolHoldings();\n        uint256 poolTarget = getPoolTarget();\n\n        // If the pool is above the target, we don't pay the insurance funding rate\n        if (poolTarget <= poolHoldings) {\n            return 0;\n        }\n\n        uint256 ratio = PRBMathUD60x18.div(poolTarget - poolHoldings, levNotionalValue);\n\n        return PRBMathUD60x18.mul(multiplyFactor, ratio);\n    }\n\n    modifier onlyLiquidation() {\n        require(msg.sender == tracer.liquidationContract(), \"INS: sender not LIQ contract\");\n        _;\n    }\n}\ncontract Pricing is IPricing {\n    using LibMath for uint256;\n    using LibMath for int256;\n    using PRBMathSD59x18 for int256;\n\n    address public tracer;\n    IInsurance public insurance;\n    IOracle public oracle;\n\n    // pricing metrics\n    Prices.PriceInstant[24] internal hourlyTracerPrices;\n    Prices.PriceInstant[24] internal hourlyOraclePrices;\n\n    // funding index => funding rate\n    mapping(uint256 => Prices.FundingRateInstant) public fundingRates;\n\n    // funding index => insurance funding rate\n    mapping(uint256 => Prices.FundingRateInstant) public insuranceFundingRates;\n\n    // market's time value\n    int256 public override timeValue;\n\n    // funding index\n    uint256 public override currentFundingIndex;\n\n    // timing variables\n    uint256 public startLastHour;\n    uint256 public startLast24Hours;\n    uint8 public override currentHour;\n\n    event HourlyPriceUpdated(uint256 price, uint256 currentHour);\n    event FundingRateUpdated(int256 fundingRate, int256 cumulativeFundingRate);\n    event InsuranceFundingRateUpdated(int256 insuranceFundingRate, int256 insuranceFundingRateValue);\n\n    /**\n     * @dev Set tracer perps factory\n     * @dev ensure that oracle contract is returning WAD values. This may be done\n     *      by wrapping the raw oracle in an adapter (see contracts/oracle)\n     * @param _tracer The address of the tracer this pricing contract links too\n     */\n    constructor(\n        address _tracer,\n        address _insurance,\n        address _oracle\n    ) {\n        tracer = _tracer;\n        insurance = IInsurance(_insurance);\n        oracle = IOracle(_oracle);\n        startLastHour = block.timestamp;\n        startLast24Hours = block.timestamp;\n    }\n\n    /**\n     * @notice Updates pricing information given a trade of a certain volume at\n     *         a set price\n     * @param tradePrice the price the trade executed at\n     */\n    function recordTrade(uint256 tradePrice) external override onlyTracer {\n        uint256 currentOraclePrice = oracle.latestAnswer();\n        if (startLastHour <= block.timestamp - 1 hours) {\n            // emit the old hourly average\n            uint256 hourlyTracerPrice = getHourlyAvgTracerPrice(currentHour);\n            emit HourlyPriceUpdated(hourlyTracerPrice, currentHour);\n\n            // update funding rate for the previous hour\n            updateFundingRate();\n\n            // update the time value\n            if (startLast24Hours <= block.timestamp - 24 hours) {\n                // Update the interest rate every 24 hours\n                updateTimeValue();\n                startLast24Hours = block.timestamp;\n            }\n\n            // update time metrics after all other state\n            startLastHour = block.timestamp;\n\n            // Check current hour and loop around if need be\n            if (currentHour == 23) {\n                currentHour = 0;\n            } else {\n                currentHour = currentHour + 1;\n            }\n\n            // add new pricing entry for new hour\n            updatePrice(tradePrice, currentOraclePrice, true);\n        } else {\n            // Update old pricing entry\n            updatePrice(tradePrice, currentOraclePrice, false);\n        }\n    }\n\n    /**\n     * @notice Updates both the latest market price and the latest underlying asset price (from an oracle) for a given tracer market given a tracer price\n     *         and an oracle price.\n     * @param marketPrice The price that a tracer was bought at, returned by the TracerPerpetualSwaps.sol contract when an order is filled\n     * @param oraclePrice The price of the underlying asset that the Tracer is based upon as returned by a Chainlink Oracle\n     * @param newRecord Bool that decides if a new hourly record should be started (true) or if a current hour should be updated (false)\n     */\n    function updatePrice(\n        uint256 marketPrice,\n        uint256 oraclePrice,\n        bool newRecord\n    ) internal {\n        // Price records entries updated every hour\n        if (newRecord) {\n            // Make new hourly record, total = marketprice, numtrades set to 1;\n            Prices.PriceInstant memory newHourly = Prices.PriceInstant(marketPrice, 1);\n            hourlyTracerPrices[currentHour] = newHourly;\n            // As above but with Oracle price\n            Prices.PriceInstant memory oracleHour = Prices.PriceInstant(oraclePrice, 1);\n            hourlyOraclePrices[currentHour] = oracleHour;\n        } else {\n            // If an update is needed, add the market price to a running total and increment number of trades\n            hourlyTracerPrices[currentHour].cumulativePrice =\n                hourlyTracerPrices[currentHour].cumulativePrice +\n                marketPrice;\n            hourlyTracerPrices[currentHour].trades = hourlyTracerPrices[currentHour].trades + 1;\n            // As above but with oracle price\n            hourlyOraclePrices[currentHour].cumulativePrice =\n                hourlyOraclePrices[currentHour].cumulativePrice +\n                oraclePrice;\n            hourlyOraclePrices[currentHour].trades = hourlyOraclePrices[currentHour].trades + 1;\n        }\n    }\n\n    /**\n     * @notice Updates the funding rate and the insurance funding rate\n     */\n    function updateFundingRate() internal {\n        // Get 8 hour time-weighted-average price (TWAP) and calculate the new funding rate and store it a new variable\n        ITracerPerpetualSwaps _tracer = ITracerPerpetualSwaps(tracer);\n        Prices.TWAP memory twapPrices = getTWAPs(currentHour);\n        int256 iPoolFundingRate = insurance.getPoolFundingRate().toInt256();\n        uint256 underlyingTWAP = twapPrices.underlying;\n        uint256 derivativeTWAP = twapPrices.derivative;\n\n        int256 newFundingRate = PRBMathSD59x18.mul(\n            derivativeTWAP.toInt256() - underlyingTWAP.toInt256() - timeValue,\n            _tracer.fundingRateSensitivity().toInt256()\n        );\n\n        // Create variable with value of new funding rate value\n        int256 currentFundingRateValue = fundingRates[currentFundingIndex].cumulativeFundingRate;\n        int256 cumulativeFundingRate = currentFundingRateValue + newFundingRate;\n\n        // as above but with insurance funding rate value\n        int256 currentInsuranceFundingRateValue = insuranceFundingRates[currentFundingIndex].cumulativeFundingRate;\n        int256 iPoolFundingRateValue = currentInsuranceFundingRateValue + iPoolFundingRate;\n\n        // Call setter functions on calculated variables\n        setFundingRate(newFundingRate, cumulativeFundingRate);\n        emit FundingRateUpdated(newFundingRate, cumulativeFundingRate);\n        setInsuranceFundingRate(iPoolFundingRate, iPoolFundingRateValue);\n        emit InsuranceFundingRateUpdated(iPoolFundingRate, iPoolFundingRateValue);\n        // increment funding index\n        currentFundingIndex = currentFundingIndex + 1;\n    }\n\n    /**\n     * @notice Given the address of a tracer market this function will get the current fair price for that market\n     */\n    function fairPrice() external view override returns (uint256) {\n        return Prices.fairPrice(oracle.latestAnswer(), timeValue);\n    }\n\n    ////////////////////////////\n    ///  SETTER FUNCTIONS   ///\n    //////////////////////////\n\n    /**\n     * @notice Calculates and then updates the time Value for a tracer market\n     */\n    function updateTimeValue() internal {\n        (uint256 avgPrice, uint256 oracleAvgPrice) = get24HourPrices();\n\n        timeValue += Prices.timeValue(avgPrice, oracleAvgPrice);\n    }\n\n    /**\n     * @notice Sets the values of the fundingRate struct\n     * @param fundingRate The funding Rate of the Tracer, calculated by updateFundingRate\n     * @param cumulativeFundingRate The cumulativeFundingRate, incremented each time the funding rate is updated\n     */\n    function setFundingRate(int256 fundingRate, int256 cumulativeFundingRate) internal {\n        fundingRates[currentFundingIndex] = Prices.FundingRateInstant(\n            block.timestamp,\n            fundingRate,\n            cumulativeFundingRate\n        );\n    }\n\n    /**\n     * @notice Sets the values of the fundingRate struct for a particular Tracer Marker\n     * @param fundingRate The insurance funding Rate of the Tracer, calculated by updateFundingRate\n     * @param cumulativeFundingRate The cumulativeFundingRate, incremented each time the funding rate is updated\n     */\n    function setInsuranceFundingRate(int256 fundingRate, int256 cumulativeFundingRate) internal {\n        insuranceFundingRates[currentFundingIndex] = Prices.FundingRateInstant(\n            block.timestamp,\n            fundingRate,\n            cumulativeFundingRate\n        );\n    }\n\n    // todo by using public variables lots of these can be removed\n    /**\n     * @return each variable of the fundingRate struct of a particular tracer at a particular funding rate index\n     */\n    function getFundingRate(uint256 index) external view override returns (Prices.FundingRateInstant memory) {\n        return fundingRates[index];\n    }\n\n    /**\n     * @return all of the variables in the funding rate struct (insurance rate) from a particular tracer market\n     */\n    function getInsuranceFundingRate(uint256 index) external view override returns (Prices.FundingRateInstant memory) {\n        return insuranceFundingRates[index];\n    }\n\n    /**\n     * @notice Gets an 8 hour time weighted avg price for a given tracer, at a particular hour. More recent prices are weighted more heavily.\n     * @param hour An integer representing what hour of the day to collect from (0-24)\n     * @return the time weighted average price for both the oraclePrice (derivative price) and the Tracer Price\n     */\n    function getTWAPs(uint256 hour) public view override returns (Prices.TWAP memory) {\n        return Prices.calculateTWAP(hour, hourlyTracerPrices, hourlyOraclePrices);\n    }\n\n    /**\n     * @notice Gets a 24 hour tracer and oracle price for a given tracer market\n     * @return the average price over a 24 hour period for oracle and Tracer price\n     */\n    function get24HourPrices() public view override returns (uint256, uint256) {\n        return (Prices.averagePriceForPeriod(hourlyTracerPrices), Prices.averagePriceForPeriod(hourlyOraclePrices));\n    }\n\n    /**\n     * @notice Gets the average tracer price for a given market during a certain hour\n     * @param hour The hour of which you want the hourly average Price\n     * @return the average price of the tracer for a particular hour\n     */\n    function getHourlyAvgTracerPrice(uint256 hour) public view override returns (uint256) {\n        return Prices.averagePrice(hourlyTracerPrices[hour]);\n    }\n\n    /**\n     * @notice Gets the average oracle price for a given market during a certain hour\n     * @param hour The hour of which you want the hourly average Price\n     */\n    function getHourlyAvgOraclePrice(uint256 hour) external view override returns (uint256) {\n        return Prices.averagePrice(hourlyOraclePrices[hour]);\n    }\n\n    /**\n     * @dev Used when only valid tracers are allowed\n     */\n    modifier onlyTracer() {\n        require(msg.sender == tracer, \"PRC: Only Tracer\");\n        _;\n    }\n}\ncontract Trader is ITrader {\n    // EIP712 Constants\n    // https://eips.ethereum.org/EIPS/eip-712\n    string private constant EIP712_DOMAIN_NAME = \"Tracer Protocol\";\n    string private constant EIP712_DOMAIN_VERSION = \"1.0\";\n    bytes32 private constant EIP712_DOMAIN_SEPERATOR =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // EIP712 Types\n    bytes32 private constant ORDER_TYPE =\n        keccak256(\n            \"Order(address maker,address market,uint256 price,uint256 amount,uint256 side,uint256 expires,uint256 created)\"\n        );\n\n    uint256 public constant override chainId = 1337; // Changes per chain\n    bytes32 public immutable override EIP712_DOMAIN;\n\n    // order hash to memory\n    mapping(bytes32 => Perpetuals.Order) public orders;\n    // maps an order hash to its signed order if seen before\n    mapping(bytes32 => Types.SignedLimitOrder) public orderToSig;\n    // order hash to amount filled\n    mapping(bytes32 => uint256) public override filled;\n    // order hash to average execution price thus far\n    mapping(bytes32 => uint256) public override averageExecutionPrice;\n\n    constructor() {\n        // Construct the EIP712 Domain\n        EIP712_DOMAIN = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_SEPERATOR,\n                keccak256(bytes(EIP712_DOMAIN_NAME)),\n                keccak256(bytes(EIP712_DOMAIN_VERSION)),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function filledAmount(Perpetuals.Order memory order) external view override returns (uint256) {\n        return filled[Perpetuals.orderId(order)];\n    }\n\n    function getAverageExecutionPrice(Perpetuals.Order memory order) external view override returns (uint256) {\n        return averageExecutionPrice[Perpetuals.orderId(order)];\n    }\n\n    /**\n     * @notice Batch executes maker and taker orders against a given market. Currently matching works\n     *         by matching orders 1 to 1\n     * @param makers An array of signed make orders\n     * @param takers An array of signed take orders\n     */\n    function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers)\n        external\n        override\n    {\n        require(makers.length == takers.length, \"TDR: Lengths differ\");\n\n        // safe as we've already bounds checked the array lengths\n        uint256 n = makers.length;\n\n        require(n > 0, \"TDR: Received empty arrays\");\n\n        for (uint256 i = 0; i < n; i++) {\n            // verify each order individually and together\n            if (\n                !isValidSignature(makers[i].order.maker, makers[i]) ||\n                !isValidSignature(takers[i].order.maker, takers[i]) ||\n                !isValidPair(takers[i], makers[i])\n            ) {\n                // skip if either order is invalid\n                continue;\n            }\n\n            // retrieve orders\n            // if the order does not exist, it is created here\n            Perpetuals.Order memory makeOrder = grabOrder(makers, i);\n            Perpetuals.Order memory takeOrder = grabOrder(takers, i);\n\n            bytes32 makerOrderId = Perpetuals.orderId(makeOrder);\n            bytes32 takerOrderId = Perpetuals.orderId(takeOrder);\n\n            uint256 makeOrderFilled = filled[makerOrderId];\n            uint256 takeOrderFilled = filled[takerOrderId];\n\n            uint256 fillAmount = Balances.fillAmount(makeOrder, makeOrderFilled, takeOrder, takeOrderFilled);\n\n            uint256 executionPrice = Perpetuals.getExecutionPrice(makeOrder, takeOrder);\n            uint256 newMakeAverage = Perpetuals.calculateAverageExecutionPrice(\n                makeOrderFilled,\n                averageExecutionPrice[makerOrderId],\n                fillAmount,\n                executionPrice\n            );\n            uint256 newTakeAverage = Perpetuals.calculateAverageExecutionPrice(\n                takeOrderFilled,\n                averageExecutionPrice[takerOrderId],\n                fillAmount,\n                executionPrice\n            );\n\n            // match orders\n            // referencing makeOrder.market is safe due to above require\n            // make low level call to catch revert\n            // todo this could be succeptible to re-entrancy as\n            // market is never verified\n            (bool success, ) = makeOrder.market.call(\n                abi.encodePacked(\n                    ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,\n                    abi.encode(makeOrder, takeOrder, fillAmount)\n                )\n            );\n\n            // ignore orders that cannot be executed\n            if (!success) continue;\n\n            // update order state\n            filled[makerOrderId] = makeOrderFilled + fillAmount;\n            filled[takerOrderId] = takeOrderFilled + fillAmount;\n            averageExecutionPrice[makerOrderId] = newMakeAverage;\n            averageExecutionPrice[takerOrderId] = newTakeAverage;\n        }\n    }\n\n    /**\n     * @notice Retrieves and validates an order from an order array\n     * @param signedOrders an array of signed orders\n     * @param index the index into the array where the desired order is\n     * @return the specified order\n     * @dev Should only be called with a verified signedOrder and with index\n     *      < signedOrders.length\n     */\n    function grabOrder(Types.SignedLimitOrder[] memory signedOrders, uint256 index)\n        internal\n        returns (Perpetuals.Order memory)\n    {\n        Perpetuals.Order memory rawOrder = signedOrders[index].order;\n\n        bytes32 orderHash = Perpetuals.orderId(rawOrder);\n        // check if order exists on chain, if not, create it\n        if (orders[orderHash].maker == address(0)) {\n            // store this order to keep track of state\n            orders[orderHash] = rawOrder;\n            // map the order hash to the signed order\n            orderToSig[orderHash] = signedOrders[index];\n        }\n\n        return orders[orderHash];\n    }\n\n    /**\n     * @notice hashes a limit order type in order to verify signatures, per EIP712\n     * @param order the limit order being hashed\n     * @return an EIP712 compliant hash (with headers) of the limit order\n     */\n    function hashOrder(Perpetuals.Order memory order) public view override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    EIP712_DOMAIN,\n                    keccak256(\n                        abi.encode(\n                            ORDER_TYPE,\n                            order.maker,\n                            order.market,\n                            order.price,\n                            order.amount,\n                            uint256(order.side),\n                            order.expires,\n                            order.created\n                        )\n                    )\n                )\n            );\n    }\n\n    /**\n     * @notice Gets the EIP712 domain hash of the contract\n     */\n    function getDomain() external view override returns (bytes32) {\n        return EIP712_DOMAIN;\n    }\n\n    /**\n     * @notice Verifies a given limit order has been signed by a given signer and has a correct nonce\n     * @param signer The signer who is being verified against the order\n     * @param signedOrder The signed order to verify the signature of\n     * @return if an order has a valid signature and a valid nonce\n     * @dev does not throw if the signature is invalid.\n     */\n    function isValidSignature(address signer, Types.SignedLimitOrder memory signedOrder) internal view returns (bool) {\n        return verifySignature(signer, signedOrder);\n    }\n\n    /**\n     * @notice Validates a given pair of signed orders against each other\n     * @param signedOrder1 the first signed order\n     * @param signedOrder2 the second signed order\n     * @return if signedOrder1 is compatible with signedOrder2\n     * @dev does not throw if pairs are invalid\n     */\n    function isValidPair(Types.SignedLimitOrder memory signedOrder1, Types.SignedLimitOrder memory signedOrder2)\n        internal\n        pure\n        returns (bool)\n    {\n        return (signedOrder1.order.market == signedOrder2.order.market);\n    }\n\n    /**\n     * @notice Verifies the signature component of a signed order\n     * @param signer The signer who is being verified against the order\n     * @param signedOrder The unsigned order to verify the signature of\n     * @return true is signer has signed the order, else false\n     */\n    function verifySignature(address signer, Types.SignedLimitOrder memory signedOrder)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return\n            signer == ECDSA.recover(hashOrder(signedOrder.order), signedOrder.sigV, signedOrder.sigR, signedOrder.sigS);\n    }\n\n    /**\n     * @return An order that has been previously created in contract, given a user-supplied order\n     * @dev Useful for checking to see if a supplied order has actually been created\n     */\n    function getOrder(Perpetuals.Order calldata order) external view override returns (Perpetuals.Order memory) {\n        bytes32 orderId = Perpetuals.orderId(order);\n        return orders[orderId];\n    }\n}\ncontract Liquidation is ILiquidation, Ownable {\n    using LibMath for uint256;\n    using LibMath for int256;\n\n    uint256 public override currentLiquidationId;\n    uint256 public override maxSlippage;\n    uint256 public override releaseTime = 15 minutes;\n    uint256 public override minimumLeftoverGasCostMultiplier = 10;\n    IPricing public pricing;\n    ITracerPerpetualSwaps public tracer;\n    address public insuranceContract;\n    address public fastGasOracle;\n\n    // Receipt ID => LiquidationReceipt\n    mapping(uint256 => LibLiquidation.LiquidationReceipt) public liquidationReceipts;\n\n    event ClaimedReceipts(address indexed liquidator, address indexed market, uint256 indexed receiptId);\n    event ClaimedEscrow(address indexed liquidatee, address indexed market, uint256 indexed id);\n    event Liquidate(\n        address indexed account,\n        address indexed liquidator,\n        int256 liquidationAmount,\n        Perpetuals.Side side,\n        address indexed market,\n        uint256 liquidationId\n    );\n    event InvalidClaimOrder(uint256 indexed receiptId);\n\n    /**\n     * @param _pricing Pricing.sol contract address\n     * @param _tracer TracerPerpetualSwaps.sol contract address\n     * @param _insuranceContract Insurance.sol contract address\n     * @param _fastGasOracle Address of the contract that implements the IOracle.sol interface\n     * @param _maxSlippage The maximum slippage percentage that is allowed on selling a\n                           liquidated position. Given as a decimal WAD. e.g 5% = 0.05*10^18\n     */\n    constructor(\n        address _pricing,\n        address _tracer,\n        address _insuranceContract,\n        address _fastGasOracle,\n        uint256 _maxSlippage\n    ) Ownable() {\n        pricing = IPricing(_pricing);\n        tracer = ITracerPerpetualSwaps(_tracer);\n        insuranceContract = _insuranceContract;\n        fastGasOracle = _fastGasOracle;\n        maxSlippage = _maxSlippage;\n    }\n\n    /**\n     * @notice Creates a liquidation receipt for a given trader\n     * @param liquidator the account executing the liquidation\n     * @param liquidatee the account being liquidated\n     * @param price the price at which this liquidation event occurred\n     * @param escrowedAmount the amount of funds required to be locked into escrow\n     *                       by the liquidator\n     * @param amountLiquidated the amount of positions that were liquidated\n     * @param liquidationSide the side of the positions being liquidated. true for long\n     *                        false for short.\n     */\n    function submitLiquidation(\n        address liquidator,\n        address liquidatee,\n        uint256 price,\n        uint256 escrowedAmount,\n        int256 amountLiquidated,\n        Perpetuals.Side liquidationSide\n    ) internal {\n        liquidationReceipts[currentLiquidationId] = LibLiquidation.LiquidationReceipt({\n            tracer: address(tracer),\n            liquidator: liquidator,\n            liquidatee: liquidatee,\n            price: price,\n            time: block.timestamp,\n            escrowedAmount: escrowedAmount,\n            releaseTime: block.timestamp + releaseTime,\n            amountLiquidated: amountLiquidated,\n            escrowClaimed: false,\n            liquidationSide: liquidationSide,\n            liquidatorRefundClaimed: false\n        });\n        currentLiquidationId += 1;\n    }\n\n    /**\n     * @notice Allows a trader to claim escrowed funds after the escrow period has expired\n     * @param receiptId The ID number of the insurance receipt from which funds are being claimed from\n     */\n    function claimEscrow(uint256 receiptId) public override {\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        require(!receipt.escrowClaimed, \"LIQ: Escrow claimed\");\n        require(block.timestamp > receipt.releaseTime, \"LIQ: Not released\");\n\n        // Mark as claimed\n        liquidationReceipts[receiptId].escrowClaimed = true;\n\n        // Update balance\n        int256 amountToReturn = receipt.escrowedAmount.toInt256();\n        emit ClaimedEscrow(receipt.liquidatee, receipt.tracer, receiptId);\n        tracer.updateAccountsOnClaim(address(0), 0, receipt.liquidatee, amountToReturn, 0);\n    }\n\n    /**\n     * @notice Returns liquidation receipt data for a given receipt id.\n     * @param id the receipt id to get data for\n     */\n    function getLiquidationReceipt(uint256 id)\n        external\n        view\n        override\n        returns (LibLiquidation.LiquidationReceipt memory)\n    {\n        return liquidationReceipts[id];\n    }\n\n    /**\n     * @notice Verify that a Liquidation is valid; submits liquidation receipt if it is\n     * @dev Reverts if the liquidation is invalid\n     * @param base Amount of base in the account to be liquidated (denominated in base tokens)\n     * @param price Fair price of the asset (denominated in quote/base)\n     * @param quote Amount of quote in the account to be liquidated (denominated in quote tokens)\n     * @param amount Amount of tokens to be liquidated\n     * @param gasPrice Current gas price, denominated in gwei\n     * @param account Account to be liquidated\n     * @return Amount to be escrowed for the liquidation\n     */\n    function verifyAndSubmitLiquidation(\n        int256 base,\n        uint256 price,\n        int256 quote,\n        int256 amount,\n        uint256 gasPrice,\n        address account\n    ) internal returns (uint256) {\n        require(amount > 0, \"LIQ: Liquidation amount <= 0\");\n        require(tx.gasprice <= IOracle(fastGasOracle).latestAnswer(), \"LIQ: GasPrice > FGasPrice\");\n\n        Balances.Position memory pos = Balances.Position(quote, base);\n        uint256 gasCost = gasPrice * tracer.LIQUIDATION_GAS_COST();\n\n        int256 currentMargin = Balances.margin(pos, price);\n        require(\n            currentMargin <= 0 ||\n                uint256(currentMargin) < Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),\n            \"LIQ: Account above margin\"\n        );\n        require(amount <= base.abs(), \"LIQ: Liquidate Amount > Position\");\n\n        // calc funds to liquidate and move to Escrow\n        uint256 amountToEscrow = LibLiquidation.calcEscrowLiquidationAmount(\n            Balances.minimumMargin(pos, price, gasCost, tracer.trueMaxLeverage()),\n            currentMargin,\n            amount,\n            base\n        );\n\n        // create a liquidation receipt\n        Perpetuals.Side side = base < 0 ? Perpetuals.Side.Short : Perpetuals.Side.Long;\n        submitLiquidation(msg.sender, account, price, amountToEscrow, amount, side);\n        return amountToEscrow;\n    }\n\n    /**\n     * @return true if the margin is greater than 10x liquidation gas cost (in quote tokens)\n     * @param updatedPosition The agent's position after being liquidated\n     * @param lastUpdatedGasPrice The last updated gas price of the account to be liquidated\n     */\n    function checkPartialLiquidation(Balances.Position memory updatedPosition, uint256 lastUpdatedGasPrice)\n        public\n        view\n        returns (bool)\n    {\n        uint256 liquidationGasCost = tracer.LIQUIDATION_GAS_COST();\n        uint256 price = pricing.fairPrice();\n\n        return\n            LibLiquidation.partialLiquidationIsValid(\n                updatedPosition,\n                lastUpdatedGasPrice,\n                liquidationGasCost,\n                price,\n                minimumLeftoverGasCostMultiplier\n            );\n    }\n\n    /**\n     * @notice Liquidates the margin account of a particular user. A deposit is needed from the liquidator.\n     *         Generates a liquidation receipt for the liquidator to use should they need a refund.\n     * @param amount The amount of tokens to be liquidated\n     * @param account The account that is to be liquidated.\n     */\n    function liquidate(int256 amount, address account) external override {\n        /* Liquidated account's balance */\n        Balances.Account memory liquidatedBalance = tracer.getBalance(account);\n\n        uint256 amountToEscrow = verifyAndSubmitLiquidation(\n            liquidatedBalance.position.base,\n            pricing.fairPrice(),\n            liquidatedBalance.position.quote,\n            amount,\n            liquidatedBalance.lastUpdatedGasPrice,\n            account\n        );\n\n        (\n            int256 liquidatorQuoteChange,\n            int256 liquidatorBaseChange,\n            int256 liquidateeQuoteChange,\n            int256 liquidateeBaseChange\n        ) = LibLiquidation.liquidationBalanceChanges(\n            liquidatedBalance.position.base,\n            liquidatedBalance.position.quote,\n            amount\n        );\n\n        Balances.Position memory updatedPosition = Balances.Position(\n            liquidatedBalance.position.quote + liquidateeQuoteChange,\n            liquidatedBalance.position.base + liquidateeBaseChange\n        );\n\n        require(\n            checkPartialLiquidation(updatedPosition, liquidatedBalance.lastUpdatedGasPrice),\n            \"LIQ: leaves too little left over\"\n        );\n\n        tracer.updateAccountsOnLiquidation(\n            msg.sender,\n            account,\n            liquidatorQuoteChange,\n            liquidatorBaseChange,\n            liquidateeQuoteChange,\n            liquidateeBaseChange,\n            amountToEscrow\n        );\n\n        emit Liquidate(\n            account,\n            msg.sender,\n            amount,\n            (liquidatedBalance.position.base < 0 ? Perpetuals.Side.Short : Perpetuals.Side.Long),\n            address(tracer),\n            currentLiquidationId - 1\n        );\n    }\n\n    /**\n     * @notice Calculates the number of units sold and the average price of those units by a trader\n     *         given multiple order\n     * @param orders a list of orders for which the units sold is being calculated from\n     * @param traderContract The trader contract with which the orders were made\n     * @param receiptId the id of the liquidation receipt the orders are being claimed against\n     */\n    function calcUnitsSold(\n        Perpetuals.Order[] memory orders,\n        address traderContract,\n        uint256 receiptId\n    ) public override returns (uint256, uint256) {\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        uint256 unitsSold;\n        uint256 avgPrice;\n        for (uint256 i; i < orders.length; i++) {\n            Perpetuals.Order memory order = ITrader(traderContract).getOrder(orders[i]);\n\n            if (\n                order.created < receipt.time || // Order made before receipt\n                order.maker != receipt.liquidator || // Order made by someone who isn't liquidator\n                order.side == receipt.liquidationSide // Order is in same direction as liquidation\n                /* Order should be the opposite to the position acquired on liquidation */\n            ) {\n                emit InvalidClaimOrder(receiptId);\n                continue;\n            }\n            if (\n                (receipt.liquidationSide == Perpetuals.Side.Long && order.price >= receipt.price) ||\n                (receipt.liquidationSide == Perpetuals.Side.Short && order.price <= receipt.price)\n            ) {\n                // Liquidation position was long\n                // Price went up, so not a slippage order\n                // or\n                // Liquidation position was short\n                // Price went down, so not a slippage order\n                emit InvalidClaimOrder(receiptId);\n                continue;\n            }\n            uint256 orderFilled = ITrader(traderContract).filledAmount(order);\n            uint256 averageExecutionPrice = ITrader(traderContract).getAverageExecutionPrice(order);\n\n            /* order.created >= receipt.time\n             * && order.maker == receipt.liquidator\n             * && order.side != receipt.liquidationSide */\n            unitsSold = unitsSold + orderFilled;\n            avgPrice = avgPrice + (averageExecutionPrice * orderFilled);\n        }\n\n        // Avoid divide by 0 if no orders sold\n        if (unitsSold == 0) {\n            return (0, 0);\n        }\n        return (unitsSold, avgPrice / unitsSold);\n    }\n\n    /**\n     * @notice Marks receipts as claimed and returns the refund amount\n     * @param escrowId the id of the receipt created during the liquidation event\n     * @param orders the orders that sell the liquidated positions\n     * @param traderContract the address of the trader contract the selling orders were made by\n     */\n    function calcAmountToReturn(\n        uint256 escrowId,\n        Perpetuals.Order[] memory orders,\n        address traderContract\n    ) public override returns (uint256) {\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[escrowId];\n        // Validate the escrowed order was fully sold\n        (uint256 unitsSold, uint256 avgPrice) = calcUnitsSold(orders, traderContract, escrowId);\n        require(unitsSold <= uint256(receipt.amountLiquidated.abs()), \"LIQ: Unit mismatch\");\n\n        uint256 amountToReturn = LibLiquidation.calculateSlippage(unitsSold, maxSlippage, avgPrice, receipt);\n        return amountToReturn;\n    }\n\n    /**\n     * @notice Drains a certain amount from insurance pool to cover excess slippage not covered by escrow\n     * @param amountWantedFromInsurance How much we want to drain\n     * @param receipt The liquidation receipt for which we are calling on the insurance pool to cover\n     */\n    function drainInsurancePoolOnLiquidation(\n        uint256 amountWantedFromInsurance,\n        LibLiquidation.LiquidationReceipt memory receipt\n    ) internal returns (uint256 _amountTakenFromInsurance, uint256 _amountToGiveToClaimant) {\n        /*\n         * If there was not enough escrowed, we want to call the insurance pool to help out.\n         * First, check the margin of the insurance Account. If this is enough, just drain from there.\n         * If this is not enough, call Insurance.drainPool to get some tokens from the insurance pool.\n         * If drainPool is able to drain enough, drain from the new margin.\n         * If the margin still does not have enough after calling drainPool, we are not able to fully\n         * claim the receipt, only up to the amount the insurance pool allows for.\n         */\n\n        Balances.Account memory insuranceBalance = tracer.getBalance(insuranceContract);\n        if (insuranceBalance.position.quote >= amountWantedFromInsurance.toInt256()) {\n            // We don't need to drain insurance contract. The balance is already in the market contract\n            _amountTakenFromInsurance = amountWantedFromInsurance;\n        } else {\n            // insuranceBalance.quote < amountWantedFromInsurance\n            if (insuranceBalance.position.quote <= 0) {\n                // attempt to drain entire balance that is needed from the pool\n                IInsurance(insuranceContract).drainPool(amountWantedFromInsurance);\n            } else {\n                // attempt to drain the required balance taking into account the insurance balance in the account contract\n                IInsurance(insuranceContract).drainPool(\n                    amountWantedFromInsurance - uint256(insuranceBalance.position.quote)\n                );\n            }\n            Balances.Account memory updatedInsuranceBalance = tracer.getBalance(insuranceContract);\n            if (updatedInsuranceBalance.position.quote < amountWantedFromInsurance.toInt256()) {\n                // Still not enough\n                _amountTakenFromInsurance = uint256(updatedInsuranceBalance.position.quote);\n            } else {\n                _amountTakenFromInsurance = amountWantedFromInsurance;\n            }\n        }\n\n        _amountToGiveToClaimant = receipt.escrowedAmount + _amountTakenFromInsurance;\n        // Don't add any to liquidatee\n    }\n\n    /**\n     * @notice Allows a liquidator to submit a single liquidation receipt and multiple order ids. If the\n     *         liquidator experienced slippage, will refund them a proportional amount of their deposit.\n     * @param receiptId Used to identify the receipt that will be claimed\n     * @param orders The orders that sold the liquidated position\n     */\n    function claimReceipt(\n        uint256 receiptId,\n        Perpetuals.Order[] memory orders,\n        address traderContract\n    ) external override {\n        // Claim the receipts from the escrow system, get back amount to return\n        LibLiquidation.LiquidationReceipt memory receipt = liquidationReceipts[receiptId];\n        require(receipt.liquidator == msg.sender, \"LIQ: Liquidator mismatch\");\n        // Mark refund as claimed\n        require(!receipt.liquidatorRefundClaimed, \"LIQ: Already claimed\");\n        liquidationReceipts[receiptId].liquidatorRefundClaimed = true;\n        liquidationReceipts[receiptId].escrowClaimed = true;\n        require(block.timestamp < receipt.releaseTime, \"LIQ: claim time passed\");\n        require(tracer.tradingWhitelist(traderContract), \"LIQ: Trader is not whitelisted\");\n\n        uint256 amountToReturn = calcAmountToReturn(receiptId, orders, traderContract);\n\n        if (amountToReturn > receipt.escrowedAmount) {\n            liquidationReceipts[receiptId].escrowedAmount = 0;\n        } else {\n            liquidationReceipts[receiptId].escrowedAmount = receipt.escrowedAmount - amountToReturn;\n        }\n\n        // Keep track of how much was actually taken out of insurance\n        uint256 amountTakenFromInsurance;\n        uint256 amountToGiveToClaimant;\n        uint256 amountToGiveToLiquidatee;\n\n        if (amountToReturn > receipt.escrowedAmount) {\n            // Need to cover some loses with the insurance contract\n            // Whatever is the remainder that can't be covered from escrow\n            uint256 amountWantedFromInsurance = amountToReturn - receipt.escrowedAmount;\n            (amountTakenFromInsurance, amountToGiveToClaimant) = drainInsurancePoolOnLiquidation(\n                amountWantedFromInsurance,\n                receipt\n            );\n        } else {\n            amountToGiveToClaimant = amountToReturn;\n            amountToGiveToLiquidatee = receipt.escrowedAmount - amountToReturn;\n        }\n\n        tracer.updateAccountsOnClaim(\n            receipt.liquidator,\n            amountToGiveToClaimant.toInt256(),\n            receipt.liquidatee,\n            amountToGiveToLiquidatee.toInt256(),\n            amountTakenFromInsurance.toInt256()\n        );\n        emit ClaimedReceipts(msg.sender, address(tracer), receiptId);\n    }\n\n    function transferOwnership(address newOwner) public override(Ownable, ILiquidation) onlyOwner {\n        super.transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice Modifies the release time\n     * @param _releaseTime new release time\n     */\n    function setReleaseTime(uint256 _releaseTime) external onlyOwner() {\n        releaseTime = _releaseTime;\n    }\n\n    /**\n     * @notice Modifies the value to multiply the liquidation cost by in determining\n     *         the minimum leftover margin on partial liquidation\n     * @param _minimumLeftoverGasCostMultiplier The new multiplier\n     */\n    function setMinimumLeftoverGasCostMultiplier(uint256 _minimumLeftoverGasCostMultiplier) external onlyOwner() {\n        minimumLeftoverGasCostMultiplier = _minimumLeftoverGasCostMultiplier;\n    }\n\n    /**\n     * @notice Modifies the max slippage\n     * @param _maxSlippage new max slippage\n     */\n    function setMaxSlippage(uint256 _maxSlippage) public override onlyOwner() {\n        maxSlippage = _maxSlippage;\n    }\n}\ncontract SafetyWithdraw is Ownable, ISafetyWithdraw {\n    function withdrawERC20Token(\n        address tokenAddress,\n        address to,\n        uint256 amount\n    ) external override onlyOwner {\n        IERC20(tokenAddress).transfer(to, amount);\n    }\n}\ncontract TracerPerpetualSwaps is ITracerPerpetualSwaps, Ownable, SafetyWithdraw {\n    using LibMath for uint256;\n    using LibMath for int256;\n    using PRBMathSD59x18 for int256;\n    using PRBMathUD60x18 for uint256;\n\n    uint256 public constant override LIQUIDATION_GAS_COST = 63516;\n    address public immutable override tracerQuoteToken;\n    uint256 public immutable override quoteTokenDecimals;\n    bytes32 public immutable override marketId;\n    IPricing public pricingContract;\n    IInsurance public insuranceContract;\n    address public override liquidationContract;\n    uint256 public override feeRate;\n    uint256 public override fees;\n    address public override feeReceiver;\n\n    /* Config variables */\n    // The price of gas in gwei\n    address public override gasPriceOracle;\n    // The maximum ratio of notionalValue to margin\n    uint256 public override maxLeverage;\n    // WAD value. sensitivity of 1 = 1*10^18\n    uint256 public override fundingRateSensitivity;\n    // WAD value. The percentage for insurance pool holdings/pool target where deleveraging begins\n    uint256 public override deleveragingCliff;\n    /* The percentage of insurance holdings to target at which the insurance pool\n       funding rate changes, and lowestMaxLeverage is reached */\n    uint256 public override insurancePoolSwitchStage;\n    // The lowest value that maxLeverage can be, if insurance pool is empty.\n    uint256 public override lowestMaxLeverage;\n\n    // Account State Variables\n    mapping(address => Balances.Account) public balances;\n    uint256 public tvl;\n    uint256 public override leveragedNotionalValue;\n\n    // Trading interfaces whitelist\n    mapping(address => bool) public override tradingWhitelist;\n\n    event FeeReceiverUpdated(address indexed receiver);\n    event FeeWithdrawn(address indexed receiver, uint256 feeAmount);\n    event Deposit(address indexed user, uint256 indexed amount);\n    event Withdraw(address indexed user, uint256 indexed amount);\n    event Settled(address indexed account, int256 margin);\n    event MatchedOrders(\n        address indexed long,\n        address indexed short,\n        uint256 amount,\n        uint256 price,\n        bytes32 longOrderId,\n        bytes32 shortOrderId\n    );\n    event FailedOrders(address indexed long, address indexed short, bytes32 longOrderId, bytes32 shortOrderId);\n\n    /**\n     * @notice Creates a new tracer market and sets the initial funding rate of the market. Anyone\n     *         will be able to purchase and trade tracers after this deployment.\n     * @param _marketId the id of the market, given as BASE/QUOTE\n     * @param _tracerQuoteToken the address of the token used for margin accounts (i.e. The margin token)\n     * @param _tokenDecimals the number of decimal places the quote token supports\n     * @param _gasPriceOracle the address of the contract implementing gas price oracle\n     * @param _maxLeverage the max leverage of the market represented as a WAD value.\n     * @param _fundingRateSensitivity the affect funding rate changes have on funding paid; u60.18-decimal fixed-point number (WAD value)\n     * @param _feeRate the fee taken on trades; WAD value. e.g. 2% fee = 0.02 * 10^18 = 2 * 10^16\n     * @param _feeReceiver the address of the person who can withdraw the fees from trades in this market\n     * @param _deleveragingCliff The percentage for insurance pool holdings/pool target where deleveraging begins.\n     *                           WAD value. e.g. 20% = 20*10^18\n     * @param _lowestMaxLeverage The lowest value that maxLeverage can be, if insurance pool is empty.\n     * @param _insurancePoolSwitchStage The percentage of insurance holdings to target at which the insurance pool\n     *                                  funding rate changes, and lowestMaxLeverage is reached\n     */\n    constructor(\n        bytes32 _marketId,\n        address _tracerQuoteToken,\n        uint256 _tokenDecimals,\n        address _gasPriceOracle,\n        uint256 _maxLeverage,\n        uint256 _fundingRateSensitivity,\n        uint256 _feeRate,\n        address _feeReceiver,\n        uint256 _deleveragingCliff,\n        uint256 _lowestMaxLeverage,\n        uint256 _insurancePoolSwitchStage\n    ) Ownable() {\n        // don't convert to interface as we don't need to interact with the contract\n        tracerQuoteToken = _tracerQuoteToken;\n        quoteTokenDecimals = _tokenDecimals;\n        gasPriceOracle = _gasPriceOracle;\n        marketId = _marketId;\n        feeRate = _feeRate;\n        maxLeverage = _maxLeverage;\n        fundingRateSensitivity = _fundingRateSensitivity;\n        feeReceiver = _feeReceiver;\n        deleveragingCliff = _deleveragingCliff;\n        lowestMaxLeverage = _lowestMaxLeverage;\n        insurancePoolSwitchStage = _insurancePoolSwitchStage;\n    }\n\n    /**\n     * @notice Adjust the max leverage as insurance pool slides from 100% of target to 0% of target\n     */\n    function trueMaxLeverage() public view override returns (uint256) {\n        IInsurance insurance = IInsurance(insuranceContract);\n\n        return\n            Perpetuals.calculateTrueMaxLeverage(\n                insurance.getPoolHoldings(),\n                insurance.getPoolTarget(),\n                maxLeverage,\n                lowestMaxLeverage,\n                deleveragingCliff,\n                insurancePoolSwitchStage\n            );\n    }\n\n    /**\n     * @notice Allows a user to deposit into their margin account\n     * @dev this contract must be an approved spender of the markets quote token on behalf of the depositer.\n     * @param amount The amount of quote tokens to be deposited into the Tracer Market account. This amount\n     * should be given in WAD format.\n     */\n    function deposit(uint256 amount) external override {\n        Balances.Account storage userBalance = balances[msg.sender];\n        // settle outstanding payments\n        settle(msg.sender);\n\n        // convert the WAD amount to the correct token amount to transfer\n        // cast is safe since amount is a uint, and wadToToken can only\n        // scale down the value\n        uint256 rawTokenAmount = uint256(Balances.wadToToken(quoteTokenDecimals, amount).toInt256());\n        IERC20(tracerQuoteToken).transferFrom(msg.sender, address(this), rawTokenAmount);\n\n        // this prevents dust from being added to the user account\n        // eg 10^18 -> 10^8 -> 10^18 will remove lower order bits\n        int256 convertedWadAmount = Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount);\n\n        // update user state\n        userBalance.position.quote = userBalance.position.quote + convertedWadAmount;\n        _updateAccountLeverage(msg.sender);\n\n        // update market TVL\n        tvl = tvl + uint256(convertedWadAmount);\n        emit Deposit(msg.sender, amount);\n    }\n\n    /**\n     * @notice Allows a user to withdraw from their margin account\n     * @dev Ensures that the users margin percent is valid after withdraw\n     * @param amount The amount of margin tokens to be withdrawn from the tracer market account. This amount\n     * should be given in WAD format\n     */\n    function withdraw(uint256 amount) external override {\n        // settle outstanding payments\n        settle(msg.sender);\n\n        uint256 rawTokenAmount = Balances.wadToToken(quoteTokenDecimals, amount);\n        int256 convertedWadAmount = Balances.tokenToWad(quoteTokenDecimals, rawTokenAmount);\n\n        Balances.Account storage userBalance = balances[msg.sender];\n        int256 newQuote = userBalance.position.quote - convertedWadAmount;\n\n        // this may be able to be optimised\n        Balances.Position memory newPosition = Balances.Position(newQuote, userBalance.position.base);\n\n        require(\n            Balances.marginIsValid(\n                newPosition,\n                userBalance.lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            ),\n            \"TCR: Withdraw below valid Margin\"\n        );\n\n        // update user state\n        userBalance.position.quote = newQuote;\n        _updateAccountLeverage(msg.sender);\n\n        // Safemath will throw if tvl < amount\n        tvl = tvl - amount;\n\n        // perform transfer\n        IERC20(tracerQuoteToken).transfer(msg.sender, rawTokenAmount);\n        emit Withdraw(msg.sender, uint256(convertedWadAmount));\n    }\n\n    /**\n     * @notice Attempt to match two orders that exist on-chain against each other\n     * @dev Emits a FailedOrders or MatchedOrders event based on whether the\n     *      orders were successfully able to be matched\n     * @param order1 The first order\n     * @param order2 The second order\n     * @param fillAmount Amount that the two orders are being filled for\n     * @return Whether the two orders were able to be matched successfully\n     */\n    function matchOrders(\n        Perpetuals.Order memory order1,\n        Perpetuals.Order memory order2,\n        uint256 fillAmount\n    ) external override onlyWhitelisted returns (bool) {\n        bytes32 order1Id = Perpetuals.orderId(order1);\n        bytes32 order2Id = Perpetuals.orderId(order2);\n        uint256 filled1 = ITrader(msg.sender).filled(order1Id);\n        uint256 filled2 = ITrader(msg.sender).filled(order2Id);\n\n        uint256 executionPrice = Perpetuals.getExecutionPrice(order1, order2);\n\n        // settle accounts\n        // note: this can revert and hence no order events will be emitted\n        settle(order1.maker);\n        settle(order2.maker);\n\n        (Balances.Position memory newPos1, Balances.Position memory newPos2) = _executeTrade(\n            order1,\n            order2,\n            fillAmount,\n            executionPrice\n        );\n        // validate orders can match, and outcome state is valid\n        if (\n            !Perpetuals.canMatch(order1, filled1, order2, filled2) ||\n            !Balances.marginIsValid(\n                newPos1,\n                balances[order1.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            ) ||\n            !Balances.marginIsValid(\n                newPos2,\n                balances[order2.maker].lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            )\n        ) {\n            // emit failed to match event and return false\n            if (order1.side == Perpetuals.Side.Long) {\n                emit FailedOrders(order1.maker, order2.maker, order1Id, order2Id);\n            } else {\n                emit FailedOrders(order2.maker, order1.maker, order2Id, order1Id);\n            }\n            return false;\n        }\n\n        // update account states\n        balances[order1.maker].position = newPos1;\n        balances[order2.maker].position = newPos2;\n\n        // update fees\n        fees =\n            fees +\n            // add 2 * fees since getFeeRate returns the fee rate for a single\n            // side of the order. Both users were charged fees\n            uint256(Balances.getFee(fillAmount, executionPrice, feeRate) * 2);\n\n        // update leverage\n        _updateAccountLeverage(order1.maker);\n        _updateAccountLeverage(order2.maker);\n\n        // Update internal trade state\n        pricingContract.recordTrade(executionPrice);\n\n        if (order1.side == Perpetuals.Side.Long) {\n            emit MatchedOrders(order1.maker, order2.maker, fillAmount, executionPrice, order1Id, order2Id);\n        } else {\n            emit MatchedOrders(order2.maker, order1.maker, fillAmount, executionPrice, order2Id, order1Id);\n        }\n        return true;\n    }\n\n    /**\n     * @notice Updates account states of two accounts given two orders that are being executed\n     * @param order1 The first order\n     * @param order2 The second order\n     * @param fillAmount The amount that the two ordered are being filled for\n     * @param executionPrice The execution price of the trades\n     * @return The new balances of the two accounts after the trade\n     */\n    function _executeTrade(\n        Perpetuals.Order memory order1,\n        Perpetuals.Order memory order2,\n        uint256 fillAmount,\n        uint256 executionPrice\n    ) internal view returns (Balances.Position memory, Balances.Position memory) {\n        // Retrieve account state\n        Balances.Account memory account1 = balances[order1.maker];\n        Balances.Account memory account2 = balances[order2.maker];\n\n        // Construct `Trade` types suitable for use with LibBalances\n        (Balances.Trade memory trade1, Balances.Trade memory trade2) = (\n            Balances.Trade(executionPrice, fillAmount, order1.side),\n            Balances.Trade(executionPrice, fillAmount, order2.side)\n        );\n\n        // Calculate new account state\n        (Balances.Position memory newPos1, Balances.Position memory newPos2) = (\n            Balances.applyTrade(account1.position, trade1, feeRate),\n            Balances.applyTrade(account2.position, trade2, feeRate)\n        );\n\n        // return new account state\n        return (newPos1, newPos2);\n    }\n\n    /**\n     * @notice internal function for updating leverage. Called within the Account contract. Also\n     *         updates the total leveraged notional value for the tracer market itself.\n     */\n    function _updateAccountLeverage(address account) internal {\n        Balances.Account memory userBalance = balances[account];\n        uint256 originalLeverage = userBalance.totalLeveragedValue;\n        uint256 newLeverage = Balances.leveragedNotionalValue(userBalance.position, pricingContract.fairPrice());\n        balances[account].totalLeveragedValue = newLeverage;\n\n        // Update market leveraged notional value\n        _updateTracerLeverage(newLeverage, originalLeverage);\n    }\n\n    /**\n     * @notice Updates the global leverage value given an accounts new leveraged value and old leveraged value\n     * @param accountNewLeveragedNotional The future notional value of the account\n     * @param accountOldLeveragedNotional The stored notional value of the account\n     */\n    function _updateTracerLeverage(uint256 accountNewLeveragedNotional, uint256 accountOldLeveragedNotional) internal {\n        leveragedNotionalValue = Prices.globalLeverage(\n            leveragedNotionalValue,\n            accountOldLeveragedNotional,\n            accountNewLeveragedNotional\n        );\n    }\n\n    /**\n     * @notice When a liquidation occurs, Liquidation.sol needs to push this contract to update\n     *         account states as necessary.\n     * @param liquidator Address of the account that called liquidate(...)\n     * @param liquidatee Address of the under-margined account getting liquidated\n     * @param liquidatorQuoteChange Amount the liquidator's quote is changing\n     * @param liquidatorBaseChange Amount the liquidator's base is changing\n     * @param liquidateeQuoteChange Amount the liquidated account's quote is changing\n     * @param liquidateeBaseChange Amount the liquidated account's base is changing\n     * @param amountToEscrow The amount the liquidator has to put into escrow\n     */\n    function updateAccountsOnLiquidation(\n        address liquidator,\n        address liquidatee,\n        int256 liquidatorQuoteChange,\n        int256 liquidatorBaseChange,\n        int256 liquidateeQuoteChange,\n        int256 liquidateeBaseChange,\n        uint256 amountToEscrow\n    ) external override onlyLiquidation {\n        // Limits the gas use when liquidating\n        uint256 gasPrice = IOracle(gasPriceOracle).latestAnswer();\n        // Update liquidators last updated gas price\n        Balances.Account storage liquidatorBalance = balances[liquidator];\n        Balances.Account storage liquidateeBalance = balances[liquidatee];\n\n        // update liquidators balance\n        liquidatorBalance.lastUpdatedGasPrice = gasPrice;\n        liquidatorBalance.position.quote =\n            liquidatorBalance.position.quote +\n            liquidatorQuoteChange -\n            amountToEscrow.toInt256();\n        liquidatorBalance.position.base = liquidatorBalance.position.base + liquidatorBaseChange;\n\n        // update liquidatee balance\n        liquidateeBalance.position.quote = liquidateeBalance.position.quote + liquidateeQuoteChange;\n        liquidateeBalance.position.base = liquidateeBalance.position.base + liquidateeBaseChange;\n\n        // Checks if the liquidator is in a valid position to process the liquidation\n        require(userMarginIsValid(liquidator), \"TCR: Liquidator under min margin\");\n    }\n\n    /**\n     * @notice When a liquidation receipt is claimed by the liquidator (i.e. they experienced slippage),\n               Liquidation.sol needs to tell the market to update its balance and the balance of the\n               liquidated agent.\n     * @dev Gives the leftover amount from the receipt to the liquidated agent\n     * @param claimant The liquidator, who has experienced slippage selling the liquidated position\n     * @param amountToGiveToClaimant The amount the liquidator is owe based off slippage\n     * @param liquidatee The account that originally got liquidated\n     * @param amountToGiveToLiquidatee Amount owed to the liquidated account\n     * @param amountToTakeFromInsurance Amount that needs to be taken from the insurance pool\n                                        in order to cover liquidation\n     */\n    function updateAccountsOnClaim(\n        address claimant,\n        int256 amountToGiveToClaimant,\n        address liquidatee,\n        int256 amountToGiveToLiquidatee,\n        int256 amountToTakeFromInsurance\n    ) external override onlyLiquidation {\n        address insuranceAddr = address(insuranceContract);\n        balances[insuranceAddr].position.quote = balances[insuranceAddr].position.quote - amountToTakeFromInsurance;\n        balances[claimant].position.quote = balances[claimant].position.quote + amountToGiveToClaimant;\n        balances[liquidatee].position.quote = balances[liquidatee].position.quote + amountToGiveToLiquidatee;\n        require(balances[insuranceAddr].position.quote >= 0, \"TCR: Insurance not funded enough\");\n    }\n\n    /**\n     * @notice settles an account. Compares current global rate with the users last updated rate\n     *         Updates the accounts margin balance accordingly.\n     * @dev Ensures the account remains in a valid margin position. Will throw if account is under margin\n     *      and the account must then be liquidated.\n     * @param account the address to settle.\n     * @dev This function aggregates data to feed into account.sols settle function which sets\n     */\n    function settle(address account) public override {\n        // Get account and global last updated indexes\n        uint256 accountLastUpdatedIndex = balances[account].lastUpdatedIndex;\n        uint256 currentGlobalFundingIndex = pricingContract.currentFundingIndex();\n        Balances.Account storage accountBalance = balances[account];\n\n        // if this user has no positions, bring them in sync\n        if (accountBalance.position.base == 0) {\n            // set to the last fully established index\n            accountBalance.lastUpdatedIndex = currentGlobalFundingIndex;\n            accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();\n        } else if (accountLastUpdatedIndex + 1 < currentGlobalFundingIndex) {\n            // Only settle account if its last updated index was before the last established\n            // global index this is since we reference the last global index\n            // Get current and global funding statuses\n            uint256 lastEstablishedIndex = currentGlobalFundingIndex - 1;\n            // Note: global rates reference the last fully established rate (hence the -1), and not\n            // the current global rate. User rates reference the last saved user rate\n            Prices.FundingRateInstant memory currGlobalRate = pricingContract.getFundingRate(lastEstablishedIndex);\n            Prices.FundingRateInstant memory currUserRate = pricingContract.getFundingRate(accountLastUpdatedIndex);\n\n            Prices.FundingRateInstant memory currInsuranceGlobalRate = pricingContract.getInsuranceFundingRate(\n                lastEstablishedIndex\n            );\n\n            Prices.FundingRateInstant memory currInsuranceUserRate = pricingContract.getInsuranceFundingRate(\n                accountLastUpdatedIndex\n            );\n\n            // settle the account\n            Balances.Account storage insuranceBalance = balances[address(insuranceContract)];\n\n            accountBalance.position = Prices.applyFunding(accountBalance.position, currGlobalRate, currUserRate);\n\n            // Update account gas price\n            accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();\n\n            if (accountBalance.totalLeveragedValue > 0) {\n                (Balances.Position memory newUserPos, Balances.Position memory newInsurancePos) = Prices.applyInsurance(\n                    accountBalance.position,\n                    insuranceBalance.position,\n                    currInsuranceGlobalRate,\n                    currInsuranceUserRate,\n                    accountBalance.totalLeveragedValue\n                );\n\n                balances[account].position = newUserPos;\n                balances[(address(insuranceContract))].position = newInsurancePos;\n            }\n\n            // Update account index\n            accountBalance.lastUpdatedIndex = lastEstablishedIndex;\n            require(userMarginIsValid(account), \"TCR: Target under-margined\");\n            emit Settled(account, accountBalance.position.quote);\n        }\n    }\n\n    /**\n     * @notice Checks if a given accounts margin is valid\n     * @param account The address of the account whose margin is to be checked\n     * @return true if the margin is valid or false otherwise\n     */\n    function userMarginIsValid(address account) public view returns (bool) {\n        Balances.Account memory accountBalance = balances[account];\n        return\n            Balances.marginIsValid(\n                accountBalance.position,\n                accountBalance.lastUpdatedGasPrice * LIQUIDATION_GAS_COST,\n                pricingContract.fairPrice(),\n                trueMaxLeverage()\n            );\n    }\n\n    /**\n     * @notice Withdraws the fees taken on trades, and sends them to the designated\n     *         fee receiver (set by the owner of the market)\n     * @dev Anyone can call this function, but fees are transferred to the fee receiver.\n     *      Fees is also subtracted from the total value locked in the market because\n     *      fees are taken out of trades that result in users' quotes being modified, and\n     *      don't otherwise get subtracted from the tvl of the market\n     */\n    function withdrawFees() external override {\n        uint256 tempFees = fees;\n        fees = 0;\n        tvl = tvl - tempFees;\n\n        // Withdraw from the account\n        IERC20(tracerQuoteToken).transfer(feeReceiver, tempFees);\n        emit FeeWithdrawn(feeReceiver, tempFees);\n    }\n\n    function getBalance(address account) external view override returns (Balances.Account memory) {\n        return balances[account];\n    }\n\n    function setLiquidationContract(address _liquidationContract) external override onlyOwner {\n        require(_liquidationContract != address(0), \"address(0) given\");\n        liquidationContract = _liquidationContract;\n    }\n\n    function setInsuranceContract(address insurance) external override onlyOwner {\n        require(insurance != address(0), \"address(0) given\");\n        insuranceContract = IInsurance(insurance);\n    }\n\n    function setPricingContract(address pricing) external override onlyOwner {\n        require(pricing != address(0), \"address(0) given\");\n        pricingContract = IPricing(pricing);\n    }\n\n    function setGasOracle(address _gasOracle) external override onlyOwner {\n        require(_gasOracle != address(0), \"address(0) given\");\n        gasPriceOracle = _gasOracle;\n    }\n\n    function setFeeReceiver(address _feeReceiver) external override onlyOwner {\n        require(_feeReceiver != address(0), \"address(0) given\");\n        feeReceiver = _feeReceiver;\n        emit FeeReceiverUpdated(_feeReceiver);\n    }\n\n    function setFeeRate(uint256 _feeRate) external override onlyOwner {\n        feeRate = _feeRate;\n    }\n\n    function setMaxLeverage(uint256 _maxLeverage) external override onlyOwner {\n        maxLeverage = _maxLeverage;\n    }\n\n    function setFundingRateSensitivity(uint256 _fundingRateSensitivity) external override onlyOwner {\n        fundingRateSensitivity = _fundingRateSensitivity;\n    }\n\n    function setDeleveragingCliff(uint256 _deleveragingCliff) external override onlyOwner {\n        deleveragingCliff = _deleveragingCliff;\n    }\n\n    function setLowestMaxLeverage(uint256 _lowestMaxLeverage) external override onlyOwner {\n        lowestMaxLeverage = _lowestMaxLeverage;\n    }\n\n    function setInsurancePoolSwitchStage(uint256 _insurancePoolSwitchStage) external override onlyOwner {\n        insurancePoolSwitchStage = _insurancePoolSwitchStage;\n    }\n\n    function transferOwnership(address newOwner) public override(Ownable, ITracerPerpetualSwaps) onlyOwner {\n        require(newOwner != address(0), \"address(0) given\");\n        super.transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice allows the owner of a market to set the whitelisting of a trading interface address\n     * @dev a permissioned interface may call the matchOrders function.\n     * @param tradingContract the contract to have its whitelisting permissions set\n     * @param whitelisted the permission of the contract. If true this contract make call makeOrder\n     */\n    function setWhitelist(address tradingContract, bool whitelisted) external onlyOwner {\n        tradingWhitelist[tradingContract] = whitelisted;\n    }\n\n    // Modifier such that only the set liquidation contract can call a function\n    modifier onlyLiquidation() {\n        require(msg.sender == liquidationContract, \"TCR: Sender not liquidation\");\n        _;\n    }\n\n    // Modifier such that only a whitelisted trader can call a function\n    modifier onlyWhitelisted() {\n        require(tradingWhitelist[msg.sender], \"TCR: Contract not whitelisted\");\n        _;\n    }\n}\ncontract GasOracle is IOracle, Ownable {\n    using LibMath for uint256;\n    IChainlinkOracle public gasOracle;\n    IChainlinkOracle public priceOracle;\n    uint8 public override decimals = 18;\n    uint256 private constant MAX_DECIMALS = 18;\n\n    constructor(address _priceOracle, address _gasOracle) {\n        gasOracle = IChainlinkOracle(_gasOracle); /* Gas cost oracle */\n        priceOracle = IChainlinkOracle(_priceOracle); /* Quote/ETH oracle */\n    }\n\n    /**\n     * @notice Calculates the latest USD/Gas price\n     * @dev Returned value is USD/Gas * 10^18 for compatibility with rest of calculations\n     */\n    function latestAnswer() external view override returns (uint256) {\n        uint256 gasPrice = uint256(gasOracle.latestAnswer());\n        uint256 ethPrice = uint256(priceOracle.latestAnswer());\n\n        uint256 result = PRBMathUD60x18.mul(gasPrice, ethPrice);\n        return result;\n    }\n\n    /**\n     * @notice converts a raw value to a WAD value.\n     * @dev this allows consistency for oracles used throughout the protocol\n     *      and allows oracles to have their decimals changed withou affecting\n     *      the market itself\n     */\n    function toWad(uint256 raw, IChainlinkOracle _oracle) internal view returns (uint256) {\n        IChainlinkOracle oracle = IChainlinkOracle(_oracle);\n        // reset the scaler for consistency\n        uint8 _decimals = oracle.decimals(); // 9\n        require(_decimals <= MAX_DECIMALS, \"GAS: too many decimals\");\n        uint256 scaler = uint256(10**(MAX_DECIMALS - _decimals));\n        return raw * scaler;\n    }\n\n    function setGasOracle(address _gasOracle) public onlyOwner {\n        require(_gasOracle != address(0), \"address(0) given\");\n        gasOracle = IChainlinkOracle(_gasOracle);\n    }\n\n    function setPriceOracle(address _priceOracle) public onlyOwner {\n        require(_priceOracle != address(0), \"address(0) given\");\n        priceOracle = IChainlinkOracle(_priceOracle);\n    }\n\n    function setDecimals(uint8 _decimals) external {\n        decimals = _decimals;\n    }\n}\ncontract InsurancePoolToken is ERC20, Ownable, ERC20Burnable {\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n    function mint(address to, uint256 amount) external onlyOwner() {\n        _mint(to, amount);\n    }\n\n    function burnFrom(address from, uint256 amount) public override onlyOwner() {\n        // override the burnFrom function and allow only the owner to burn\n        // pool tokens on behalf of a holder\n        _burn(from, amount);\n    }\n}\ncontract OracleAdapter is IOracle, Ownable {\n    using LibMath for uint256;\n    IChainlinkOracle public oracle;\n    uint256 private constant MAX_DECIMALS = 18;\n    uint256 public scaler;\n\n    constructor(address _oracle) {\n        setOracle(_oracle);\n    }\n\n    /**\n     * @notice Gets the latest anwser from the oracle\n     * @dev converts the price to a WAD price before returning\n     */\n    function latestAnswer() external view override returns (uint256) {\n        return toWad(uint256(oracle.latestAnswer()));\n    }\n\n    function decimals() external pure override returns (uint8) {\n        return uint8(MAX_DECIMALS);\n    }\n\n    /**\n     * @notice converts a raw value to a WAD value.\n     * @dev this allows consistency for oracles used throughout the protocol\n     *      and allows oracles to have their decimals changed withou affecting\n     *      the market itself\n     */\n    function toWad(uint256 raw) internal view returns (uint256) {\n        return raw * scaler;\n    }\n\n    /**\n     * @notice Change the upstream feed address.\n     */\n    function changeOracle(address newOracle) public onlyOwner {\n        setOracle(newOracle);\n    }\n\n    /**\n     * @notice sets the upstream oracle\n     * @dev resets the scalar value to ensure WAD values are always returned\n     */\n    function setOracle(address newOracle) internal {\n        oracle = IChainlinkOracle(newOracle);\n        // reset the scaler for consistency\n        uint8 _decimals = oracle.decimals();\n        require(_decimals <= MAX_DECIMALS, \"COA: too many decimals\");\n        scaler = uint256(10**(MAX_DECIMALS - _decimals));\n    }\n}\ncontract TracerPerpetualsFactory is Ownable, ITracerPerpetualsFactory {\n    uint256 public tracerCounter;\n    address public perpsDeployer;\n    address public liquidationDeployer;\n    address public insuranceDeployer;\n    address public pricingDeployer;\n\n    // Index of Tracer (where 0 is index of first Tracer market), corresponds to tracerCounter => market address\n    mapping(uint256 => address) public override tracersByIndex;\n    // Tracer market => whether that address is a valid Tracer or not\n    mapping(address => bool) public override validTracers;\n    // Tracer market => whether this address is a DAO approved market.\n    // note markets deployed by the DAO are by default approved\n    mapping(address => bool) public override daoApproved;\n\n    event TracerDeployed(bytes32 indexed marketId, address indexed market);\n\n    constructor(\n        address _perpsDeployer,\n        address _liquidationDeployer,\n        address _insuranceDeployer,\n        address _pricingDeployer,\n        address _governance\n    ) {\n        setPerpsDeployerContract(_perpsDeployer);\n        setLiquidationDeployerContract(_liquidationDeployer);\n        setInsuranceDeployerContract(_insuranceDeployer);\n        setPricingDeployerContract(_pricingDeployer);\n        transferOwnership(_governance);\n    }\n\n    /**\n     * @notice Allows any user to deploy a tracer market\n     * @param _data The data that will be used as constructor parameters for the new Tracer market.\n     */\n    function deployTracer(\n        bytes calldata _data,\n        address oracle,\n        address fastGasOracle,\n        uint256 maxLiquidationSlippage\n    ) external {\n        _deployTracer(_data, msg.sender, oracle, fastGasOracle, maxLiquidationSlippage);\n    }\n\n    /**\n     * @notice Allows the Tracer DAO to deploy a DAO approved Tracer market\n     * @param _data The data that will be used as constructor parameters for the new Tracer market.\n     */\n    function deployTracerAndApprove(\n        bytes calldata _data,\n        address oracle,\n        address fastGasOracle,\n        uint256 maxLiquidationSlippage\n    ) external onlyOwner() {\n        address tracer = _deployTracer(_data, owner(), oracle, fastGasOracle, maxLiquidationSlippage);\n        // DAO deployed markets are automatically approved\n        setApproved(address(tracer), true);\n    }\n\n    /**\n     * @notice internal function for the actual deployment of a Tracer market.\n     */\n    function _deployTracer(\n        bytes calldata _data,\n        address tracerOwner,\n        address oracle,\n        address fastGasOracle,\n        uint256 maxLiquidationSlippage\n    ) internal returns (address) {\n        // Create and link tracer to factory\n        address market = IPerpsDeployer(perpsDeployer).deploy(_data);\n        ITracerPerpetualSwaps tracer = ITracerPerpetualSwaps(market);\n\n        validTracers[market] = true;\n        tracersByIndex[tracerCounter] = market;\n        tracerCounter++;\n\n        // Instantiate Insurance contract for tracer\n        address insurance = IInsuranceDeployer(insuranceDeployer).deploy(market);\n        address pricing = IPricingDeployer(pricingDeployer).deploy(market, insurance, oracle);\n        address liquidation = ILiquidationDeployer(liquidationDeployer).deploy(\n            pricing,\n            market,\n            insurance,\n            fastGasOracle,\n            maxLiquidationSlippage\n        );\n\n        // Perform admin operations on the tracer to finalise linking\n        tracer.setInsuranceContract(insurance);\n        tracer.setPricingContract(pricing);\n        tracer.setLiquidationContract(liquidation);\n\n        // Ownership either to the deployer or the DAO\n        tracer.transferOwnership(tracerOwner);\n        ILiquidation(liquidation).transferOwnership(tracerOwner);\n        emit TracerDeployed(tracer.marketId(), address(tracer));\n        return market;\n    }\n\n    /**\n     * @notice Sets the perpsDeployer contract for tracers markets.\n     * @param newDeployer the new perpsDeployer contract address\n     */\n    function setPerpsDeployerContract(address newDeployer) public override onlyOwner() {\n        require(newDeployer != address(0), \"address(0) given\");\n        perpsDeployer = newDeployer;\n    }\n\n    function setInsuranceDeployerContract(address newInsuranceDeployer) public override onlyOwner() {\n        require(newInsuranceDeployer != address(0), \"address(0) given\");\n        insuranceDeployer = newInsuranceDeployer;\n    }\n\n    function setPricingDeployerContract(address newPricingDeployer) public override onlyOwner() {\n        require(newPricingDeployer != address(0), \"address(0) given\");\n        pricingDeployer = newPricingDeployer;\n    }\n\n    function setLiquidationDeployerContract(address newLiquidationDeployer) public override onlyOwner() {\n        require(newLiquidationDeployer != address(0), \"address(0) given\");\n        liquidationDeployer = newLiquidationDeployer;\n    }\n\n    /**\n     * @notice Sets a contracts approval by the DAO. This allows the factory to\n     *         identify contracts that the DAO has \"absorbed\" into its control\n     * @dev requires the contract to be owned by the DAO if being set to true.\n     */\n    function setApproved(address market, bool value) public override onlyOwner() {\n        if (value) {\n            require(Ownable(market).owner() == owner(), \"TFC: Owner not DAO\");\n        }\n        daoApproved[market] = value;\n    }\n}\n",
    "bin": []
}