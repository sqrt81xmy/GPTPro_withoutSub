{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/10/contracts",
    "external_functions": [
        [
            "IRageQuit"
        ],
        [
            "IHypervisor"
        ],
        [
            "Hypervisor",
            "IFactory",
            "IPowerSwitch",
            "IInstanceRegistry",
            "IERC20",
            "IRewardPool",
            "IUniversalVault"
        ],
        [
            "Visor",
            "IERC721",
            "IERC20",
            "IRageQuit"
        ]
    ],
    "new_contract": "contract Hypervisor is IHypervisor, Powered, Ownable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /* constants */\n\n    // An upper bound on the number of active stakes per vault is required to prevent\n    // calls to rageQuit() from reverting.\n    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower\n    // than the hardcoded limit of 500k gas on the vault.\n    // This limit is configurable and could be increased in a future deployment.\n    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide\n    // an error code that allows for reliably catching out-of-gas errors on remote calls.\n    uint256 public constant MAX_STAKES_PER_VAULT = 30;\n    uint256 public constant MAX_REWARD_TOKENS = 50;\n    uint256 public constant BASE_SHARES_PER_WEI = 1000000;\n    uint256 public stakeLimit = 2500 ether;\n\n    /* storage */\n\n    HypervisorData private _hypervisor;\n    mapping(address => VaultData) private _vaults;\n    EnumerableSet.AddressSet private _bonusTokenSet;\n    EnumerableSet.AddressSet private _vaultFactorySet;\n\n    /* initializer */\n\n    /// @notice Initizalize Hypervisor\n    /// access control: only proxy constructor\n    /// state machine: can only be called once\n    /// state scope: set initialization variables\n    /// token transfer: none\n    /// @param ownerAddress address The admin address\n    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool\n    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch\n    /// @param stakingToken address The address of the staking token for this Hypervisor\n    /// @param rewardToken address The address of the reward token for this Hypervisor\n    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time\n    constructor(\n        address ownerAddress,\n        address rewardPoolFactory,\n        address powerSwitchFactory,\n        address stakingToken,\n        address rewardToken,\n        RewardScaling memory rewardScaling,\n        uint256 _stakeLimit\n    ) {\n        // the scaling floor must be smaller than ceiling\n        require(rewardScaling.floor <= rewardScaling.ceiling, \"Hypervisor: floor above ceiling\");\n\n        // setting rewardScalingTime to 0 would cause divide by zero error\n        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling\n        require(rewardScaling.time != 0, \"Hypervisor: scaling time cannot be zero\");\n\n        // deploy power switch\n        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));\n\n        // deploy reward pool\n        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));\n\n        // set internal configs\n        Ownable.transferOwnership(ownerAddress);\n        Powered._setPowerSwitch(powerSwitch);\n\n        // commit to storage\n        _hypervisor.stakingToken = stakingToken;\n        _hypervisor.rewardToken = rewardToken;\n        _hypervisor.rewardPool = rewardPool;\n        _hypervisor.rewardScaling = rewardScaling;\n\n        stakeLimit = _stakeLimit;\n\n        // emit event\n        emit HypervisorCreated(rewardPool, powerSwitch);\n    }\n\n    /* getter functions */\n\n    function getBonusTokenSetLength() external view override returns (uint256 length) {\n        return _bonusTokenSet.length();\n    }\n\n    function getBonusTokenAtIndex(uint256 index)\n        external\n        view\n        override\n        returns (address bonusToken)\n    {\n        return _bonusTokenSet.at(index);\n    }\n\n    function getVaultFactorySetLength() external view override returns (uint256 length) {\n        return _vaultFactorySet.length();\n    }\n\n    function getVaultFactoryAtIndex(uint256 index)\n        external\n        view\n        override\n        returns (address factory)\n    {\n        return _vaultFactorySet.at(index);\n    }\n\n    function isValidVault(address target) public view override returns (bool validity) {\n        // validate target is created from whitelisted vault factory\n        for (uint256 index = 0; index < _vaultFactorySet.length(); index++) {\n            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {\n                return true;\n            }\n        }\n        // explicit return\n        return false;\n    }\n\n    function isValidAddress(address target) public view override returns (bool validity) {\n        // sanity check target for potential input errors\n        return\n            target != address(this) &&\n            target != address(0) &&\n            target != _hypervisor.stakingToken &&\n            target != _hypervisor.rewardToken &&\n            target != _hypervisor.rewardPool &&\n            !_bonusTokenSet.contains(target);\n    }\n\n    /* Hypervisor getters */\n\n    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {\n        return _hypervisor;\n    }\n\n    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {\n        // calculate reward available based on state\n        return getFutureUnlockedRewards(block.timestamp);\n    }\n\n    function getFutureUnlockedRewards(uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 unlockedRewards)\n    {\n        // get reward amount remaining\n        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n        // calculate reward available based on state\n        unlockedRewards = calculateUnlockedRewards(\n            _hypervisor.rewardSchedules,\n            remainingRewards,\n            _hypervisor.rewardSharesOutstanding,\n            timestamp\n        );\n        // explicit return\n        return unlockedRewards;\n    }\n\n    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {\n        // calculate new stake units\n        return getFutureTotalStakeUnits(block.timestamp);\n    }\n\n    function getFutureTotalStakeUnits(uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 totalStakeUnits)\n    {\n        // return early if no change\n        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;\n        // calculate new stake units\n        uint256 newStakeUnits =\n            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);\n        // add to cached total\n        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);\n        // explicit return\n        return totalStakeUnits;\n    }\n\n    /* vault getters */\n\n    function getVaultData(address vault)\n        external\n        view\n        override\n        returns (VaultData memory vaultData)\n    {\n        return _vaults[vault];\n    }\n\n    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                _vaults[vault]\n                    .totalStake,\n                getCurrentUnlockedRewards(),\n                getCurrentTotalStakeUnits(),\n                block\n                    .timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getFutureVaultReward(address vault, uint256 timestamp)\n        external\n        view\n        override\n        returns (uint256 reward)\n    {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                _vaults[vault]\n                    .totalStake,\n                getFutureUnlockedRewards(timestamp),\n                getFutureTotalStakeUnits(timestamp),\n                timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getCurrentStakeReward(address vault, uint256 stakeAmount)\n        external\n        view\n        override\n        returns (uint256 reward)\n    {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                stakeAmount,\n                getCurrentUnlockedRewards(),\n                getCurrentTotalStakeUnits(),\n                block\n                    .timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getFutureStakeReward(\n        address vault,\n        uint256 stakeAmount,\n        uint256 timestamp\n    ) external view override returns (uint256 reward) {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                stakeAmount,\n                getFutureUnlockedRewards(timestamp),\n                getFutureTotalStakeUnits(timestamp),\n                timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getCurrentVaultStakeUnits(address vault)\n        public\n        view\n        override\n        returns (uint256 stakeUnits)\n    {\n        // calculate stake units\n        return getFutureVaultStakeUnits(vault, block.timestamp);\n    }\n\n    function getFutureVaultStakeUnits(address vault, uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 stakeUnits)\n    {\n        // calculate stake units\n        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);\n    }\n\n    /* pure functions */\n\n    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)\n        public\n        pure\n        override\n        returns (uint256 totalStakeUnits)\n    {\n        for (uint256 index; index < stakes.length; index++) {\n            // reference stake\n            StakeData memory stakeData = stakes[index];\n            // calculate stake units\n            uint256 stakeUnits =\n                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);\n            // add to running total\n            totalStakeUnits = totalStakeUnits.add(stakeUnits);\n        }\n    }\n\n    function calculateStakeUnits(\n        uint256 amount,\n        uint256 start,\n        uint256 end\n    ) public pure override returns (uint256 stakeUnits) {\n        // calculate duration\n        uint256 duration = end.sub(start);\n        // calculate stake units\n        stakeUnits = duration.mul(amount);\n        // explicit return\n        return stakeUnits;\n    }\n\n    function calculateUnlockedRewards(\n        RewardSchedule[] memory rewardSchedules,\n        uint256 rewardBalance,\n        uint256 sharesOutstanding,\n        uint256 timestamp\n    ) public pure override returns (uint256 unlockedRewards) {\n        // return 0 if no registered schedules\n        if (rewardSchedules.length == 0) {\n            return 0;\n        }\n\n        // calculate reward shares locked across all reward schedules\n        uint256 sharesLocked;\n        for (uint256 index = 0; index < rewardSchedules.length; index++) {\n            // fetch reward schedule storage reference\n            RewardSchedule memory schedule = rewardSchedules[index];\n\n            // caculate amount of shares available on this schedule\n            // if (now - start) < duration\n            //   sharesLocked = shares - (shares * (now - start) / duration)\n            // else\n            //   sharesLocked = 0\n            uint256 currentSharesLocked = 0;\n            if (timestamp.sub(schedule.start) < schedule.duration) {\n                currentSharesLocked = schedule.shares.sub(\n                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)\n                );\n            }\n\n            // add to running total\n            sharesLocked = sharesLocked.add(currentSharesLocked);\n        }\n\n        // convert shares to reward\n        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding\n        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);\n\n        // calculate amount available\n        // unlockedRewards = rewardBalance - rewardLocked\n        unlockedRewards = rewardBalance.sub(rewardLocked);\n\n        // explicit return\n        return unlockedRewards;\n    }\n\n    function calculateRewardFromStakes(\n        StakeData[] memory stakes,\n        uint256 unstakeAmount,\n        uint256 unlockedRewards,\n        uint256 totalStakeUnits,\n        uint256 timestamp,\n        RewardScaling memory rewardScaling\n    ) public pure override returns (RewardOutput memory out) {\n        uint256 stakesToDrop = 0;\n        while (unstakeAmount > 0) {\n            // fetch vault stake storage reference\n            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];\n\n            // calculate stake duration\n            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);\n\n            uint256 currentAmount;\n            if (lastStake.amount > unstakeAmount) {\n                // set current amount to remaining unstake amount\n                currentAmount = unstakeAmount;\n                // amount of last stake is reduced\n                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);\n            } else {\n                // set current amount to amount of last stake\n                currentAmount = lastStake.amount;\n                // add to stakes to drop\n                stakesToDrop += 1;\n            }\n\n            // update remaining unstakeAmount\n            unstakeAmount = unstakeAmount.sub(currentAmount);\n\n            // calculate reward amount\n            uint256 currentReward =\n                calculateReward(\n                    unlockedRewards,\n                    currentAmount,\n                    stakeDuration,\n                    totalStakeUnits,\n                    rewardScaling\n                );\n\n            // update cumulative reward\n            out.reward = out.reward.add(currentReward);\n\n            // update cached unlockedRewards\n            unlockedRewards = unlockedRewards.sub(currentReward);\n\n            // calculate time weighted stake\n            uint256 stakeUnits = currentAmount.mul(stakeDuration);\n\n            // update cached totalStakeUnits\n            totalStakeUnits = totalStakeUnits.sub(stakeUnits);\n        }\n\n        // explicit return\n        return\n            RewardOutput(\n                out.lastStakeAmount,\n                stakes.length.sub(stakesToDrop),\n                out.reward,\n                totalStakeUnits\n            );\n    }\n\n    function calculateReward(\n        uint256 unlockedRewards,\n        uint256 stakeAmount,\n        uint256 stakeDuration,\n        uint256 totalStakeUnits,\n        RewardScaling memory rewardScaling\n    ) public pure override returns (uint256 reward) {\n        // calculate time weighted stake\n        uint256 stakeUnits = stakeAmount.mul(stakeDuration);\n\n        // calculate base reward\n        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits\n        uint256 baseReward = 0;\n        if (totalStakeUnits != 0) {\n            // scale reward according to proportional weight\n            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);\n        }\n\n        // calculate scaled reward\n        // if no scaling or scaling period completed\n        //   reward = baseReward\n        // else\n        //   minReward = baseReward * scalingFloor / scalingCeiling\n        //   bonusReward = baseReward\n        //                 * (scalingCeiling - scalingFloor) / scalingCeiling\n        //                 * duration / scalingTime\n        //   reward = minReward + bonusReward\n        if (stakeDuration >= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {\n            // no reward scaling applied\n            reward = baseReward;\n        } else {\n            // calculate minimum reward using scaling floor\n            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);\n\n            // calculate bonus reward with vested portion of scaling factor\n            uint256 bonusReward =\n                baseReward\n                    .mul(stakeDuration)\n                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))\n                    .div(rewardScaling.ceiling)\n                    .div(rewardScaling.time);\n\n            // add minimum reward and bonus reward\n            reward = minReward.add(bonusReward);\n        }\n\n        // explicit return\n        return reward;\n    }\n\n    /* admin functions */\n\n    /// @notice Add funds to the Hypervisor\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope:\n    ///   - increase _hypervisor.rewardSharesOutstanding\n    ///   - append to _hypervisor.rewardSchedules\n    /// token transfer: transfer staking tokens from msg.sender to reward pool\n    /// @param amount uint256 Amount of reward tokens to deposit\n    /// @param duration uint256 Duration over which to linearly unlock rewards\n    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {\n        // validate duration\n        require(duration != 0, \"Hypervisor: invalid duration\");\n\n        // create new reward shares\n        // if existing rewards on this Hypervisor\n        //   mint new shares proportional to % change in rewards remaining\n        //   newShares = remainingShares * newReward / remainingRewards\n        // else\n        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate\n        //   store as fixed point number with same  of decimals as reward token\n        uint256 newRewardShares;\n        if (_hypervisor.rewardSharesOutstanding > 0) {\n            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);\n        } else {\n            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);\n        }\n\n        // add reward shares to total\n        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);\n\n        // store new reward schedule\n        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));\n\n        // transfer reward tokens to reward pool\n        TransferHelper.safeTransferFrom(\n            _hypervisor.rewardToken,\n            msg.sender,\n            _hypervisor.rewardPool,\n            amount\n        );\n\n        // emit event\n        emit HypervisorFunded(amount, duration);\n    }\n\n    /// @notice Add vault factory to whitelist\n    /// @dev use this function to enable stakes to vaults coming from the specified\n    ///      factory contract\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - not shutdown\n    /// state scope:\n    ///   - append to _vaultFactorySet\n    /// token transfer: none\n    /// @param factory address The address of the vault factory\n    function registerVaultFactory(address factory) external onlyOwner notShutdown {\n        // add factory to set\n        require(_vaultFactorySet.add(factory), \"Hypervisor: vault factory already registered\");\n\n        // emit event\n        emit VaultFactoryRegistered(factory);\n    }\n\n    /// @notice Remove vault factory from whitelist\n    /// @dev use this function to disable new stakes to vaults coming from the specified\n    ///      factory contract.\n    ///      note: vaults with existing stakes from this factory are sill able to unstake\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - not shutdown\n    /// state scope:\n    ///   - remove from _vaultFactorySet\n    /// token transfer: none\n    /// @param factory address The address of the vault factory\n    function removeVaultFactory(address factory) external onlyOwner notShutdown {\n        // remove factory from set\n        require(_vaultFactorySet.remove(factory), \"Hypervisor: vault factory not registered\");\n\n        // emit event\n        emit VaultFactoryRemoved(factory);\n    }\n\n    /// @notice Register bonus token for distribution\n    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope:\n    ///   - append to _bonusTokenSet\n    /// token transfer: none\n    /// @param bonusToken address The address of the bonus token\n    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {\n        // verify valid bonus token\n        _validateAddress(bonusToken);\n\n        // verify bonus token count\n        require(_bonusTokenSet.length() < MAX_REWARD_TOKENS, \"Hypervisor: max bonus tokens reached \");\n\n        // add token to set\n        assert(_bonusTokenSet.add(bonusToken));\n\n        // emit event\n        emit BonusTokenRegistered(bonusToken);\n    }\n\n    /// @notice Rescue tokens from RewardPool\n    /// @dev use this function to rescue tokens from RewardPool contract\n    ///      without distributing to stakers or triggering emergency shutdown\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope: none\n    /// token transfer: transfer requested token from RewardPool to recipient\n    /// @param token address The address of the token to rescue\n    /// @param recipient address The address of the recipient\n    /// @param amount uint256 The amount of tokens to rescue\n    function rescueTokensFromRewardPool(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyOwner onlyOnline {\n        // verify recipient\n        _validateAddress(recipient);\n\n        // check not attempting to unstake reward token\n        require(token != _hypervisor.rewardToken, \"Hypervisor: invalid address\");\n\n        // check not attempting to wthdraw bonus token\n        require(!_bonusTokenSet.contains(token), \"Hypervisor: invalid address\");\n\n        // transfer tokens to recipient\n        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);\n    }\n\n    /* user functions */\n\n    /// @notice Stake tokens\n    /// @dev anyone can stake to any vault if they have valid permission\n    /// access control: anyone\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    ///   - when vault exists on this Hypervisor\n    /// state scope:\n    ///   - append to _vaults[vault].stakes\n    ///   - increase _vaults[vault].totalStake\n    ///   - increase _hypervisor.totalStake\n    ///   - increase _hypervisor.totalStakeUnits\n    ///   - increase _hypervisor.lastUpdate\n    /// token transfer: transfer staking tokens from msg.sender to vault\n    /// @param vault address The address of the vault to stake from\n    /// @param amount uint256 The amount of staking tokens to stake\n    function stake(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external override onlyOnline {\n        // verify vault is valid\n        require(isValidVault(vault), \"Hypervisor: vault is not registered\");\n\n        // verify non-zero amount\n        require(amount != 0, \"Hypervisor: no amount staked\");\n\n        // fetch vault storage reference\n        VaultData storage vaultData = _vaults[vault];\n\n        // verify stakes boundary not reached\n        require(\n            vaultData.stakes.length < MAX_STAKES_PER_VAULT,\n            \"Hypervisor: MAX_STAKES_PER_VAULT reached\"\n        );\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // store amount and timestamp\n        vaultData.stakes.push(StakeData(amount, block.timestamp));\n\n        // update cached total vault and Hypervisor amounts\n        vaultData.totalStake = vaultData.totalStake.add(amount);\n        // verify stake quantity without bounds\n        require(\n            stakeLimit == 0 || vaultData.totalStake <= stakeLimit,\n            \"Hypervisor: Stake limit exceeded\"\n        );\n        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);\n\n        // call lock on vault\n        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);\n\n        // emit event\n        emit Staked(vault, amount);\n    }\n\n    /// @notice Unstake staking tokens and claim reward\n    /// @dev rewards can only be claimed when unstaking\n    /// access control: only owner of vault\n    /// state machine:\n    ///   - when vault exists on this Hypervisor\n    ///   - after stake from vault\n    ///   - can be called multiple times while sufficient stake remains\n    ///   - only online\n    /// state scope:\n    ///   - decrease _hypervisor.rewardSharesOutstanding\n    ///   - decrease _hypervisor.totalStake\n    ///   - increase _hypervisor.lastUpdate\n    ///   - modify _hypervisor.totalStakeUnits\n    ///   - modify _vaults[vault].stakes\n    ///   - decrease _vaults[vault].totalStake\n    /// token transfer:\n    ///   - transfer reward tokens from reward pool to recipient\n    ///   - transfer bonus tokens from reward pool to recipient\n    /// @param vault address The vault to unstake from\n    /// @param amount uint256 The amount of staking tokens to unstake\n    function unstakeAndClaim(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external override onlyOnline {\n        // fetch vault storage reference\n        VaultData storage vaultData = _vaults[vault];\n\n        // verify non-zero amount\n        require(amount != 0, \"Hypervisor: no amount unstaked\");\n\n        address recipient = IUniversalVault(vault).owner();\n\n        // validate recipient\n        _validateAddress(recipient);\n\n        // check for sufficient vault stake amount\n        require(vaultData.totalStake >= amount, \"Hypervisor: insufficient vault stake\");\n\n        // check for sufficient Hypervisor stake amount\n        // if this check fails, there is a bug in stake accounting\n        assert(_hypervisor.totalStake >= amount);\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // get reward amount remaining\n        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n\n        // calculate vested portion of reward pool\n        uint256 unlockedRewards =\n            calculateUnlockedRewards(\n                _hypervisor.rewardSchedules,\n                remainingRewards,\n                _hypervisor.rewardSharesOutstanding,\n                block.timestamp\n            );\n\n        // calculate vault time weighted reward with scaling\n        RewardOutput memory out =\n            calculateRewardFromStakes(\n                vaultData.stakes,\n                amount,\n                unlockedRewards,\n                _hypervisor.totalStakeUnits,\n                block.timestamp,\n                _hypervisor.rewardScaling\n            );\n\n        // update stake data in storage\n        if (out.newStakesCount == 0) {\n            // all stakes have been unstaked\n            delete vaultData.stakes;\n        } else {\n            // some stakes have been completely or partially unstaked\n            // delete fully unstaked stakes\n            while (vaultData.stakes.length > out.newStakesCount) vaultData.stakes.pop();\n            // update partially unstaked stake\n            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;\n        }\n\n        // update cached stake totals\n        vaultData.totalStake = vaultData.totalStake.sub(amount);\n        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);\n        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;\n\n        // unlock staking tokens from vault\n        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);\n\n        // emit event\n        emit Unstaked(vault, amount);\n\n        // only perform on non-zero reward\n        if (out.reward > 0) {\n            // calculate shares to burn\n            // sharesToBurn = sharesOutstanding * reward / remainingRewards\n            uint256 sharesToBurn =\n                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);\n\n            // burn claimed shares\n            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);\n\n            // transfer bonus tokens from reward pool to recipient\n            if (_bonusTokenSet.length() > 0) {\n                for (uint256 index = 0; index < _bonusTokenSet.length(); index++) {\n                    // fetch bonus token address reference\n                    address bonusToken = _bonusTokenSet.at(index);\n\n                    // calculate bonus token amount\n                    // bonusAmount = bonusRemaining * reward / remainingRewards\n                    uint256 bonusAmount =\n                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(\n                            remainingRewards\n                        );\n\n                    // transfer bonus token\n                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);\n\n                    // emit event\n                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);\n                }\n            }\n\n            // transfer reward tokens from reward pool to recipient\n            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);\n\n            // emit event\n            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);\n        }\n    }\n\n    /// @notice Exit Hypervisor without claiming reward\n    /// @dev This function should never revert when correctly called by the vault.\n    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to\n    ///      place an upper bound on the for loop in calculateTotalStakeUnits().\n    /// access control: only callable by the vault directly\n    /// state machine:\n    ///   - when vault exists on this Hypervisor\n    ///   - when active stake from this vault\n    ///   - any power state\n    /// state scope:\n    ///   - decrease _hypervisor.totalStake\n    ///   - increase _hypervisor.lastUpdate\n    ///   - modify _hypervisor.totalStakeUnits\n    ///   - delete _vaults[vault]\n    /// token transfer: none\n    function rageQuit() external override {\n        // fetch vault storage reference\n        VaultData storage _vaultData = _vaults[msg.sender];\n\n        // revert if no active stakes\n        require(_vaultData.stakes.length != 0, \"Hypervisor: no stake\");\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // emit event\n        emit Unstaked(msg.sender, _vaultData.totalStake);\n\n        // update cached totals\n        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);\n        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(\n            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)\n        );\n\n        // delete stake data\n        delete _vaults[msg.sender];\n    }\n\n    /* convenience functions */\n\n    function _updateTotalStakeUnits() private {\n        // update cached totalStakeUnits\n        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();\n        // update cached lastUpdate\n        _hypervisor.lastUpdate = block.timestamp;\n    }\n\n    function _validateAddress(address target) private view {\n        // sanity check target for potential input errors\n        require(isValidAddress(target), \"Hypervisor: invalid address\");\n    }\n\n    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)\n        private\n        pure\n        returns (StakeData[] memory newArray)\n    {\n        newArray = new StakeData[](newLength);\n        for (uint256 index = 0; index < newLength; index++) {\n            newArray[index] = array[index];\n        }\n        return newArray;\n    }\n}\ncontract OwnableERC721 {\n    address private _nftAddress;\n\n    modifier onlyOwner() {\n        require(owner() == msg.sender, \"OwnableERC721: caller is not the owner\");\n        _;\n    }\n\n    function _setNFT(address nftAddress) internal {\n        _nftAddress = nftAddress;\n    }\n\n    function nft() public view virtual returns (address nftAddress) {\n        return _nftAddress;\n    }\n\n    function owner() public view virtual returns (address ownerAddress) {\n        return IERC721(_nftAddress).ownerOf(uint256(address(this)));\n    }\n}\ncontract Visor is\n    IUniversalVault,\n    EIP712(\"UniversalVault\", \"1.0.0\"),\n    ERC1271,\n    OwnableERC721,\n    Initializable,\n    IERC721Receiver\n{\n    using SafeMath for uint256;\n    using Address for address;\n    using Address for address payable;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /* constant */\n\n    // Hardcoding a gas limit for rageQuit() is required to prevent gas DOS attacks\n    // the gas requirement cannot be determined at runtime by querying the delegate\n    // as it could potentially be manipulated by a malicious delegate who could force\n    // the calls to revert.\n    // The gas limit could alternatively be set upon vault initialization or creation\n    // of a lock, but the gas consumption trade-offs are not favorable.\n    // Ultimately, to avoid a need for fixed gas limits, the EVM would need to provide\n    // an error code that allows for reliably catching out-of-gas errors on remote calls.\n    uint256 public constant RAGEQUIT_GAS = 500000;\n    bytes32 public constant LOCK_TYPEHASH =\n        keccak256(\"Lock(address delegate,address token,uint256 amount,uint256 nonce)\");\n    bytes32 public constant UNLOCK_TYPEHASH =\n        keccak256(\"Unlock(address delegate,address token,uint256 amount,uint256 nonce)\");\n\n    string public constant VERSION = \"VISOR-2.0.3\";\n\n    /* storage */\n\n    uint256 private _nonce;\n    mapping(bytes32 => LockData) private _locks;\n    EnumerableSet.Bytes32Set private _lockSet;\n    string public uri;\n\n    struct Nft {\n      uint256 tokenId; \n      address nftContract;\n    }\n\n    Nft[] public nfts;\n    mapping(bytes32=>bool) public nftApprovals;\n    mapping(bytes32=>uint256) public erc20Approvals;\n\n    struct TimelockERC20 {\n      address recipient;\n      address token;\n      uint256 amount;\n      uint256 expires;\n    }\n\n    mapping(bytes32=>TimelockERC20) public timelockERC20s; \n    mapping(address=>bytes32[]) public timelockERC20Keys;\n    mapping(address=>uint256) public timelockERC20Balances;\n\n    struct TimelockERC721 {\n      address recipient;\n      address nftContract;\n      uint256 tokenId;\n      uint256 expires;\n    }\n\n    mapping(bytes32=>TimelockERC721) public timelockERC721s; \n    mapping(address=>bytes32[]) public timelockERC721Keys;\n\n    event AddNftToken(address nftContract, uint256 tokenId);\n    event RemoveNftToken(address nftContract, uint256 tokenId);\n    event TimeLockERC20(address recipient, address token, uint256 amount, uint256 expires);\n    event TimeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires);\n    event TimeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);\n    event TimeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);\n\n    /* initialization function */\n\n    function initializeLock() external initializer {}\n\n    function initialize() external override initializer {\n      OwnableERC721._setNFT(msg.sender);\n    }\n\n    /* ether receive */\n\n    receive() external payable {}\n\n    /* internal  */\n\n    function _addNft(address nftContract, uint256 tokenId) internal {\n\n      nfts.push(\n        Nft({\n          tokenId: tokenId,\n          nftContract: nftContract\n        })\n      );\n      emit AddNftToken(nftContract, tokenId);\n    }\n\n    function _removeNft(address nftContract, uint256 tokenId) internal {\n      uint256 len = nfts.length;\n      for (uint256 i = 0; i < len; i++) {\n        Nft memory nftInfo = nfts[i];\n        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {\n          if(i != len - 1) {\n            nfts[i] = nfts[len - 1];\n          }\n          nfts.pop();\n          emit RemoveNftToken(nftContract, tokenId);\n          break;\n        }\n      }\n    }\n\n    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {\n        return OwnableERC721.owner();\n    }\n\n    /* pure functions */\n\n    function calculateLockID(address delegate, address token)\n        public\n        pure\n        override\n        returns (bytes32 lockID)\n    {\n        return keccak256(abi.encodePacked(delegate, token));\n    }\n\n    /* getter functions */\n\n    function getPermissionHash(\n        bytes32 eip712TypeHash,\n        address delegate,\n        address token,\n        uint256 amount,\n        uint256 nonce\n    ) public view override returns (bytes32 permissionHash) {\n        return\n            EIP712._hashTypedDataV4(\n                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))\n            );\n    }\n\n    function getNonce() external view override returns (uint256 nonce) {\n        return _nonce;\n    }\n\n    function owner()\n        public\n        view\n        override(IUniversalVault, OwnableERC721)\n        returns (address ownerAddress)\n    {\n        return OwnableERC721.owner();\n    }\n\n    function getLockSetCount() external view override returns (uint256 count) {\n        return _lockSet.length();\n    }\n\n    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {\n        return _locks[_lockSet.at(index)];\n    }\n\n    function getBalanceDelegated(address token, address delegate)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        return _locks[calculateLockID(delegate, token)].balance;\n    }\n\n    function getBalanceLocked(address token) public view override returns (uint256 balance) {\n        uint256 count = _lockSet.length();\n        for (uint256 index; index < count; index++) {\n            LockData storage _lockData = _locks[_lockSet.at(index)];\n            if (_lockData.token == token && _lockData.balance > balance)\n                balance = _lockData.balance;\n        }\n        return balance;\n    }\n\n    function checkBalances() external view override returns (bool validity) {\n        // iterate over all token locks and validate sufficient balance\n        uint256 count = _lockSet.length();\n        for (uint256 index; index < count; index++) {\n            // fetch storage lock reference\n            LockData storage _lockData = _locks[_lockSet.at(index)];\n            // if insufficient balance and no\u220ft shutdown, return false\n            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;\n        }\n        // if sufficient balance or shutdown, return true\n        return true;\n    }\n\n    // @notice Get ERC721 from nfts[] by index\n    /// @param i nfts index of nfts[] \n    function getNftById(uint256 i) external view returns (address nftContract, uint256 tokenId) {\n        require(i < nfts.length, \"ID overflow\");\n        Nft memory ni = nfts[i];\n        nftContract = ni.nftContract;\n        tokenId = ni.tokenId;\n    }\n\n    // @notice Get index of ERC721 in nfts[]\n    /// @param nftContract Address of ERC721 \n    /// @param tokenId tokenId for NFT in nftContract \n    function getNftIdByTokenIdAndAddr(address nftContract, uint256 tokenId) external view returns(uint256) {\n        uint256 len = nfts.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (nftContract == nfts[i].nftContract && tokenId == nfts[i].tokenId) {\n                return i;\n            }\n        }\n        require(false, \"Token not found\");\n    }\n\n    // @notice Get number of timelocks for given ERC20 token \n    function getTimeLockCount(address token) public view returns(uint256) {\n      return timelockERC20Keys[token].length;\n    }\n\n    // @notice Get number of timelocks for NFTs of a given ERC721 contract \n    function getTimeLockERC721Count(address nftContract) public view returns(uint256) {\n      return timelockERC721Keys[nftContract].length;\n    }\n\n    /* user functions */\n\n    /// @notice Lock ERC20 tokens in the vault\n    /// access control: called by delegate with signed permission from owner\n    /// state machine: anytime\n    /// state scope:\n    /// - insert or update _locks\n    /// - increase _nonce\n    /// token transfer: none\n    /// @param token Address of token being locked\n    /// @param amount Amount of tokens being locked\n    /// @param permission Permission signature payload\n    function lock(\n        address token,\n        uint256 amount,\n        bytes calldata permission\n    )\n        external\n        override\n        onlyValidSignature(\n            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),\n            permission\n        )\n    {\n        // get lock id\n        bytes32 lockID = calculateLockID(msg.sender, token);\n\n        // add lock to storage\n        if (_lockSet.contains(lockID)) {\n            // if lock already exists, increase amount\n            _locks[lockID].balance = _locks[lockID].balance.add(amount);\n        } else {\n            // if does not exist, create new lock\n            // add lock to set\n            assert(_lockSet.add(lockID));\n            // add lock data to storage\n            _locks[lockID] = LockData(msg.sender, token, amount);\n        }\n\n        // validate sufficient balance\n        require(\n            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,\n            \"UniversalVault: insufficient balance\"\n        );\n\n        // increase nonce\n        _nonce += 1;\n\n        // emit event\n        emit Locked(msg.sender, token, amount);\n    }\n\n    /// @notice Unlock ERC20 tokens in the vault\n    /// access control: called by delegate with signed permission from owner\n    /// state machine: after valid lock from delegate\n    /// state scope:\n    /// - remove or update _locks\n    /// - increase _nonce\n    /// token transfer: none\n    /// @param token Address of token being unlocked\n    /// @param amount Amount of tokens being unlocked\n    /// @param permission Permission signature payload\n    function unlock(\n        address token,\n        uint256 amount,\n        bytes calldata permission\n    )\n        external\n        override\n        onlyValidSignature(\n            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),\n            permission\n        )\n    {\n        // get lock id\n        bytes32 lockID = calculateLockID(msg.sender, token);\n\n        // validate existing lock\n        require(_lockSet.contains(lockID), \"UniversalVault: missing lock\");\n\n        // update lock data\n        if (_locks[lockID].balance > amount) {\n            // substract amount from lock balance\n            _locks[lockID].balance = _locks[lockID].balance.sub(amount);\n        } else {\n            // delete lock data\n            delete _locks[lockID];\n            assert(_lockSet.remove(lockID));\n        }\n\n        // increase nonce\n        _nonce += 1;\n\n        // emit event\n        emit Unlocked(msg.sender, token, amount);\n    }\n\n    /// @notice Forcibly cancel delegate lock\n    /// @dev This function will attempt to notify the delegate of the rage quit using\n    ///      a fixed amount of gas.\n    /// access control: only owner\n    /// state machine: after valid lock from delegate\n    /// state scope:\n    /// - remove item from _locks\n    /// token transfer: none\n    /// @param delegate Address of delegate\n    /// @param token Address of token being unlocked\n    function rageQuit(address delegate, address token)\n        external\n        override\n        onlyOwner\n        returns (bool notified, string memory error)\n    {\n        // get lock id\n        bytes32 lockID = calculateLockID(delegate, token);\n\n        // validate existing lock\n        require(_lockSet.contains(lockID), \"UniversalVault: missing lock\");\n\n        // attempt to notify delegate\n        if (delegate.isContract()) {\n            // check for sufficient gas\n            require(gasleft() >= RAGEQUIT_GAS, \"UniversalVault: insufficient gas\");\n\n            // attempt rageQuit notification\n            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {\n                notified = true;\n            } catch Error(string memory res) {\n                notified = false;\n                error = res;\n            } catch (bytes memory) {\n                notified = false;\n            }\n        }\n\n        // update lock storage\n        assert(_lockSet.remove(lockID));\n        delete _locks[lockID];\n\n        // emit event\n        emit RageQuit(delegate, token, notified, error);\n    }\n\n    function setURI(string memory _uri) public onlyOwner {\n      uri = _uri;\n    }\n\n    /// @notice Transfer ERC20 tokens out of vault\n    /// access control: only owner\n    /// state machine: when balance >= max(lock) + amount\n    /// state scope: none\n    /// token transfer: transfer any token\n    /// @param token Address of token being transferred\n    /// @param to Address of the to\n    /// @param amount Amount of tokens to transfer\n    function transferERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external override onlyOwner {\n        // check for sufficient balance\n        require(\n            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),\n            \"UniversalVault: insufficient balance\"\n        );\n        // perform transfer\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    // @notice Approve delegate account to transfer ERC20 tokens out of vault\n    /// @param token Address of token being transferred\n    /// @param delegate Address being approved\n    /// @param amount Amount of tokens approved to transfer\n    function approveTransferERC20(address token, address delegate, uint256 amount) external onlyOwner {\n      erc20Approvals[keccak256(abi.encodePacked(delegate, token))] = amount;\n    }\n\n    /// @notice Transfer ERC20 tokens out of vault with an approved account\n    /// access control: only approved accounts in erc20Approvals \n    /// state machine: when balance >= max(lock) + amount\n    /// state scope: none\n    /// token transfer: transfer any token\n    /// @param token Address of token being transferred\n    /// @param to Address of the to\n    /// @param amount Amount of tokens to transfer\n    function delegatedTransferERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external {\n        if(msg.sender != _getOwner()) {\n\n        require( \n            erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,\n            \"Account not approved to transfer amount\"); \n        } \n\n        // check for sufficient balance\n        require(\n            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),\n            \"UniversalVault: insufficient balance\"\n        );\n        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);\n        \n        // perform transfer\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    /// @notice Transfer ETH out of vault\n    /// access control: only owner\n    /// state machine: when balance >= amount\n    /// state scope: none\n    /// token transfer: transfer any token\n    /// @param to Address of the to\n    /// @param amount Amount of ETH to transfer\n    function transferETH(address to, uint256 amount) external payable override onlyOwner {\n      // perform transfer\n      TransferHelper.safeTransferETH(to, amount);\n    }\n\n    // @notice Approve delegate account to transfer ERC721 token out of vault\n    /// @param delegate Account address being approved to transfer nft  \n    /// @param nftContract address of nft minter \n    /// @param tokenId token id of the nft instance \n    function approveTransferERC721(\n      address delegate, \n      address nftContract, \n      uint256 tokenId\n    ) external onlyOwner {\n      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = true;\n    }\n\n    /// @notice Transfer ERC721 out of vault\n    /// access control: only owner or approved\n    /// ERC721 transfer: transfer any ERC721 token\n    /// @param to recipient address \n    /// @param nftContract address of nft minter \n    /// @param tokenId token id of the nft instance \n    function transferERC721(\n        address to,\n        address nftContract,\n        uint256 tokenId\n    ) external {\n        if(msg.sender != _getOwner()) {\n          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], \"NFT not approved for transfer\"); \n        } \n\n        for(uint256 i=0; i<timelockERC721Keys[nftContract].length; i++) {\n          if(tokenId == timelockERC721s[timelockERC721Keys[nftContract][i]].tokenId) {\n              require(\n                timelockERC721s[timelockERC721Keys[nftContract][i]].expires <= block.timestamp, \n                \"NFT locked and not expired\"\n              );\n              require( timelockERC721s[timelockERC721Keys[nftContract][i]].recipient == msg.sender, \"NFT locked and must be withdrawn by timelock recipient\");\n          }\n        }\n\n        _removeNft(nftContract, tokenId);\n        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);\n    }\n\n    // @notice Adjust nfts[] on ERC721 token recieved \n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata) external override returns (bytes4) {\n      _addNft(msg.sender, tokenId);\n      return IERC721Receiver.onERC721Received.selector;\n    }\n\n    // @notice Lock ERC721 in vault until expires, redeemable by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param nftContract address of nft minter \n    /// @param tokenId Token id of the nft instance \n    /// @param expires Timestamp when recipient is allowed to withdraw \n    function timeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public onlyOwner {\n\n      require(\n        expires > block.timestamp, \n        \"Expires must be in future\"\n      );\n \n      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); \n\n      require(\n        timelockERC721s[key].expires == 0,\n        \"TimelockERC721 already exists\"\n      );\n     \n      timelockERC721s[key] = TimelockERC721({\n          recipient: recipient,\n          nftContract: nftContract,\n          tokenId: tokenId,\n          expires: expires\n      });\n\n      timelockERC721Keys[nftContract].push(key);\n\n      IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);\n      emit TimeLockERC20(recipient, nftContract, tokenId, expires);\n    }\n\n    // @notice Withdraw ERC721 in vault post expires by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param nftContract address of nft minter \n    /// @param tokenId Token id of the nft instance \n    /// @param expires Timestamp when recipient is allowed to withdraw\n    function timeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public {\n\n      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); \n      require(\n        timelockERC721s[key].expires <= block.timestamp,\n        \"Not expired yet\"\n      );\n\n      require(msg.sender == timelockERC721s[key].recipient, \"Not recipient\");\n\n      _removeNft(nftContract, tokenId);\n      delete timelockERC721s[key];\n\n      IERC721(nftContract).safeTransferFrom(address(this), recipient, tokenId);\n      emit TimeUnlockERC721(recipient, nftContract, tokenId, expires);\n    }\n\n    // @notice Lock ERC720 amount in vault until expires, redeemable by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param token Address of token to lock \n    /// @param amount Amount of token to lock \n    /// @param expires Timestamp when recipient is allowed to withdraw\n    function timeLockERC20(address recipient, address token, uint256 amount, uint256 expires) public onlyOwner {\n\n      require(\n        IERC20(token).allowance(msg.sender, address(this)) >= amount, \n        \"Amount not approved\"\n      );\n\n      require(\n        expires > block.timestamp, \n        \"Expires must be in future\"\n      );\n\n      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); \n\n      require(\n        timelockERC20s[key].expires == 0,\n        \"TimelockERC20 already exists\"\n      );\n    \n      timelockERC20s[key] = TimelockERC20({\n          recipient: recipient,\n          token: token,\n          amount: amount,\n          expires: expires\n      });\n      timelockERC20Keys[token].push(key);\n      timelockERC20Balances[token] = timelockERC20Balances[token].add(amount);\n      IERC20(token).transferFrom(msg.sender, address(this), amount);\n      emit TimeLockERC20(recipient, token, amount, expires);\n    }\n\n    // @notice Withdraw ERC20 from vault post expires by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param token Address of token to lock \n    /// @param amount Amount of token to lock \n    /// @param expires Timestamp when recipient is allowed to withdraw\n    function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {\n\n      require(\n        IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),\n        \"Insufficient balance\"\n      );\n\n      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); \n      require(\n        timelockERC20s[key].expires <= block.timestamp,\n        \"Not expired yet\"\n      );\n\n      require(msg.sender == timelockERC20s[key].recipient, \"Not recipient\");\n      \n      delete timelockERC20s[key];\n\n      timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);\n      TransferHelper.safeTransfer(token, recipient, amount);\n      emit TimeUnlockERC20(recipient, token, amount, expires);\n    }\n\n}\nabstract contract ERC1271 is IERC1271 {\n    // Valid magic value bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n    bytes4 internal constant VALID_SIG = IERC1271.isValidSignature.selector;\n    // Invalid magic value\n    bytes4 internal constant INVALID_SIG = bytes4(0);\n\n    modifier onlyValidSignature(bytes32 permissionHash, bytes memory signature) {\n        require(\n            isValidSignature(permissionHash, signature) == VALID_SIG,\n            \"ERC1271: Invalid signature\"\n        );\n        _;\n    }\n\n    function _getOwner() internal view virtual returns (address owner);\n\n    function isValidSignature(bytes32 permissionHash, bytes memory signature)\n        public\n        view\n        override\n        returns (bytes4)\n    {\n        return\n            SignatureChecker.isValidSignature(_getOwner(), permissionHash, signature)\n                ? VALID_SIG\n                : INVALID_SIG;\n    }\n}\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n\n    constructor(string memory name, string memory version) {\n        _HASHED_NAME = keccak256(bytes(name));\n        _HASHED_VERSION = keccak256(bytes(version));\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 name,\n        bytes32 version\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, name, version, _getChainId(), address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", _domainSeparatorV4(), structHash));\n    }\n\n    function _getChainId() private view returns (uint256 chainId) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal view virtual returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal view virtual returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n}\ncontract Powered is IPowered {\n    /* storage */\n\n    address private _powerSwitch;\n\n    /* modifiers */\n\n    modifier onlyOnline() {\n        _onlyOnline();\n        _;\n    }\n\n    modifier onlyOffline() {\n        _onlyOffline();\n        _;\n    }\n\n    modifier notShutdown() {\n        _notShutdown();\n        _;\n    }\n\n    modifier onlyShutdown() {\n        _onlyShutdown();\n        _;\n    }\n\n    /* initializer */\n\n    function _setPowerSwitch(address powerSwitch) internal {\n        _powerSwitch = powerSwitch;\n    }\n\n    /* getter functions */\n\n    function isOnline() public view override returns (bool status) {\n        return IPowerSwitch(_powerSwitch).isOnline();\n    }\n\n    function isOffline() public view override returns (bool status) {\n        return IPowerSwitch(_powerSwitch).isOffline();\n    }\n\n    function isShutdown() public view override returns (bool status) {\n        return IPowerSwitch(_powerSwitch).isShutdown();\n    }\n\n    function getPowerSwitch() public view override returns (address powerSwitch) {\n        return _powerSwitch;\n    }\n\n    function getPowerController() public view override returns (address controller) {\n        return IPowerSwitch(_powerSwitch).getPowerController();\n    }\n\n    /* convenience functions */\n\n    function _onlyOnline() private view {\n        require(isOnline(), \"Powered: is not online\");\n    }\n\n    function _onlyOffline() private view {\n        require(isOffline(), \"Powered: is not offline\");\n    }\n\n    function _notShutdown() private view {\n        require(!isShutdown(), \"Powered: is shutdown\");\n    }\n\n    function _onlyShutdown() private view {\n        require(isShutdown(), \"Powered: is not shutdown\");\n    }\n}\n",
    "bin": []
}