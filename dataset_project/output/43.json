{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/43",
    "external_functions": [
        [
            "DelegatedStaking"
        ]
    ],
    "new_contract": "contract DelegatedStaking is OwnableUpgradeable{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    uint256 constant divider = 10**18; // 18 decimals used for scaling the rates\n    uint128 validatorCoolDown; // how many epochs until validator unstaking is unlocked\n    uint128 delegatorCoolDown; // how many epochs until delegator unstaking is unlocked\n    uint128 maxCapMultiplier;\n    uint128 validatorMinStakedRequired; // minimum # of tokens validator is required to have staked\n    uint128 allocatedTokensPerEpoch; // # of tokens per epoch to be distributed\n    uint128 rewardsLocked; // # of tokens the owner sent to the contract\n    uint128 endEpoch; // the epoch when the contract will be out of allocated reward tokens\n    uint128 totalGlobalShares; // global shares\n    uint128 lastUpdateEpoch; // block # when the global exchange rate was updated last\n    uint128 globalExchangeRate;\n    uint128 validatorsN; // number of validators, used to get validator ids\n    mapping(uint128 => Validator) validators; // id -> validator instance\n    IERC20Upgradeable constant CQT = IERC20Upgradeable(0xD417144312DbF50465b1C641d016962017Ef6240);\n\n    struct Staking {\n        uint128 staked; // initial CQT amount staked\n        uint128 shares; // # of validator shares that delegate owns\n    }\n    struct Unstaking {\n        uint128 coolDownEnd; // epoch when unstaking can be redeemed\n        uint128 amount;\n    }\n    struct Validator {\n        address _address;\n        address operator;\n        uint128 commissionRate; // validator commission rate\n        uint128 disabledEpoch; // epoch when validator got disabled, if set to 0, validator is enabled\n        uint128 globalShares; // total number of global shares under a validator\n        uint128 lastUpdateGlobalRate; // global exchange rate when the validator was updated the last time\n        uint128 totalShares; // total number of validator shares\n        uint128 delegated; // total number of tokens originally staked/delegated to the validator, this does not include interest\n        uint128 exchangeRate; // validator exchange rate\n        uint128 commissionAvailableToRedeem; // # of CQTs paid to the validator\n        mapping(address => Staking) stakings;\n        mapping(address => Unstaking[]) unstakings;\n    }\n    event RewardTokensDeposited(uint128 amount);\n    event ValidatorAdded(uint128 indexed id, address indexed validator, address indexed operator);\n    event ValidatorDisabled(uint128 indexed id);\n    event Staked(uint128 indexed validatorId, address delegator, uint128 amount);\n    event Unstaked(uint128 indexed validatorId, address indexed delegator, uint128 amount);\n    event RecoveredUnstake(uint128 indexed validatorId, address indexed delegator, uint128 amount, uint128 unstakingId);\n    event UnstakeRedeemed(uint128 indexed validatorId, address indexed delegator, uint128 amount);\n    event RewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);\n    event CommissionRewardRedeemed(uint128 indexed validatorId, address indexed beneficiary, uint128 amount);\n    event AllocatedTokensTaken(uint128 amount);\n    event MaxCapMultiplierChanged(uint128 amount);\n    event TransferredUnstake(uint128 indexed oldValidatorId, uint128 indexed newValidatorId, address indexed delegator, uint128 amount, uint128 unstakingId);\n    event EmissionRateChanged(uint128 newRate);\n    event ValidatorCommissionRateChanged(uint128 indexed validatorId, uint128 newRate);\n    event ValidatorMinStakedRequiredChanged(uint128 amount);\n    event Initialized(uint128 minStakedRequired, uint128 validatorCoolDown, uint128 delegatorCoolDown, uint128 maxCapMultiplier, uint128 allocatedTokensPerEpoch, uint128 globalExchangeRate);\n\n    // this is used to have the contract upgradeable\n    function initialize(uint128 minStakedRequired) public initializer {\n        __Ownable_init();\n        validatorMinStakedRequired = minStakedRequired;\n        validatorCoolDown = 180*6646; // ~ 6 months\n        delegatorCoolDown = 28*6646; // ~ 28 days\n        maxCapMultiplier = 10;\n        allocatedTokensPerEpoch = 1*10**18; // should never be 0\n        globalExchangeRate = 10**18; // 1 to 1\n        emit Initialized(minStakedRequired, validatorCoolDown, delegatorCoolDown, maxCapMultiplier, allocatedTokensPerEpoch, globalExchangeRate);\n    }\n\n    // used to transfer CQT from delegators, validators and the owner to the contract\n    function _transferToContract(address from, uint128 amount) internal {\n        CQT.safeTransferFrom(from, address(this), amount);\n    }\n\n    // used to transfer CQT from contract, for rewards redemption or transferring out unstaked\n    function _transferFromContract(address to, uint128 amount) internal {\n        CQT.safeTransfer(to, amount);\n    }\n\n    // transfer CQT from the owner to the contract for rewards allocation, must change end epoch\n    function depositRewardTokens(uint128 amount) public onlyOwner {\n        require(amount >= allocatedTokensPerEpoch, \"Does not cover least 1 epoch\");\n        require(amount % allocatedTokensPerEpoch == 0, \"Not multiple\");\n        if (endEpoch != 0) {\n            unchecked { endEpoch += amount / allocatedTokensPerEpoch; }\n        }\n        else{\n            unchecked { rewardsLocked += amount; }\n        }\n        _transferToContract(msg.sender, amount);\n        emit RewardTokensDeposited(amount);\n    }\n\n    // transfer reward CQT from the contract to the owner, must change end epoch and not allow transfer from the past\n    function takeOutRewardTokens(uint128 amount) public onlyOwner {\n        require(amount > 0, \"Amount is 0\");\n        require(amount % allocatedTokensPerEpoch == 0, \"Not multiple\");\n        if (endEpoch != 0){\n            uint128 currentEpoch = uint128(block.number);\n            uint128 epochs = amount / allocatedTokensPerEpoch;\n            require(endEpoch - epochs > currentEpoch, \"Cannot takeout rewards from past\");\n            unchecked { endEpoch = endEpoch - epochs; }\n        }\n        else{\n            require(rewardsLocked >= amount, \"Amount is greater than available\");\n            unchecked { rewardsLocked -= amount; }\n        }\n        _transferFromContract(msg.sender, amount);\n        emit AllocatedTokensTaken(amount);\n    }\n\n    // update global exchange rate\n    function _updateGlobalExchangeRate() internal {\n        uint128 currentBlock = uint128(block.number);\n        // if the program ended, set update epoch to the end epoch\n        uint128 currentEpoch = currentBlock < endEpoch? currentBlock : endEpoch;\n        if (currentEpoch != lastUpdateEpoch){\n            // when no one has staked anything, do not update the rate\n            if(totalGlobalShares > 0)\n            {\n                unchecked { globalExchangeRate += uint128(uint256(allocatedTokensPerEpoch) * divider * uint256(currentEpoch - lastUpdateEpoch)/uint256(totalGlobalShares)) ; }\n            }\n            lastUpdateEpoch = currentEpoch;\n        }\n    }\n\n    // update validator exchange rate\n    function _updateValidator(Validator storage v) internal {\n        // if validator is disabled, we do not update it since it was updated during disabling transaction\n        if(v.disabledEpoch == 0){\n            if (v.totalShares == 0){\n                // when validator stakes the first time, the exchange rate must be equal to the current global exchange rate\n                v.exchangeRate = globalExchangeRate;\n            }\n            else {\n                // the growth of global exchange rate since the validator was updated the last time\n                uint128 rateDifference;\n                unchecked { rateDifference = globalExchangeRate - v.lastUpdateGlobalRate; }\n                // tokens given to the validator and its delegators since last update\n                uint128 tokensGivenToValidator = _sharesToTokens(v.globalShares, rateDifference);\n                // commission paid out of the tokens\n                uint128 commissionPaid = uint128(uint256(tokensGivenToValidator) * uint256(v.commissionRate) /  divider);\n                // increase validator exchange rate by distributing the leftover tokens through the validator shares\n                v.exchangeRate += uint128(uint256(tokensGivenToValidator - commissionPaid) * divider / v.totalShares);\n                // give commission tokens to the validator\n                unchecked { v.commissionAvailableToRedeem += commissionPaid; }\n            }\n            // set the last update global rate to the current one\n            v.lastUpdateGlobalRate = globalExchangeRate;\n        }\n    }\n    // used to convert global shares or validator shares to CQT\n    function _sharesToTokens(uint128 sharesN, uint128 rate) internal view returns(uint128){\n        return uint128(uint256(sharesN) * uint256(rate) / divider);\n    }\n    // used to convert CQT to global shares or validator shares\n    function _tokensToShares(uint128 amount, uint128 rate) internal view returns(uint128){\n        return uint128(uint256(amount) * divider / uint256(rate));\n    }\n\n    function stake(uint128 validatorId, uint128 amount) public {\n        _stake(validatorId, amount, true);\n    }\n    // need to update global exchange rate, validator data and then delegator instance\n    // withTransfer set to false when delegators recover unstake, because the tokens are already in the contract\n    function _stake(uint128 validatorId, uint128 amount, bool withTransfer) internal {\n        require(amount >= divider, \"Amount must be at least 1 token\");\n        require(validatorId < validatorsN, \"Invalid validator\");\n        Validator storage v = validators[validatorId];\n        require(v.disabledEpoch == 0, \"Validator is disabled\");\n        // if this is the first stake, then set the end epoch\n        if (endEpoch == 0){\n            unchecked { endEpoch = uint128(block.number) + rewardsLocked / allocatedTokensPerEpoch; }\n            rewardsLocked = 0; // no longer used and saves a bit of gas\n        }\n        require(endEpoch > block.number, \"Program ended\");\n        _updateGlobalExchangeRate();\n        _updateValidator(v);\n        // if staker is validator who self delegates\n        if (msg.sender == v._address){\n            require(amount + v.stakings[msg.sender].staked >= validatorMinStakedRequired, \"Amount < min staked required\");\n        }\n        else {\n            // otherwise need to check for max cap\n            uint128 validatorStaked = v.stakings[v._address].staked;\n            uint128 validatorMaxCap = validatorStaked * maxCapMultiplier;\n            uint128 newDelegated = v.delegated - validatorStaked + amount;\n            require(newDelegated <= validatorMaxCap, \"Validator max capacity exceeded\");\n        }\n        // it is set to true when there is a stake\n        // it is set to false when we recover delegation from unstaking\n        if (withTransfer)\n            _transferToContract(msg.sender, amount);\n        Staking storage s = v.stakings[msg.sender];\n\n        // update global shares #\n        uint128 globalSharesToAdd = _tokensToShares(amount, globalExchangeRate);\n        unchecked { totalGlobalShares += globalSharesToAdd; }\n        unchecked { v.globalShares += globalSharesToAdd; }\n\n        // update validator shares #\n        uint128 newDelegatorSharesN = _tokensToShares(amount, v.exchangeRate);\n        unchecked { v.totalShares += newDelegatorSharesN; }\n        unchecked { s.shares += newDelegatorSharesN; }\n        unchecked { v.delegated += amount; }\n        unchecked { s.staked += amount; }\n        emit Staked(validatorId, msg.sender, amount);\n    }\n\n    // need to update global exchange rate, validator data and then delegator instance\n    function unstake(uint128 validatorId, uint128 amount) public {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        Validator storage v = validators[validatorId];\n        Staking storage s = v.stakings[msg.sender];\n        require(s.staked >= amount, \"Staked < amount provided\");\n        bool isValidator = msg.sender == v._address;\n        _updateGlobalExchangeRate();\n        _updateValidator(v);\n        // only update if the validator is enabled, otherwise the global shares were already excluded during disableValidator call and the rest does not matter anymore\n        uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);\n        require(validatorSharesRemove > 0, \"Unstake amount is too small\");\n        if (v.disabledEpoch == 0){\n            // if validator is enabled and the program has not ended -> check for unstaking beyond max cap or min stake required\n            if (isValidator && endEpoch > block.number){\n                uint128 newValidatorStaked = s.staked - amount;\n                uint128 newValidatorMaxCap = newValidatorStaked * maxCapMultiplier;\n                uint128 delegated = v.delegated - s.staked;\n                require(delegated <= newValidatorMaxCap, \"Cannot unstake beyond max cap\");\n                require(newValidatorStaked >= validatorMinStakedRequired, \"Unstake > min staked required\");\n            }\n\n            // update global shares #\n            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);\n            require(globalSharesRemove > 0, \"Unstake amount is too small\");\n            unchecked { totalGlobalShares -= globalSharesRemove;}\n            unchecked { v.globalShares -= globalSharesRemove; }\n\n            // update validator shares #\n            unchecked { v.totalShares -= validatorSharesRemove; }\n            unchecked { v.delegated -= amount; }\n        }\n        unchecked { s.shares -= validatorSharesRemove; }\n        unchecked { s.staked -= amount; }\n\n        // create unstaking instance\n        uint128 coolDownEnd = v.disabledEpoch != 0 ? v.disabledEpoch : uint128(block.number);\n        unchecked { coolDownEnd += (isValidator ? validatorCoolDown : delegatorCoolDown); }\n        v.unstakings[msg.sender].push(Unstaking( coolDownEnd, amount));\n        emit Unstaked(validatorId, msg.sender, amount);\n    }\n\n    // restake unstaked tokens\n    function recoverUnstaking(uint128 amount, uint128 validatorId, uint128 unstakingId) public{\n        Unstaking storage us = validators[validatorId].unstakings[msg.sender][unstakingId];\n        require(us.amount >= amount, \"Unstaking has less tokens\");\n        _stake(validatorId, amount, false);\n        us.amount -= amount;\n        // set cool down end to 0 to release gas if new unstaking amount is 0\n        if(us.amount == 0)\n            us.coolDownEnd = 0;\n        emit RecoveredUnstake(validatorId, msg.sender, amount, unstakingId);\n    }\n\n    // if amount is 0 then redeem all\n    function _redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) internal {\n        require(beneficiary!=address(0x0), \"Invalid beneficiary\");\n        _updateGlobalExchangeRate();\n        Validator storage v = validators[validatorId];\n        _updateValidator(v);\n        Staking storage s = v.stakings[msg.sender];\n\n        uint128 rewards = _sharesToTokens(s.shares, v.exchangeRate) - s.staked;\n        if(msg.sender == v._address){\n            if(amount == 0){\n                unchecked { amount = rewards + v.commissionAvailableToRedeem; }\n            }\n            require(rewards + v.commissionAvailableToRedeem >= amount, \"Redeem amount > available\");\n            // first redeem rewards from commission\n            uint128 commissionLeftOver = amount < v.commissionAvailableToRedeem ? v.commissionAvailableToRedeem - amount : 0;\n            // if there is more, redeem  it from regular rewards\n            if (commissionLeftOver == 0){\n                uint128 validatorSharesRemove = _tokensToShares(amount - v.commissionAvailableToRedeem, v.exchangeRate);\n                unchecked { s.shares -= validatorSharesRemove; }\n                unchecked { v.totalShares -= validatorSharesRemove; }\n            }\n            emit CommissionRewardRedeemed(validatorId, beneficiary, v.commissionAvailableToRedeem - commissionLeftOver);\n            v.commissionAvailableToRedeem = commissionLeftOver;\n        }\n        else {\n            if(amount == 0){\n                amount = rewards;\n            }\n            require(rewards >= amount, \"Redeem amount > available\");\n            uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);\n            unchecked { s.shares -= validatorSharesRemove; }\n            unchecked { v.totalShares -= validatorSharesRemove; }\n        }\n        _transferFromContract(beneficiary, amount);\n\n        // update global shares #\n        // this includes commission and rewards earned\n        // only update if the validator is enabled, otherwise the shares were already excluded during disableValidator call\n        if (v.disabledEpoch == 0){\n            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);\n            unchecked { totalGlobalShares -= globalSharesRemove; }\n            unchecked { v.globalShares -= globalSharesRemove; }\n        }\n        emit RewardRedeemed(validatorId, beneficiary, amount);\n    }\n\n    // redeem all available rewards\n    function redeemAllRewards( uint128 validatorId, address beneficiary) external {\n        _redeemRewards(validatorId, beneficiary, 0);\n    }\n\n    // if validator calls redeem rewards, first tokens paid from comissions will be redeemed and then regular rewards\n    function redeemRewards( uint128 validatorId, address beneficiary, uint128 amount) external {\n        require(amount > 0, \"Amount is 0\");\n        _redeemRewards(validatorId, beneficiary, amount);\n    }\n\n    // add new validator instance\n    function addValidator(address validator, address operator, uint128 commissionRate) public onlyOwner {\n        require(commissionRate < divider, \"Rate must be less than 100%\");\n        uint128 N = validatorsN;\n        validators[N]._address = validator;\n        validators[N].operator = operator;\n        validators[N].commissionRate = commissionRate;\n        emit ValidatorAdded(N, validator, operator);\n        unchecked { validatorsN += 1; }\n    }\n\n    // can only be called by the owner or the validator, disabling will allow validator to fully unstake\n    // validator instance can only be disabled once and can never be reenabled\n    function disableValidator(uint128 validatorId) public {\n        Validator storage v = validators[validatorId];\n        require(v.disabledEpoch == 0, \"Validator is already disabled\");\n        require(v._address == msg.sender || msg.sender == owner(), \"Caller is not owner or validator\");\n        _updateGlobalExchangeRate();\n        _updateValidator(v);\n        v.disabledEpoch = uint128(block.number) < endEpoch? uint128(block.number) : endEpoch;\n        unchecked { totalGlobalShares -= v.globalShares; }\n        emit ValidatorDisabled(validatorId);\n    }\n\n    // change emission rate, should reset end epoch\n    function setAllocatedTokensPerEpoch(uint128 amount) public onlyOwner {\n        require(amount > 0, \"Amount is 0\");\n        uint128 toTransfer;\n        if (endEpoch != 0){\n            _updateGlobalExchangeRate();\n            // get number of epochs from now to the end epoch\n            uint128 epochs = endEpoch > uint128(block.number) ? endEpoch - uint128(block.number) : 0;\n            // calculate how much rewards would be distributed with the old emission rate\n            uint128 futureRewards = allocatedTokensPerEpoch * epochs;\n            // calculate how many epochs will be covered\n            uint128 addEpochs = futureRewards / amount;\n            toTransfer = futureRewards % amount;\n            require(addEpochs != 0, \"This amount will end the program\");\n            unchecked { endEpoch = uint128(block.number) + addEpochs; }\n        }\n        else {\n          toTransfer = rewardsLocked % amount;\n        }\n        allocatedTokensPerEpoch = amount;\n        emit EmissionRateChanged(amount);\n        if(toTransfer > 0)\n            _transferFromContract(msg.sender, toTransfer);\n\n    }\n\n    // we assume that we will never set it to less than what is staked already\n    function setMaxCapMultiplier(uint128 amount) public onlyOwner {\n        require(amount > 0, \"Must be greater than 0\");\n        maxCapMultiplier = amount;\n        emit MaxCapMultiplierChanged(amount);\n    }\n\n    // only owner can change commission rate\n    function setValidatorCommissionRate(uint128 amount, uint128 validatorId) public onlyOwner {\n        require(amount < divider, \"Rate must be less than 100%\");\n        _updateGlobalExchangeRate();\n        _updateValidator(validators[validatorId]);\n        validators[validatorId].commissionRate = amount;\n        emit ValidatorCommissionRateChanged(validatorId, amount);\n    }\n\n    // we are assuming there will never be a case when the owner sets the value to something extremely big and if that happens accidentally, we will just recall the function\n    function setValidatorMinStakedRequired(uint128 amount) public onlyOwner {\n        validatorMinStakedRequired = amount;\n        emit ValidatorMinStakedRequiredChanged(amount);\n    }\n\n    // if a validator gets disabled, delegators can redelegate their tokens to another validator\n    // first they need to unstake\n    function redelegateUnstaked(uint128 amount, uint128 oldValidatorId, uint128 newValidatorId, uint128 unstakingId) public {\n        require(validators[oldValidatorId].disabledEpoch != 0, \"Validator is not disabled\");\n        require(validators[oldValidatorId]._address != msg.sender, \"Validator cannot redelegate\");\n        Unstaking storage us = validators[oldValidatorId].unstakings[msg.sender][unstakingId];\n        require(us.amount >= amount, \"Unstaking has less tokens\");\n        _stake(newValidatorId, amount, false);\n        unchecked { us.amount -= amount; }\n        // set cool down end to 0 to release gas if new unstaking amount is 0\n        if(us.amount == 0)\n            us.coolDownEnd = 0;\n        emit TransferredUnstake(oldValidatorId, newValidatorId, msg.sender, amount, unstakingId);\n    }\n\n    // transfer out unlocked unstaked tokens back to the delegator\n    function transferUnstakedOut(uint128 amount, uint128 validatorId, uint128 unstakingId) public {\n        Unstaking storage us = validators[validatorId].unstakings[msg.sender][unstakingId];\n        require( uint128(block.number) > us.coolDownEnd, \"Cooldown period has not ended\" );\n        require(us.amount >= amount, \"Amount is too high\");\n        _transferFromContract(msg.sender, amount);\n        unchecked { us.amount -= amount; }\n        // set cool down end to 0 to release gas if new unstaking amount is 0\n        if (us.amount == 0)\n            us.coolDownEnd = 0;\n        emit UnstakeRedeemed(validatorId, msg.sender, amount);\n    }\n\n    // returns details of each validator\n    // array index is id\n    function getValidatorsDetails() public view returns (uint128[] memory commissionRates, uint128[] memory delegated) {\n        commissionRates = new uint128[](validatorsN);\n        delegated = new uint128[](validatorsN);\n        for (uint128 i = 0; i < validatorsN; ++i){\n            Validator storage v = validators[i];\n            commissionRates[i] = v.commissionRate;\n            delegated[i] = v.delegated - v.stakings[v._address].staked;\n        }\n        return (commissionRates, delegated);\n    }\n\n    // this follows the same logic as _updateGlobalExchangeRate and _updateValidator\n    // array index is id of validator\n    function getDelegatorDetails(address delegator) public view returns( uint128[] memory delegated,  uint128[] memory rewardsAvailable, uint128[] memory commissionRewards) {\n       delegated = new uint128[](validatorsN);\n       rewardsAvailable = new uint128[](validatorsN);\n       commissionRewards = new uint128[](validatorsN);\n       uint256 currentEpoch = block.number < endEpoch? block.number: endEpoch;\n       uint128 newGlobalExchangeRate = uint128((uint256(allocatedTokensPerEpoch) * divider/totalGlobalShares)*(currentEpoch - lastUpdateEpoch)) + globalExchangeRate;\n       Validator storage v;\n       Staking storage s;\n        for (uint128 i = 0; i < validatorsN; ++i){\n            v = validators[i];\n            s = v.stakings[delegator];\n            delegated[i] = s.staked;\n            if (v.disabledEpoch == 0){\n                uint128 newTokensGiven = _sharesToTokens(v.globalShares, newGlobalExchangeRate - v.lastUpdateGlobalRate);\n                uint128 commissionPaid = uint128(uint256(newTokensGiven) * uint256(v.commissionRate) /  divider);\n                uint128 rateIncrease = uint128(uint256(newTokensGiven - commissionPaid) * divider / v.totalShares);\n                rewardsAvailable[i] = _sharesToTokens(s.shares, v.exchangeRate + rateIncrease) - s.staked;\n                if(delegator == v._address)\n                    commissionRewards[i] = v.commissionAvailableToRedeem + commissionPaid;\n            }\n            else {\n                rewardsAvailable[i] = _sharesToTokens(s.shares, v.exchangeRate) - s.staked;\n                if(delegator == v._address)\n                    commissionRewards[i] = v.commissionAvailableToRedeem;\n            }\n        }\n        return (delegated, rewardsAvailable, commissionRewards);\n    }\n\n    function getMetadata() public view returns(uint128,  uint128, uint128, uint128, uint128 ){\n        uint128 totalStaked = uint128(uint256(totalGlobalShares) * uint256(globalExchangeRate) / divider);\n        return (allocatedTokensPerEpoch, endEpoch, maxCapMultiplier, totalStaked, validatorsN);\n    }\n}",
    "bin": []
}