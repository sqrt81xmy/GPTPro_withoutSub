{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/35/trident",
    "external_functions": [
        [
            "TridentRouter",
            "IBentoBoxMinimal",
            "IPool",
            "MasterDeployer",
            "IPoolFactory"
        ],
        [
            "ConstantProductPoolFactory"
        ],
        [
            "HybridPoolFactory"
        ],
        [
            "IndexPoolFactory"
        ]
    ],
    "new_contract": "contract IndexPoolFactory is PoolDeployer {\n    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}\n\n    function deployPool(bytes memory _deployData) external returns (address pool) {\n        (address[] memory tokens, uint136[] memory weights, uint256 swapFee) = abi.decode(_deployData, (address[], uint136[], uint256));\n\n        // @dev Strips any extra data.\n        _deployData = abi.encode(tokens, weights, swapFee);\n\n        // @dev Salt is not actually needed since `_deployData` is part of creationCode and already contains the salt.\n        bytes32 salt = keccak256(_deployData);\n        pool = address(new IndexPool{salt: salt}(_deployData, masterDeployer));\n        _registerPool(pool, tokens, salt);\n    }\n}\nabstract contract PoolDeployer {\n    address public immutable masterDeployer;\n\n    mapping(address => mapping(address => address[])) public pools;\n    mapping(bytes32 => address) public configAddress;\n\n    modifier onlyMaster() {\n        require(msg.sender == masterDeployer, \"UNAUTHORIZED_DEPLOYER\");\n        _;\n    }\n\n    constructor(address _masterDeployer) {\n        require(_masterDeployer != address(0), \"ZERO_ADDRESS\");\n        masterDeployer = _masterDeployer;\n    }\n\n    function _registerPool(\n        address pool,\n        address[] memory tokens,\n        bytes32 salt\n    ) internal onlyMaster {\n        // @dev Store the address of the deployed contract.\n        configAddress[salt] = pool;\n        // @dev Attacker used underflow, it was not very effective. poolimon!\n        // null token array would cause deployment to fail via out of bounds memory axis/gas limit.\n        unchecked {\n            for (uint256 i; i < tokens.length - 1; i++) {\n                require(tokens[i] < tokens[i + 1], \"INVALID_TOKEN_ORDER\");\n                for (uint256 j = i + 1; j < tokens.length; j++) {\n                    pools[tokens[i]][tokens[j]].push(pool);\n                    pools[tokens[j]][tokens[i]].push(pool);\n                }\n            }\n        }\n    }\n\n    function poolsCount(address token0, address token1) external view returns (uint256 count) {\n        count = pools[token0][token1].length;\n    }\n\n    function getPools(\n        address token0,\n        address token1,\n        uint256 startIndex,\n        uint256 endIndex\n    ) external view returns (address[] memory pairPools) {\n        pairPools = new address[](endIndex - startIndex);\n        for (uint256 i = 0; startIndex < endIndex; i++) {\n            pairPools[i] = pools[token0][token1][startIndex];\n            startIndex++;\n        }\n    }\n}\ncontract MasterDeployer is TridentOwnable {\n    event DeployPool(address indexed factory, address indexed pool, bytes deployData);\n    event AddToWhitelist(address indexed factory);\n    event RemoveFromWhitelist(address indexed factory);\n    event BarFeeUpdated(uint256 indexed barFee);\n    event MigratorUpdated(address indexed migrator);\n\n    uint256 public barFee;\n    address public migrator;\n\n    address public immutable barFeeTo;\n    address public immutable bento;\n\n    uint256 internal constant MAX_FEE = 10000; // @dev 100%.\n\n    mapping(address => bool) public pools;\n    mapping(address => bool) public whitelistedFactories;\n\n    constructor(\n        uint256 _barFee,\n        address _barFeeTo,\n        address _bento\n    ) {\n        require(_barFee <= MAX_FEE, \"INVALID_BAR_FEE\");\n        require(_barFeeTo != address(0), \"ZERO_ADDRESS\");\n        require(_bento != address(0), \"ZERO_ADDRESS\");\n\n        barFee = _barFee;\n        barFeeTo = _barFeeTo;\n        bento = _bento;\n    }\n\n    function deployPool(address _factory, bytes calldata _deployData) external returns (address pool) {\n        require(whitelistedFactories[_factory], \"FACTORY_NOT_WHITELISTED\");\n        pool = IPoolFactory(_factory).deployPool(_deployData);\n        pools[pool] = true;\n        emit DeployPool(_factory, pool, _deployData);\n    }\n\n    function addToWhitelist(address _factory) external onlyOwner {\n        whitelistedFactories[_factory] = true;\n        emit AddToWhitelist(_factory);\n    }\n\n    function removeFromWhitelist(address _factory) external onlyOwner {\n        whitelistedFactories[_factory] = false;\n        emit RemoveFromWhitelist(_factory);\n    }\n\n    function setBarFee(uint256 _barFee) external onlyOwner {\n        require(_barFee <= MAX_FEE, \"INVALID_BAR_FEE\");\n        barFee = _barFee;\n        emit BarFeeUpdated(_barFee);\n    }\n\n    function setMigrator(address _migrator) external onlyOwner {\n        migrator = _migrator;\n        emit MigratorUpdated(_migrator);\n    }\n}\ncontract TridentHelper {\n    /// @notice ERC-20 token for wrapped ETH (v9).\n    address internal immutable wETH;\n\n    constructor(address _wETH) {\n        wETH = _wETH;\n    }\n\n    /// @notice Provides batch function calls for this contract and returns the data from all of them if they all succeed.\n    /// Adapted from https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol, License-Identifier: GPL-2.0-or-later.\n    /// @dev The `msg.value` should not be trusted for any method callable from this function.\n    /// @param data ABI-encoded params for each of the calls to make to this contract.\n    /// @return results The results from each of the calls passed in via `data`.\n    function batch(bytes[] calldata data) external payable returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        // We only allow one exactInputSingle call to be made in a single batch call.\n        // This is not really needed but we want to save users from signing malicious payloads.\n        // We also don't want nested batch calls.\n        bool swapCalled;\n        for (uint256 i = 0; i < data.length; i++) {\n            bytes4 selector = getSelector(data[i]);\n            if (selector == TridentRouter.exactInputSingle.selector || selector == TridentRouter.exactInputSingleWithNativeToken.selector) {\n                require(!swapCalled, \"Swap called twice\");\n                swapCalled = true;\n            } else {\n                require(selector != this.batch.selector, \"Nested Batch\");\n            }\n\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n            if (!success) {\n                // @dev Next 5 lines from https://ethereum.stackexchange.com/a/83577.\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n            results[i] = result;\n        }\n    }\n\n    /// @notice Provides gas-optimized balance check on this contract to avoid redundant extcodesize check in addition to returndatasize check.\n    /// @param token Address of ERC-20 token.\n    /// @return balance Token amount held by this contract.\n    function balanceOfThis(address token) internal view returns (uint256 balance) {\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(0x70a08231, address(this))); // @dev balanceOf(address).\n        require(success && data.length >= 32, \"BALANCE_OF_FAILED\");\n        balance = abi.decode(data, (uint256));\n    }\n\n    /// @notice Provides EIP-2612 signed approval for this contract to spend user tokens.\n    /// @param token Address of ERC-20 token.\n    /// @param amount Token amount to grant spending right over.\n    /// @param deadline Termination for signed approval (UTC timestamp in seconds).\n    /// @param v The recovery byte of the signature.\n    /// @param r Half of the ECDSA signature pair.\n    /// @param s Half of the ECDSA signature pair.\n    function permitThis(\n        address token,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        (bool success, ) = token.call(abi.encodeWithSelector(0xd505accf, msg.sender, address(this), amount, deadline, v, r, s)); // @dev permit(address,address,uint256,uint256,uint8,bytes32,bytes32).\n        require(success, \"PERMIT_FAILED\");\n    }\n\n    /// @notice Provides DAI-derived signed approval for this contract to spend user tokens.\n    /// @param token Address of ERC-20 token.\n    /// @param nonce Token owner's nonce - increases at each call to {permit}.\n    /// @param expiry Termination for signed approval - UTC timestamp in seconds.\n    /// @param v The recovery byte of the signature.\n    /// @param r Half of the ECDSA signature pair.\n    /// @param s Half of the ECDSA signature pair.\n    function permitThisAllowed(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        (bool success, ) = token.call(abi.encodeWithSelector(0x8fcbaf0c, msg.sender, address(this), nonce, expiry, true, v, r, s)); // @dev permit(address,address,uint256,uint256,bool,uint8,bytes32,bytes32).\n        require(success, \"PERMIT_FAILED\");\n    }\n\n    /// @notice Provides 'safe' ERC-20 {transfer} for tokens that don't consistently return true/false.\n    /// @param token Address of ERC-20 token.\n    /// @param recipient Account to send tokens to.\n    /// @param amount Token amount to send.\n    function safeTransfer(\n        address token,\n        address recipient,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, recipient, amount)); // @dev transfer(address,uint256).\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\n    }\n\n    /// @notice Provides 'safe' ERC-20 {transferFrom} for tokens that don't consistently return true/false.\n    /// @param token Address of ERC-20 token.\n    /// @param sender Account to send tokens from.\n    /// @param recipient Account to send tokens to.\n    /// @param amount Token amount to send.\n    function safeTransferFrom(\n        address token,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, sender, recipient, amount)); // @dev transferFrom(address,address,uint256).\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM_FAILED\");\n    }\n\n    /// @notice Provides low-level `wETH` {withdraw}.\n    /// @param amount Token amount to unwrap into ETH.\n    function withdrawFromWETH(uint256 amount) internal {\n        (bool success, ) = wETH.call(abi.encodeWithSelector(0x2e1a7d4d, amount)); // @dev withdraw(uint256).\n        require(success, \"WITHDRAW_FROM_WETH_FAILED\");\n    }\n\n    /// @notice Provides 'safe' ETH transfer.\n    /// @param recipient Account to send ETH to.\n    /// @param amount ETH amount to send.\n    function safeTransferETH(address recipient, uint256 amount) internal {\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /**\n     * @notice function to extract the selector of a bytes calldata\n     * @param _data the calldata bytes\n     */\n    function getSelector(bytes memory _data) internal pure returns (bytes4 sig) {\n        assembly {\n            sig := mload(add(_data, 32))\n        }\n    }\n}\ncontract TridentOwnable {\n    address public owner;\n    address public pendingOwner;\n\n    event TransferOwner(address indexed sender, address indexed recipient);\n    event TransferOwnerClaim(address indexed sender, address indexed recipient);\n\n    /// @notice Initialize and grant deployer account (`msg.sender`) `owner` access role.\n    constructor() {\n        owner = msg.sender;\n        emit TransferOwner(address(0), msg.sender);\n    }\n\n    /// @notice Access control modifier that requires modified function to be called by `owner` account.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"NOT_OWNER\");\n        _;\n    }\n\n    /// @notice `pendingOwner` can claim `owner` account.\n    function claimOwner() external {\n        require(msg.sender == pendingOwner, \"NOT_PENDING_OWNER\");\n        emit TransferOwner(owner, msg.sender);\n        owner = msg.sender;\n        pendingOwner = address(0);\n    }\n\n    /// @notice Transfer `owner` account.\n    /// @param recipient Account granted `owner` access control.\n    /// @param direct If 'true', ownership is directly transferred.\n    function transferOwner(address recipient, bool direct) external onlyOwner {\n        if (direct) {\n            owner = recipient;\n            emit TransferOwner(msg.sender, recipient);\n        } else {\n            pendingOwner = recipient;\n            emit TransferOwnerClaim(msg.sender, recipient);\n        }\n    }\n}\ncontract TridentRouter is ITridentRouter, TridentHelper {\n    /// @notice BentoBox token vault.\n    IBentoBoxMinimal public immutable bento;\n    MasterDeployer public immutable masterDeployer;\n\n    /// @dev Used to ensure that `tridentSwapCallback` is called only by the authorized address.\n    /// These are set when someone calls a flash swap and reset afterwards.\n    address internal cachedMsgSender;\n    address internal cachedPool;\n\n    mapping(address => bool) internal whitelistedPools;\n\n    constructor(\n        IBentoBoxMinimal _bento,\n        MasterDeployer _masterDeployer,\n        address _wETH\n    ) TridentHelper(_wETH) {\n        _bento.registerProtocol();\n        bento = _bento;\n        masterDeployer = _masterDeployer;\n    }\n\n    receive() external payable {\n        require(msg.sender == wETH);\n    }\n\n    /// @notice Swaps token A to token B directly. Swaps are done on `bento` tokens.\n    /// @param params This includes the address of token A, pool, amount of token A to swap,\n    /// minimum amount of token B after the swap and data required by the pool for the swap.\n    /// @dev Ensure that the pool is trusted before calling this function. The pool can steal users' tokens.\n    function exactInputSingle(ExactInputSingleParams calldata params) public payable returns (uint256 amountOut) {\n        // @dev Prefund the pool with token A.\n        bento.transfer(params.tokenIn, msg.sender, params.pool, params.amountIn);\n        // @dev Trigger the swap in the pool.\n        amountOut = IPool(params.pool).swap(params.data);\n        // @dev Ensure that the slippage wasn't too much. This assumes that the pool is honest.\n        require(amountOut >= params.amountOutMinimum, \"TOO_LITTLE_RECEIVED\");\n    }\n\n    /// @notice Swaps token A to token B indirectly by using multiple hops.\n    /// @param params This includes the addresses of the tokens, pools, amount of token A to swap,\n    /// minimum amount of token B after the swap and data required by the pools for the swaps.\n    /// @dev Ensure that the pools are trusted before calling this function. The pools can steal users' tokens.\n    function exactInput(ExactInputParams calldata params) public payable returns (uint256 amountOut) {\n        // @dev Pay the first pool directly.\n        bento.transfer(params.tokenIn, msg.sender, params.path[0].pool, params.amountIn);\n        // @dev Call every pool in the path.\n        // Pool `N` should transfer its output tokens to pool `N+1` directly.\n        // The last pool should transfer its output tokens to the user.\n        // If the user wants to unwrap `wETH`, the final destination should be this contract and\n        // a batch call should be made to `unwrapWETH`.\n        for (uint256 i; i < params.path.length; i++) {\n            // We don't necessarily need this check but saving users from themseleves.\n            isWhiteListed(params.path[i].pool);\n            amountOut = IPool(params.path[i].pool).swap(params.path[i].data);\n        }\n        // @dev Ensure that the slippage wasn't too much. This assumes that the pool is honest.\n        require(amountOut >= params.amountOutMinimum, \"TOO_LITTLE_RECEIVED\");\n    }\n\n    /// @notice Swaps token A to token B by using callbacks.\n    /// @param path Addresses of the pools and data required by the pools for the swaps.\n    /// @param amountOutMinimum Minimum amount of token B after the swap.\n    /// @dev Ensure that the pools are trusted before calling this function. The pools can steal users' tokens.\n    /// This function will unlikely be used in production but it shows how to use callbacks. One use case will be arbitrage.\n    function exactInputLazy(uint256 amountOutMinimum, Path[] calldata path) public payable returns (uint256 amountOut) {\n        // @dev Call every pool in the path.\n        // Pool `N` should transfer its output tokens to pool `N+1` directly.\n        // The last pool should transfer its output tokens to the user.\n        for (uint256 i; i < path.length; i++) {\n            isWhiteListed(path[i].pool);\n            // @dev The cached `msg.sender` is used as the funder when the callback happens.\n            cachedMsgSender = msg.sender;\n            // @dev The cached pool must be the address that calls the callback.\n            cachedPool = path[i].pool;\n            amountOut = IPool(path[i].pool).flashSwap(path[i].data);\n        }\n        // @dev Resets the `cachedPool` to get a refund.\n        // `1` is used as the default value to avoid the storage slot being released.\n        cachedMsgSender = address(1);\n        cachedPool = address(1);\n        require(amountOut >= amountOutMinimum, \"TOO_LITTLE_RECEIVED\");\n    }\n\n    /// @notice Swaps token A to token B directly. It's the same as `exactInputSingle` except\n    /// it takes raw ERC-20 tokens from the users and deposits them into `bento`.\n    /// @param params This includes the address of token A, pool, amount of token A to swap,\n    /// minimum amount of token B after the swap and data required by the pool for the swap.\n    /// @dev Ensure that the pool is trusted before calling this function. The pool can steal users' tokens.\n    function exactInputSingleWithNativeToken(ExactInputSingleParams calldata params) public payable returns (uint256 amountOut) {\n        // @dev Deposits the native ERC-20 token from the user into the pool's `bento`.\n        _depositToBentoBox(params.tokenIn, params.pool, params.amountIn);\n        // @dev Trigger the swap in the pool.\n        amountOut = IPool(params.pool).swap(params.data);\n        // @dev Ensure that the slippage wasn't too much. This assumes that the pool is honest.\n        require(amountOut >= params.amountOutMinimum, \"TOO_LITTLE_RECEIVED\");\n    }\n\n    /// @notice Swaps token A to token B indirectly by using multiple hops. It's the same as `exactInput` except\n    /// it takes raw ERC-20 tokens from the users and deposits them into `bento`.\n    /// @param params This includes the addresses of the tokens, pools, amount of token A to swap,\n    /// minimum amount of token B after the swap and data required by the pools for the swaps.\n    /// @dev Ensure that the pools are trusted before calling this function. The pools can steal users' tokens.\n    function exactInputWithNativeToken(ExactInputParams calldata params) public payable returns (uint256 amountOut) {\n        // @dev Deposits the native ERC-20 token from the user into the pool's `bento`.\n        _depositToBentoBox(params.tokenIn, params.path[0].pool, params.amountIn);\n        // @dev Call every pool in the path.\n        // Pool `N` should transfer its output tokens to pool `N+1` directly.\n        // The last pool should transfer its output tokens to the user.\n        for (uint256 i; i < params.path.length; i++) {\n            isWhiteListed(params.path[i].pool);\n            amountOut = IPool(params.path[i].pool).swap(params.path[i].data);\n        }\n        // @dev Ensure that the slippage wasn't too much. This assumes that the pool is honest.\n        require(amountOut >= params.amountOutMinimum, \"TOO_LITTLE_RECEIVED\");\n    }\n\n    /// @notice Swaps multiple input tokens to multiple output tokens using multiple paths, in different percentages.\n    /// For example, you can swap 50 DAI + 100 USDC into 60% ETH and 40% BTC.\n    /// @param params This includes everything needed for the swap. Look at the `ComplexPathParams` struct for more details.\n    /// @dev This function is not optimized for single swaps and should only be used in complex cases where\n    /// the amounts are large enough that minimizing slippage by using multiple paths is worth the extra gas.\n    function complexPath(ComplexPathParams calldata params) public payable {\n        // @dev Deposit all initial tokens to respective pools and initiate the swaps.\n        // Input tokens come from the user - output goes to following pools.\n        for (uint256 i; i < params.initialPath.length; i++) {\n            if (params.initialPath[i].native) {\n                _depositToBentoBox(params.initialPath[i].tokenIn, params.initialPath[i].pool, params.initialPath[i].amount);\n            } else {\n                bento.transfer(params.initialPath[i].tokenIn, msg.sender, params.initialPath[i].pool, params.initialPath[i].amount);\n            }\n            isWhiteListed(params.initialPath[i].pool);\n            IPool(params.initialPath[i].pool).swap(params.initialPath[i].data);\n        }\n        // @dev Do all the middle swaps. Input comes from previous pools - output goes to following pools.\n        for (uint256 i; i < params.percentagePath.length; i++) {\n            uint256 balanceShares = bento.balanceOf(params.percentagePath[i].tokenIn, address(this));\n            uint256 transferShares = (balanceShares * params.percentagePath[i].balancePercentage) / uint256(10)**8;\n            bento.transfer(params.percentagePath[i].tokenIn, address(this), params.percentagePath[i].pool, transferShares);\n            isWhiteListed(params.percentagePath[i].pool);\n            IPool(params.percentagePath[i].pool).swap(params.percentagePath[i].data);\n        }\n        // @dev Do all the final swaps. Input comes from previous pools - output goes to the user.\n        for (uint256 i; i < params.output.length; i++) {\n            uint256 balanceShares = bento.balanceOf(params.output[i].token, address(this));\n            require(balanceShares >= params.output[i].minAmount, \"TOO_LITTLE_RECEIVED\");\n            if (params.output[i].unwrapBento) {\n                bento.withdraw(params.output[i].token, address(this), params.output[i].to, 0, balanceShares);\n            } else {\n                bento.transfer(params.output[i].token, address(this), params.output[i].to, balanceShares);\n            }\n        }\n    }\n\n    /// @notice Add liquidity to a pool.\n    /// @param tokenInput Token address and amount to add as liquidity.\n    /// @param pool Pool address to add liquidity to.\n    /// @param minLiquidity Minimum output liquidity - caps slippage.\n    /// @param data Data required by the pool to add liquidity.\n    function addLiquidity(\n        TokenInput[] memory tokenInput,\n        address pool,\n        uint256 minLiquidity,\n        bytes calldata data\n    ) public payable returns (uint256 liquidity) {\n        isWhiteListed(pool);\n        // @dev Send all input tokens to the pool.\n        for (uint256 i; i < tokenInput.length; i++) {\n            if (tokenInput[i].native) {\n                _depositToBentoBox(tokenInput[i].token, pool, tokenInput[i].amount);\n            } else {\n                bento.transfer(tokenInput[i].token, msg.sender, pool, tokenInput[i].amount);\n            }\n        }\n        liquidity = IPool(pool).mint(data);\n        require(liquidity >= minLiquidity, \"NOT_ENOUGH_LIQUIDITY_MINTED\");\n    }\n\n    /// @notice Add liquidity to a pool using callbacks - same as `addLiquidity`, but now with callbacks.\n    /// @dev The input tokens are sent to the pool during the callback.\n    function addLiquidityLazy(\n        address pool,\n        uint256 minLiquidity,\n        bytes calldata data\n    ) public payable returns (uint256 liquidity) {\n        isWhiteListed(pool);\n        cachedMsgSender = msg.sender;\n        cachedPool = pool;\n        // @dev The pool must ensure that there's not too much slippage.\n        liquidity = IPool(pool).mint(data);\n        cachedMsgSender = address(1);\n        cachedPool = address(1);\n        require(liquidity >= minLiquidity, \"NOT_ENOUGH_LIQUIDITY_MINTED\");\n    }\n\n    /// @notice Burn liquidity tokens to get back `bento` tokens.\n    /// @param pool Pool address.\n    /// @param liquidity Amount of liquidity tokens to burn.\n    /// @param data Data required by the pool to burn liquidity.\n    /// @param minWithdrawals Minimum amount of `bento` tokens to be returned.\n    function burnLiquidity(\n        address pool,\n        uint256 liquidity,\n        bytes calldata data,\n        IPool.TokenAmount[] memory minWithdrawals\n    ) public {\n        isWhiteListed(pool);\n        safeTransferFrom(pool, msg.sender, pool, liquidity);\n        IPool.TokenAmount[] memory withdrawnLiquidity = IPool(pool).burn(data);\n        for (uint256 i; i < minWithdrawals.length; i++) {\n            uint256 j;\n            for (; j < withdrawnLiquidity.length; j++) {\n                if (withdrawnLiquidity[j].token == minWithdrawals[i].token) {\n                    require(withdrawnLiquidity[j].amount >= minWithdrawals[i].amount, \"TOO_LITTLE_RECEIVED\");\n                    break;\n                }\n            }\n            // @dev A token that is present in `minWithdrawals` is missing from `withdrawnLiquidity`.\n            require(j < withdrawnLiquidity.length, \"INCORRECT_TOKEN_WITHDRAWN\");\n        }\n    }\n\n    /// @notice Burn liquidity tokens to get back `bento` tokens.\n    /// @dev The tokens are swapped automatically and the output is in a single token.\n    /// @param pool Pool address.\n    /// @param liquidity Amount of liquidity tokens to burn.\n    /// @param data Data required by the pool to burn liquidity.\n    /// @param minWithdrawal Minimum amount of tokens to be returned.\n    function burnLiquiditySingle(\n        address pool,\n        uint256 liquidity,\n        bytes calldata data,\n        uint256 minWithdrawal\n    ) public {\n        isWhiteListed(pool);\n        // @dev Use 'liquidity = 0' for prefunding.\n        safeTransferFrom(pool, msg.sender, pool, liquidity);\n        uint256 withdrawn = IPool(pool).burnSingle(data);\n        require(withdrawn >= minWithdrawal, \"TOO_LITTLE_RECEIVED\");\n    }\n\n    /// @notice Used by the pool 'flashSwap' functionality to take input tokens from the user.\n    function tridentSwapCallback(bytes calldata data) external {\n        require(msg.sender == cachedPool, \"UNAUTHORIZED_CALLBACK\");\n        TokenInput memory tokenInput = abi.decode(data, (TokenInput));\n        // @dev Transfer the requested tokens to the pool.\n        if (tokenInput.native) {\n            _depositFromUserToBentoBox(tokenInput.token, cachedMsgSender, msg.sender, tokenInput.amount);\n        } else {\n            bento.transfer(tokenInput.token, cachedMsgSender, msg.sender, tokenInput.amount);\n        }\n        // @dev Resets the `msg.sender`'s authorization.\n        cachedMsgSender = address(1);\n    }\n\n    /// @notice Can be used by the pool 'mint' functionality to take tokens from the user.\n    function tridentMintCallback(bytes calldata data) external {\n        require(msg.sender == cachedPool, \"UNAUTHORIZED_CALLBACK\");\n        TokenInput[] memory tokenInput = abi.decode(data, (TokenInput[]));\n        // @dev Transfer the requested tokens to the pool.\n        for (uint256 i; i < tokenInput.length; i++) {\n            if (tokenInput[i].native) {\n                _depositFromUserToBentoBox(tokenInput[i].token, cachedMsgSender, msg.sender, tokenInput[i].amount);\n            } else {\n                bento.transfer(tokenInput[i].token, cachedMsgSender, msg.sender, tokenInput[i].amount);\n            }\n        }\n        // @dev Resets the `msg.sender`'s authorization.\n        cachedMsgSender = address(1);\n    }\n\n    /// @notice Recover mistakenly sent `bento` tokens.\n    function sweepBentoBoxToken(\n        address token,\n        uint256 amount,\n        address recipient\n    ) external {\n        bento.transfer(token, address(this), recipient, amount);\n    }\n\n    /// @notice Recover mistakenly sent ERC-20 tokens.\n    function sweepNativeToken(\n        address token,\n        uint256 amount,\n        address recipient\n    ) external {\n        safeTransfer(token, recipient, amount);\n    }\n\n    /// @notice Recover mistakenly sent ETH.\n    function refundETH() external payable {\n        if (address(this).balance != 0) safeTransferETH(msg.sender, address(this).balance);\n    }\n\n    /// @notice Unwrap this contract's `wETH` into ETH\n    function unwrapWETH(uint256 amountMinimum, address recipient) external {\n        uint256 balanceWETH = balanceOfThis(wETH);\n        require(balanceWETH >= amountMinimum, \"INSUFFICIENT_WETH\");\n        if (balanceWETH != 0) {\n            withdrawFromWETH(balanceWETH);\n            safeTransferETH(recipient, balanceWETH);\n        }\n    }\n\n    function deployPool(address _factory, bytes calldata _deployData) external returns (address) {\n        return masterDeployer.deployPool(_factory, _deployData);\n    }\n\n    function _depositToBentoBox(\n        address token,\n        address recipient,\n        uint256 amount\n    ) internal {\n        if (token == wETH && address(this).balance != 0) {\n            uint256 underlyingAmount = bento.toAmount(wETH, amount, true);\n            if (address(this).balance >= underlyingAmount) {\n                // @dev Deposit ETH into `recipient` `bento` account.\n                bento.deposit{value: underlyingAmount}(address(0), address(this), recipient, 0, amount);\n                return;\n            }\n        }\n        // @dev Deposit ERC-20 token into `recipient` `bento` account.\n        bento.deposit(token, msg.sender, recipient, 0, amount);\n    }\n\n    function _depositFromUserToBentoBox(\n        address token,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        if (token == wETH && address(this).balance != 0) {\n            uint256 underlyingAmount = bento.toAmount(wETH, amount, true);\n            if (address(this).balance >= underlyingAmount) {\n                // @dev Deposit ETH into `recipient` `bento` account.\n                bento.deposit{value: underlyingAmount}(address(0), address(this), recipient, 0, amount);\n                return;\n            }\n        }\n        // @dev Deposit ERC-20 token into `recipient` `bento` account.\n        bento.deposit(token, sender, recipient, 0, amount);\n    }\n\n    function isWhiteListed(address pool) internal {\n        if (!whitelistedPools[pool]) {\n            require(masterDeployer.pools(pool), \"INVALID POOL\");\n            whitelistedPools[pool] = true;\n        }\n    }\n}\ncontract HybridPoolFactory is PoolDeployer {\n    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}\n\n    function deployPool(bytes memory _deployData) external returns (address pool) {\n        (address tokenA, address tokenB, uint256 swapFee, uint256 a) = abi.decode(_deployData, (address, address, uint256, uint256));\n\n        if (tokenA > tokenB) {\n            (tokenA, tokenB) = (tokenB, tokenA);\n        }\n\n        // @dev Strips any extra data.\n        _deployData = abi.encode(tokenA, tokenB, swapFee, a);\n        address[] memory tokens = new address[](2);\n        tokens[0] = tokenA;\n        tokens[1] = tokenB;\n\n        // @dev Salt is not actually needed since `_deployData` is part of creationCode and already contains the salt.\n        bytes32 salt = keccak256(_deployData);\n        pool = address(new HybridPool{salt: salt}(_deployData, masterDeployer));\n        _registerPool(pool, tokens, salt);\n    }\n}\ncontract ConstantProductPoolFactory is PoolDeployer {\n    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}\n\n    function deployPool(bytes memory _deployData) external returns (address pool) {\n        (address tokenA, address tokenB, uint256 swapFee, bool twapSupport) = abi.decode(_deployData, (address, address, uint256, bool));\n\n        if (tokenA > tokenB) {\n            (tokenA, tokenB) = (tokenB, tokenA);\n        }\n\n        // @dev Strips any extra data.\n        _deployData = abi.encode(tokenA, tokenB, swapFee, twapSupport);\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = tokenA;\n        tokens[1] = tokenB;\n\n        // @dev Salt is not actually needed since `_deployData` is part of creationCode and already contains the salt.\n        bytes32 salt = keccak256(_deployData);\n        pool = address(new ConstantProductPool{salt: salt}(_deployData, masterDeployer));\n        _registerPool(pool, tokens, salt);\n    }\n}\n",
    "bin": []
}