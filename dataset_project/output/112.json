{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/112/backd",
    "external_functions": [
        [
            "AddressProvider",
            "ILiquidityPool",
            "IStakerVault"
        ],
        [
            "Controller",
            "IStakerVault",
            "IInflationManager",
            "IAddressProvider",
            "ILiquidityPool",
            "IERC20",
            "IAction"
        ],
        [
            "LpToken",
            "ILiquidityPool"
        ],
        [
            "StakerVault",
            "IController",
            "IInflationManager",
            "IAddressProvider",
            "ILpGauge",
            "ILiquidityPool",
            "IERC20Full",
            "IERC20",
            "IRoleManager"
        ],
        [
            "RoleManager",
            "IAddressProvider"
        ],
        [
            "ChainlinkOracleProvider",
            "AggregatorV2V3Interface"
        ],
        [
            "IChainlinkOracle"
        ],
        [
            "ChainlinkUsdWrapper",
            "IChainlinkOracle"
        ],
        [
            "Erc20Pool",
            "IController",
            "IStakerVault",
            "IVault",
            "ILpToken",
            "IAddressProvider",
            "IRoleManager",
            "IERC20"
        ],
        [
            "EthPool",
            "IController",
            "IStakerVault",
            "IVault",
            "ILpToken",
            "IAddressProvider",
            "IRoleManager"
        ],
        [
            "PoolFactory",
            "IController",
            "IStakerVault",
            "IAddressProvider",
            "ILiquidityPool",
            "IEthPool",
            "ILpToken",
            "IVault",
            "IErc20Pool"
        ],
        [
            "Erc20Vault",
            "IController",
            "IStrategy",
            "IVaultReserve",
            "IPausable",
            "ILiquidityPool",
            "IERC20"
        ],
        [
            "EthVault",
            "IController",
            "IStrategy",
            "IVaultReserve",
            "IPausable",
            "ILiquidityPool"
        ],
        [
            "Vault",
            "IController",
            "IStrategy",
            "IVaultReserve",
            "IPausable"
        ],
        [
            "VaultReserve",
            "IERC20"
        ]
    ],
    "new_contract": "contract Erc20Vault is Vault {\n    using AddressProviderHelpers for IAddressProvider;\n    using SafeERC20 for IERC20;\n\n    constructor(IController controller) Vault(controller) {}\n\n    function initialize(\n        address _pool,\n        uint256 _debtLimit,\n        uint256 _targetAllocation,\n        uint256 _bound\n    ) external virtual override initializer {\n        _initialize(_pool, _debtLimit, _targetAllocation, _bound);\n        address underlying_ = ILiquidityPool(pool).getUnderlying();\n        require(underlying_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        IERC20(underlying_).safeApprove(address(reserve), type(uint256).max);\n        IERC20(underlying_).safeApprove(_pool, type(uint256).max);\n    }\n\n    function getUnderlying() public view override returns (address) {\n        return ILiquidityPool(pool).getUnderlying();\n    }\n\n    function _transfer(address to, uint256 amount) internal override {\n        IERC20(getUnderlying()).safeTransfer(to, amount);\n    }\n\n    function _depositToReserve(uint256 amount) internal override {\n        reserve.deposit(getUnderlying(), amount);\n    }\n\n    function _depositToTreasury(uint256 amount) internal override {\n        IERC20(getUnderlying()).safeTransfer(addressProvider.getTreasury(), amount);\n    }\n\n    function _payStrategist(uint256 amount, address strategist) internal override {\n        if (strategist == address(0)) return;\n        ILiquidityPool(pool).depositFor(strategist, amount);\n    }\n\n    function _availableUnderlying() internal view override returns (uint256) {\n        return IERC20(getUnderlying()).balanceOf(address(this));\n    }\n}\ncontract VaultStorage {\n    uint256 public currentAllocated;\n    uint256 public waitingForRemovalAllocated;\n    address public pool;\n\n    uint256 public totalDebt;\n    bool public strategyActive;\n\n    EnumerableMapping.AddressToUintMap internal _strategiesWaitingForRemoval;\n}\ncontract EthPool is LiquidityPool, IEthPool {\n    constructor(IController _controller) LiquidityPool(_controller) {}\n\n    receive() external payable {}\n\n    function initialize(\n        string memory name_,\n        uint256 depositCap_,\n        address vault_\n    ) external override returns (bool) {\n        return _initialize(name_, depositCap_, vault_);\n    }\n\n    function getUnderlying() public pure override returns (address) {\n        return address(0);\n    }\n\n    function _doTransferIn(address from, uint256 amount) internal override {\n        require(msg.sender == from, Error.INVALID_SENDER);\n        require(msg.value == amount, Error.INVALID_AMOUNT);\n    }\n\n    function _doTransferOut(address payable to, uint256 amount) internal override {\n        to.transfer(amount);\n    }\n\n    function _getBalanceUnderlying() internal view override returns (uint256) {\n        return _getBalanceUnderlying(false);\n    }\n\n    function _getBalanceUnderlying(bool transferInDone) internal view override returns (uint256) {\n        uint256 balance = address(this).balance;\n        if (!transferInDone) {\n            balance -= msg.value;\n        }\n        return balance;\n    }\n}\ncontract PoolFactory is Authorization {\n    using AddressProviderHelpers for IAddressProvider;\n\n    struct Addresses {\n        address pool;\n        address vault;\n        address lpToken;\n        address stakerVault;\n    }\n\n    struct ImplementationNames {\n        bytes32 pool;\n        bytes32 vault;\n        bytes32 lpToken;\n        bytes32 stakerVault;\n    }\n\n    struct VaultArgs {\n        uint256 debtLimit;\n        uint256 targetAllocation;\n        uint256 bound;\n    }\n\n    struct LpTokenArgs {\n        string name;\n        string symbol;\n        uint8 decimals;\n    }\n\n    struct DeployPoolVars {\n        address lpTokenImplementation;\n        address poolImplementation;\n        address stakerVaultImplementation;\n        address vaultImplementation;\n    }\n\n    bytes32 internal constant _POOL_KEY = \"pool\";\n    bytes32 internal constant _LP_TOKEN_KEY = \"lp_token\";\n    bytes32 internal constant _STAKER_VAULT_KEY = \"staker_vault\";\n    bytes32 internal constant _VAULT_KEY = \"vault\";\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    /**\n     * @dev maps a contract type (e.g. \"pool\" or \"lp_token\", as defined in constants above)\n     * to a mapping from an implementation name to the actual implementation\n     * The implementation name is decided when registering the implementation\n     * and can be arbitrary (e.g. \"ERC20PoolV1\")\n     */\n    mapping(bytes32 => mapping(bytes32 => address)) public implementations;\n\n    event NewPool(address pool, address vault, address lpToken, address stakerVault);\n    event NewImplementation(bytes32 key, bytes32 name, address implementation);\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = IController(_controller);\n        addressProvider = IController(_controller).addressProvider();\n    }\n\n    /**\n     * @notice Add a new pool implementation to the factory.\n     * @param name of the pool implementation.\n     * @param implementation of pool implementation to add.\n     */\n    function addPoolImplementation(bytes32 name, address implementation)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        return _addImplementation(_POOL_KEY, name, implementation);\n    }\n\n    /**\n     * @notice Add a new LP token implementation to the factory.\n     * @param name of the LP token implementation.\n     * @param implementation of lp token implementation to add.\n     */\n    function addLpTokenImplementation(bytes32 name, address implementation)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        return _addImplementation(_LP_TOKEN_KEY, name, implementation);\n    }\n\n    /**\n     * @notice Add a new vault implementation to the factory.\n     * @param name of the vault implementation.\n     * @param implementation of vault implementation to add.\n     */\n    function addVaultImplementation(bytes32 name, address implementation)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        return _addImplementation(_VAULT_KEY, name, implementation);\n    }\n\n    /**\n     * @notice Add a new staker vault implementation to the factory.\n     * @param name of the staker vault implementation.\n     * @param implementation of staker vault implementation to add.\n     */\n    function addStakerVaultImplementation(bytes32 name, address implementation)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        return _addImplementation(_STAKER_VAULT_KEY, name, implementation);\n    }\n\n    /**\n     * @notice Deploys a new pool and LP token.\n     * @dev Decimals is an argument as not all ERC20 tokens implement the ERC20Detailed interface.\n     *      An implementation where `getUnderlying()` returns the zero address is for ETH pools.\n     * @param poolName Name of the pool.\n     * @param underlying Address of the pool's underlying.\n     * @param lpTokenArgs Arguments to create the LP token for the pool\n     * @param vaultArgs Arguments to create the vault\n     * @param implementationNames Name of the implementations to use\n     * @return addrs Address of the deployed pool, address of the pool's deployed LP token.\n     */\n    function deployPool(\n        string calldata poolName,\n        uint256 depositCap,\n        address underlying,\n        LpTokenArgs calldata lpTokenArgs,\n        VaultArgs calldata vaultArgs,\n        ImplementationNames calldata implementationNames\n    ) external onlyGovernance returns (Addresses memory addrs) {\n        DeployPoolVars memory vars;\n\n        vars.poolImplementation = implementations[_POOL_KEY][implementationNames.pool];\n        require(vars.poolImplementation != address(0), Error.INVALID_POOL_IMPLEMENTATION);\n\n        vars.lpTokenImplementation = implementations[_LP_TOKEN_KEY][implementationNames.lpToken];\n        require(vars.lpTokenImplementation != address(0), Error.INVALID_LP_TOKEN_IMPLEMENTATION);\n\n        vars.vaultImplementation = implementations[_VAULT_KEY][implementationNames.vault];\n        require(vars.vaultImplementation != address(0), Error.INVALID_VAULT_IMPLEMENTATION);\n\n        vars.stakerVaultImplementation = implementations[_STAKER_VAULT_KEY][\n            implementationNames.stakerVault\n        ];\n        require(\n            vars.stakerVaultImplementation != address(0),\n            Error.INVALID_STAKER_VAULT_IMPLEMENTATION\n        );\n\n        addrs.pool = Clones.clone(vars.poolImplementation);\n        addrs.vault = Clones.clone(vars.vaultImplementation);\n\n        if (underlying == address(0)) {\n            // ETH pool\n            require(\n                ILiquidityPool(vars.poolImplementation).getUnderlying() == address(0),\n                Error.INVALID_POOL_IMPLEMENTATION\n            );\n            require(lpTokenArgs.decimals == 18, Error.INVALID_DECIMALS);\n            IEthPool(addrs.pool).initialize(poolName, depositCap, addrs.vault);\n        } else {\n            IErc20Pool(addrs.pool).initialize(poolName, underlying, depositCap, addrs.vault);\n        }\n\n        addrs.lpToken = Clones.clone(vars.lpTokenImplementation);\n\n        ILpToken(addrs.lpToken).initialize(\n            lpTokenArgs.name,\n            lpTokenArgs.symbol,\n            lpTokenArgs.decimals,\n            addrs.pool\n        );\n\n        addrs.stakerVault = Clones.clone(vars.stakerVaultImplementation);\n        IStakerVault(addrs.stakerVault).initialize(addrs.lpToken);\n        controller.addStakerVault(addrs.stakerVault);\n\n        ILiquidityPool(addrs.pool).setLpToken(addrs.lpToken);\n        ILiquidityPool(addrs.pool).setStaker();\n\n        IVault(addrs.vault).initialize(\n            addrs.pool,\n            vaultArgs.debtLimit,\n            vaultArgs.targetAllocation,\n            vaultArgs.bound\n        );\n\n        addressProvider.addPool(addrs.pool);\n\n        emit NewPool(addrs.pool, addrs.vault, addrs.lpToken, addrs.stakerVault);\n        return addrs;\n    }\n\n    /**\n     * @notice Add a new implementation of type `name` to the factory.\n     * @param key of the implementation to add.\n     * @param name of the implementation to add.\n     * @param implementation of lp token implementation to add.\n     */\n    function _addImplementation(\n        bytes32 key,\n        bytes32 name,\n        address implementation\n    ) internal returns (bool) {\n        mapping(bytes32 => address) storage currentImplementations = implementations[key];\n        if (currentImplementations[name] != address(0)) {\n            return false;\n        }\n        currentImplementations[name] = implementation;\n        emit NewImplementation(key, name, implementation);\n        return true;\n    }\n}\ncontract VaultReserve is IVaultReserve, Authorization {\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant _INITIAL_WITHDRAWAL_DELAY = 3 days;\n\n    mapping(address => mapping(address => uint256)) private _balances;\n    mapping(address => uint256) private _lastWithdrawal;\n\n    uint256 public minWithdrawalDelay;\n\n    modifier onlyVault() {\n        require(_roleManager().hasRole(Roles.VAULT, msg.sender), Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    constructor(IRoleManager roleManager) Authorization(roleManager) {\n        minWithdrawalDelay = _INITIAL_WITHDRAWAL_DELAY;\n    }\n\n    /**\n     * @notice Deposit funds into vault reserve.\n     * @notice Only callable by a whitelisted vault.\n     * @param token Token to deposit.\n     * @param amount Amount to deposit.\n     * @return True if deposit was successful.\n     */\n    function deposit(address token, uint256 amount)\n        external\n        payable\n        override\n        onlyVault\n        returns (bool)\n    {\n        if (token == address(0)) {\n            require(msg.value == amount, Error.INVALID_AMOUNT);\n            _balances[msg.sender][token] += msg.value;\n            return true;\n        }\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBalance = IERC20(token).balanceOf(address(this));\n        uint256 received = newBalance - balance;\n        require(received >= amount, Error.INVALID_AMOUNT);\n        _balances[msg.sender][token] += received;\n        emit Deposit(msg.sender, token, amount);\n        return true;\n    }\n\n    /**\n     * @notice Withdraw funds from vault reserve.\n     * @notice Only callable by a whitelisted vault.\n     * @param token Token to withdraw.\n     * @param amount Amount to withdraw.\n     * @return True if withdrawal was successful.\n     */\n    function withdraw(address token, uint256 amount) external override onlyVault returns (bool) {\n        require(canWithdraw(msg.sender), Error.RESERVE_ACCESS_EXCEEDED);\n        uint256 accountBalance = _balances[msg.sender][token];\n        require(accountBalance >= amount, Error.INSUFFICIENT_BALANCE);\n\n        _balances[msg.sender][token] -= amount;\n        _lastWithdrawal[msg.sender] = block.timestamp;\n\n        if (token == address(0)) {\n            payable(msg.sender).transfer(amount);\n        } else {\n            IERC20(token).safeTransfer(msg.sender, amount);\n        }\n        emit Withdraw(msg.sender, token, amount);\n        return true;\n    }\n\n    /**\n     * @notice Check token balance of a specific vault.\n     * @param vault Vault to check balance of.\n     * @param token Token to check balance in.\n     * @return Token balance of vault.\n     */\n    function getBalance(address vault, address token) public view override returns (uint256) {\n        return _balances[vault][token];\n    }\n\n    /**\n     * @notice returns true if the vault is allowed to withdraw from the reserve\n     */\n    function canWithdraw(address vault) public view returns (bool) {\n        return block.timestamp >= _lastWithdrawal[vault] + minWithdrawalDelay;\n    }\n}\ncontract Authorization is AuthorizationBase {\n    IRoleManager internal immutable __roleManager;\n\n    constructor(IRoleManager roleManager) {\n        __roleManager = roleManager;\n    }\n\n    function _roleManager() internal view override returns (IRoleManager) {\n        return __roleManager;\n    }\n}\ncontract EthVault is Vault {\n    using AddressProviderHelpers for IAddressProvider;\n\n    address private constant _UNDERLYING = address(0);\n\n    constructor(IController controller) Vault(controller) {}\n\n    receive() external payable {}\n\n    function initialize(\n        address _pool,\n        uint256 _debtLimit,\n        uint256 _targetAllocation,\n        uint256 _bound\n    ) external virtual override initializer {\n        _initialize(_pool, _debtLimit, _targetAllocation, _bound);\n    }\n\n    function getUnderlying() public pure override returns (address) {\n        return _UNDERLYING;\n    }\n\n    function _transfer(address to, uint256 amount) internal override {\n        payable(to).transfer(amount);\n    }\n\n    function _depositToReserve(uint256 amount) internal override {\n        reserve.deposit{value: amount}(_UNDERLYING, amount);\n    }\n\n    function _depositToTreasury(uint256 amount) internal override {\n        payable(addressProvider.getTreasury()).transfer(amount);\n    }\n\n    function _payStrategist(uint256 amount, address strategist) internal override {\n        if (strategist == address(0)) return;\n        ILiquidityPool(pool).depositFor{value: amount}(strategist, amount);\n    }\n\n    function _availableUnderlying() internal view override returns (uint256) {\n        return address(this).balance;\n    }\n}\ncontract Controller is IController, Authorization, Preparable {\n    using AddressProviderHelpers for IAddressProvider;\n\n    IAddressProvider public immutable override addressProvider;\n\n    IInflationManager public inflationManager;\n\n    bytes32 internal constant _KEEPER_REQUIRED_STAKED_BKD = \"KEEPER_REQUIRED_STAKED_BKD\";\n\n    constructor(IAddressProvider _addressProvider)\n        Authorization(_addressProvider.getRoleManager())\n    {\n        addressProvider = _addressProvider;\n    }\n\n    function setInflationManager(address _inflationManager) external onlyGovernance {\n        require(address(inflationManager) == address(0), Error.ADDRESS_ALREADY_SET);\n        require(_inflationManager != address(0), Error.INVALID_ARGUMENT);\n        inflationManager = IInflationManager(_inflationManager);\n    }\n\n    function addStakerVault(address stakerVault)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY)\n        returns (bool)\n    {\n        if (!addressProvider.addStakerVault(stakerVault)) {\n            return false;\n        }\n        if (address(inflationManager) != address(0)) {\n            address lpGauge = IStakerVault(stakerVault).getLpGauge();\n            if (lpGauge != address(0)) {\n                inflationManager.whitelistGauge(lpGauge);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @notice Delists pool.\n     * @param pool Address of pool to delist.\n     * @return `true` if successful.\n     */\n    function removePool(address pool) external override onlyGovernance returns (bool) {\n        if (!addressProvider.removePool(pool)) {\n            return false;\n        }\n        address lpToken = ILiquidityPool(pool).getLpToken();\n\n        if (address(inflationManager) != address(0)) {\n            (bool exists, address stakerVault) = addressProvider.tryGetStakerVault(lpToken);\n            if (exists) {\n                inflationManager.removeStakerVaultFromInflation(stakerVault, lpToken);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Prepares the minimum amount of staked BKD required by a keeper\n     */\n    function prepareKeeperRequiredStakedBKD(uint256 amount) external override onlyGovernance {\n        require(addressProvider.getBKDLocker() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        _prepare(_KEEPER_REQUIRED_STAKED_BKD, amount);\n    }\n\n    /**\n     * @notice Sets the minimum amount of staked BKD required by a keeper to the prepared value\n     */\n    function executeKeeperRequiredStakedBKD() external override {\n        _executeUInt256(_KEEPER_REQUIRED_STAKED_BKD);\n    }\n\n    /**\n     * @notice Returns true if the given keeper has enough staked BKD to execute actions\n     */\n    function canKeeperExecuteAction(address keeper) external view override returns (bool) {\n        uint256 requiredBKD = getKeeperRequiredStakedBKD();\n        return\n            requiredBKD == 0 ||\n            IERC20(addressProvider.getBKDLocker()).balanceOf(keeper) >= requiredBKD;\n    }\n\n    /**\n     * @return Returns the minimum amount of staked BKD required by a keeper\n     */\n    function getKeeperRequiredStakedBKD() public view override returns (uint256) {\n        return currentUInts256[_KEEPER_REQUIRED_STAKED_BKD];\n    }\n\n    /**\n     * @return the total amount of ETH require by `payer` to cover the fees for\n     * positions registered in all actions\n     */\n    function getTotalEthRequiredForGas(address payer) external view override returns (uint256) {\n        // solhint-disable-previous-line ordering\n        uint256 totalEthRequired = 0;\n        address[] memory actions = addressProvider.allActions();\n        uint256 numActions = actions.length;\n        for (uint256 i = 0; i < numActions; i++) {\n            totalEthRequired += IAction(actions[i]).getEthRequiredForGas(payer);\n        }\n        return totalEthRequired;\n    }\n}\ncontract LpToken is ILpToken, ERC20Upgradeable {\n    using ScaledMath for uint256;\n\n    uint8 private _decimals;\n\n    address public override minter;\n\n    /**\n     * @notice Make a function only callable by the minter contract.\n     * @dev Fails if msg.sender is not the minter.\n     */\n    modifier onlyMinter() {\n        require(msg.sender == minter, Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    constructor() ERC20Upgradeable() {}\n\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address _minter\n    ) external override initializer returns (bool) {\n        require(_minter != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        __ERC20_init(name_, symbol_);\n        _decimals = decimals_;\n        minter = _minter;\n        return true;\n    }\n\n    /**\n     * @notice Mint tokens.\n     * @param account Account from which tokens should be burned.\n     * @param amount Amount of tokens to mint.\n     */\n    function mint(address account, uint256 amount) external override onlyMinter {\n        _mint(account, amount);\n    }\n\n    /**\n     * @notice Burns tokens of msg.sender.\n     * @param amount Amount of tokens to burn.\n     */\n    function burn(uint256 amount) external override {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n     * @notice Burn tokens.\n     * @param owner Account from which tokens should be burned.\n     * @param burnAmount Amount of tokens to burn.\n     * @return Aamount of tokens burned.\n     */\n    function burn(address owner, uint256 burnAmount)\n        external\n        override\n        onlyMinter\n        returns (uint256)\n    {\n        _burn(owner, burnAmount);\n        return burnAmount;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev We notify that LP tokens have been transfered\n     * this is currently used to keep track of the withdrawal fees\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        if (amount > 0) ILiquidityPool(minter).handleLpTokenTransfer(from, to, amount); // add check to not break 0 transfers\n    }\n}\ncontract ChainlinkUsdWrapper is IChainlinkOracle {\n    using DecimalScale for uint256;\n\n    IChainlinkOracle private immutable _ethOracle =\n        IChainlinkOracle(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n    IChainlinkOracle private immutable _oracle;\n    uint8 private immutable _decimals;\n\n    constructor(address oracle_) {\n        _oracle = IChainlinkOracle(oracle_);\n        _decimals = IChainlinkOracle(oracle_).decimals();\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        (\n            uint80 roundId_,\n            int256 answer_,\n            uint256 startedAt_,\n            uint256 updatedAt_,\n            uint80 answeredInRound_\n        ) = _oracle.latestRoundData();\n        return (roundId_, (answer_ * _ethPrice()) / 1e8, startedAt_, updatedAt_, answeredInRound_);\n    }\n\n    function decimals() external view override returns (uint8) {\n        return _decimals;\n    }\n\n    function _ethPrice() private view returns (int256) {\n        (, int256 answer, , , ) = _ethOracle.latestRoundData();\n        return answer;\n    }\n}\ncontract ChainlinkOracleProvider is IChainlinkOracleProvider, Authorization {\n    using DecimalScale for uint256;\n\n    uint256 public stalePriceDelay;\n\n    mapping(address => address) public feeds;\n\n    event FeedUpdated(address indexed asset, address indexed previousFeed, address indexed newFeed);\n\n    constructor(IRoleManager roleManager, address ethFeed) Authorization(roleManager) {\n        feeds[address(0)] = ethFeed;\n        stalePriceDelay = 2 hours;\n    }\n\n    /// @notice Allows to set Chainlink feeds\n    /// @dev All feeds should be set relative to USD.\n    /// This can only be called by governance\n    function setFeed(address asset, address feed) external override onlyGovernance {\n        address previousFeed = feeds[asset];\n        require(feed != previousFeed, Error.INVALID_ARGUMENT);\n        feeds[asset] = feed;\n        emit FeedUpdated(asset, previousFeed, feed);\n    }\n\n    /**\n     * @notice Sets the stake price delay value.\n     * @param stalePriceDelay_ The new stale price delay to set.\n     */\n    function setStalePriceDelay(uint256 stalePriceDelay_) external override onlyGovernance {\n        require(stalePriceDelay_ >= 1 hours, Error.INVALID_ARGUMENT);\n        stalePriceDelay = stalePriceDelay_;\n    }\n\n    /// @inheritdoc IOracleProvider\n    function getPriceETH(address asset) external view override returns (uint256) {\n        return (getPriceUSD(asset) * 1e18) / getPriceUSD(address(0));\n    }\n\n    /// @inheritdoc IOracleProvider\n    function getPriceUSD(address asset) public view override returns (uint256) {\n        address feed = feeds[asset];\n        require(feed != address(0), Error.ASSET_NOT_SUPPORTED);\n\n        (, int256 answer, , uint256 updatedAt, ) = AggregatorV2V3Interface(feed).latestRoundData();\n\n        require(block.timestamp <= updatedAt + stalePriceDelay, Error.STALE_PRICE);\n        require(answer >= 0, Error.NEGATIVE_PRICE);\n\n        uint256 price = uint256(answer);\n        uint8 decimals = AggregatorV2V3Interface(feed).decimals();\n        return price.scaleFrom(decimals);\n    }\n}\ncontract RoleManager is IRoleManager {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    IAddressProvider public immutable addressProvider;\n\n    modifier onlyGovernance() {\n        require(hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    constructor(IAddressProvider _addressProvider) {\n        addressProvider = _addressProvider;\n        _grantRole(Roles.GOVERNANCE, msg.sender);\n    }\n\n    function grantRole(bytes32 role, address account) external onlyGovernance {\n        _grantRole(role, account);\n    }\n\n    function addGovernor(address newGovernor) external onlyGovernance {\n        _grantRole(Roles.GOVERNANCE, newGovernor);\n    }\n\n    function renounceGovernance() external onlyGovernance {\n        require(getRoleMemberCount(Roles.GOVERNANCE) > 1, Error.CANNOT_REVOKE_ROLE);\n        _revokeRole(Roles.GOVERNANCE, msg.sender);\n    }\n\n    function addGaugeZap(address zap) external onlyGovernance {\n        _grantRole(Roles.GAUGE_ZAP, zap);\n    }\n\n    function removeGaugeZap(address zap) external {\n        revokeRole(Roles.GAUGE_ZAP, zap);\n    }\n\n    function hasAnyRole(\n        bytes32 role1,\n        bytes32 role2,\n        address account\n    ) external view returns (bool) {\n        return hasRole(role1, account) || hasRole(role2, account);\n    }\n\n    function hasAnyRole(\n        bytes32 role1,\n        bytes32 role2,\n        bytes32 role3,\n        address account\n    ) external view returns (bool) {\n        return hasRole(role1, account) || hasRole(role2, account) || hasRole(role3, account);\n    }\n\n    function hasAnyRole(bytes32[] memory roles, address account)\n        external\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        for (uint256 i = 0; i < roles.length; i++) {\n            if (hasRole(roles[i], account)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getRoleMember(bytes32 role, uint256 index)\n        external\n        view\n        virtual\n        override\n        returns (address)\n    {\n        if (role == Roles.ADDRESS_PROVIDER && index == 0) {\n            return address(addressProvider);\n        } else if (role == Roles.POOL_FACTORY && index == 0) {\n            return addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY);\n        } else if (role == Roles.CONTROLLER && index == 0) {\n            return addressProvider.getAddress(AddressProviderKeys._CONTROLLER_KEY);\n        } else if (role == Roles.POOL) {\n            return addressProvider.getPoolAtIndex(index);\n        } else if (role == Roles.VAULT) {\n            return addressProvider.getVaultAtIndex(index);\n        }\n        return _roleMembers[role].at(index);\n    }\n\n    function revokeRole(bytes32 role, address account) public onlyGovernance {\n        require(role != Roles.GOVERNANCE, Error.CANNOT_REVOKE_ROLE);\n        require(hasRole(role, account), Error.INVALID_ARGUMENT);\n        _revokeRole(role, account);\n    }\n\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        if (\n            role == Roles.ADDRESS_PROVIDER || role == Roles.POOL_FACTORY || role == Roles.CONTROLLER\n        ) {\n            return 1;\n        }\n        if (role == Roles.POOL) {\n            return addressProvider.poolsCount();\n        }\n        if (role == Roles.VAULT) {\n            return addressProvider.vaultsCount();\n        }\n        return _roleMembers[role].length();\n    }\n\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        if (role == Roles.ADDRESS_PROVIDER) {\n            return account == address(addressProvider);\n        } else if (role == Roles.POOL_FACTORY) {\n            return\n                account == addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY, false);\n        } else if (role == Roles.CONTROLLER) {\n            return\n                account == addressProvider.getAddress(AddressProviderKeys._CONTROLLER_KEY, false);\n        } else if (role == Roles.MAINTENANCE) {\n            return _roles[role].members[account] || _roles[Roles.GOVERNANCE].members[account];\n        } else if (role == Roles.POOL) {\n            return addressProvider.isPool(account);\n        } else if (role == Roles.VAULT) {\n            return addressProvider.isVault(account);\n        }\n        return _roles[role].members[account];\n    }\n\n    function _grantRole(bytes32 role, address account) internal {\n        _roles[role].members[account] = true;\n        _roleMembers[role].add(account);\n        emit RoleGranted(role, account, msg.sender);\n    }\n\n    function _revokeRole(bytes32 role, address account) internal {\n        _roles[role].members[account] = false;\n        emit RoleRevoked(role, account, msg.sender);\n    }\n}\nabstract contract Vault is IVault, Authorization, VaultStorageV1, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using EnumerableMapping for EnumerableMapping.AddressToUintMap;\n    using EnumerableExtensions for EnumerableMapping.AddressToUintMap;\n    using AddressProviderHelpers for IAddressProvider;\n\n    bytes32 internal constant _STRATEGY_KEY = \"Strategy\";\n    bytes32 internal constant _PERFORMANCE_FEE_KEY = \"PerformanceFee\";\n    bytes32 internal constant _STRATEGIST_FEE_KEY = \"StrategistFee\";\n    bytes32 internal constant _DEBT_LIMIT_KEY = \"DebtLimit\";\n    bytes32 internal constant _TARGET_ALLOCATION_KEY = \"TargetAllocation\";\n    bytes32 internal constant _RESERVE_FEE_KEY = \"ReserveFee\";\n    bytes32 internal constant _BOUND_KEY = \"Bound\";\n\n    uint256 internal constant _INITIAL_RESERVE_FEE = 0.01e18;\n    uint256 internal constant _INITIAL_STRATEGIST_FEE = 0.1e18;\n    uint256 internal constant _INITIAL_PERFORMANCE_FEE = 0;\n\n    uint256 public constant MAX_PERFORMANCE_FEE = 0.5e18;\n    uint256 public constant MAX_DEVIATION_BOUND = 0.5e18;\n    uint256 public constant STRATEGY_DELAY = 5 days;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n    IVaultReserve public immutable reserve;\n\n    modifier onlyPool() {\n        require(msg.sender == pool, Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    modifier onlyPoolOrGovernance() {\n        require(\n            msg.sender == pool || _roleManager().hasRole(Roles.GOVERNANCE, msg.sender),\n            Error.UNAUTHORIZED_ACCESS\n        );\n        _;\n    }\n\n    modifier onlyPoolOrMaintenance() {\n        require(\n            msg.sender == pool || _roleManager().hasRole(Roles.MAINTENANCE, msg.sender),\n            Error.UNAUTHORIZED_ACCESS\n        );\n        _;\n    }\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        IAddressProvider addressProvider_ = _controller.addressProvider();\n        addressProvider = addressProvider_;\n        reserve = IVaultReserve(addressProvider_.getVaultReserve());\n    }\n\n    function _initialize(\n        address _pool,\n        uint256 _debtLimit,\n        uint256 _targetAllocation,\n        uint256 _bound\n    ) internal {\n        require(_debtLimit <= ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(_targetAllocation <= ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(_bound <= MAX_DEVIATION_BOUND, Error.INVALID_AMOUNT);\n\n        pool = _pool;\n\n        _setConfig(_DEBT_LIMIT_KEY, _debtLimit);\n        _setConfig(_TARGET_ALLOCATION_KEY, _targetAllocation);\n        _setConfig(_BOUND_KEY, _bound);\n        _setConfig(_RESERVE_FEE_KEY, _INITIAL_RESERVE_FEE);\n        _setConfig(_STRATEGIST_FEE_KEY, _INITIAL_STRATEGIST_FEE);\n        _setConfig(_PERFORMANCE_FEE_KEY, _INITIAL_PERFORMANCE_FEE);\n    }\n\n    /**\n     * @notice Handles deposits from the liquidity pool\n     */\n    function deposit() external payable override onlyPoolOrMaintenance {\n        // solhint-disable-previous-line ordering\n        _deposit();\n    }\n\n    /**\n     * @notice Withdraws specified amount of underlying from vault.\n     * @dev If the specified amount exceeds idle funds, an amount of funds is withdrawn\n     *      from the strategy such that it will achieve a target allocation for after the\n     *      amount has been withdrawn.\n     * @param amount Amount to withdraw.\n     * @return `true` if successful.\n     */\n    function withdraw(uint256 amount) external override onlyPoolOrGovernance returns (bool) {\n        IStrategy strategy = getStrategy();\n        uint256 availableUnderlying_ = _availableUnderlying();\n\n        if (availableUnderlying_ < amount) {\n            if (address(strategy) == address(0)) return false;\n            uint256 allocated = strategy.balance();\n            uint256 requiredWithdrawal = amount - availableUnderlying_;\n\n            if (requiredWithdrawal > allocated) return false;\n\n            // compute withdrawal amount to sustain target allocation\n            uint256 newTarget = (allocated - requiredWithdrawal).scaledMul(getTargetAllocation());\n            uint256 excessAmount = allocated - newTarget;\n            strategy.withdraw(excessAmount);\n            currentAllocated = _computeNewAllocated(currentAllocated, excessAmount);\n        } else {\n            uint256 allocatedUnderlying = 0;\n            if (address(strategy) != address(0))\n                allocatedUnderlying = IStrategy(strategy).balance();\n            uint256 totalUnderlying = availableUnderlying_ +\n                allocatedUnderlying +\n                waitingForRemovalAllocated;\n            uint256 totalUnderlyingAfterWithdraw = totalUnderlying - amount;\n            _rebalance(totalUnderlyingAfterWithdraw, allocatedUnderlying);\n        }\n\n        _transfer(pool, amount);\n        return true;\n    }\n\n    /**\n     * @notice Withdraws all funds from vault and strategy and transfer them to the pool.\n     */\n    function withdrawAll() external override onlyPoolOrGovernance {\n        _withdrawAllFromStrategy();\n        _transfer(pool, _availableUnderlying());\n    }\n\n    /**\n     * @notice Withdraws specified amount of underlying from reserve to vault.\n     * @dev Withdraws from reserve will cause a spike in pool exchange rate.\n     *  Pool deposits should be paused during this to prevent front running\n     * @param amount Amount to withdraw.\n     */\n    function withdrawFromReserve(uint256 amount) external override onlyGovernance {\n        require(amount > 0, Error.INVALID_AMOUNT);\n        require(IPausable(pool).isPaused(), Error.POOL_NOT_PAUSED);\n        uint256 reserveBalance_ = reserve.getBalance(address(this), getUnderlying());\n        require(amount <= reserveBalance_, Error.INSUFFICIENT_BALANCE);\n        reserve.withdraw(getUnderlying(), amount);\n    }\n\n    /**\n     * @notice Activate the current strategy set for the vault.\n     * @return `true` if strategy has been activated\n     */\n    function activateStrategy() external onlyGovernance returns (bool) {\n        return _activateStrategy();\n    }\n\n    /**\n     * @notice Deactivates a strategy.\n     * @return `true` if strategy has been deactivated\n     */\n    function deactivateStrategy() external onlyGovernance returns (bool) {\n        return _deactivateStrategy();\n    }\n\n    /**\n     * @notice Initializes the vault's strategy.\n     * @dev Bypasses the time delay, but can only be called if strategy is not set already.\n     * @param strategy_ Address of the strategy.\n     * @return `true` if successful.\n     */\n    function initializeStrategy(address strategy_) external override onlyGovernance returns (bool) {\n        require(currentAddresses[_STRATEGY_KEY] == address(0), Error.ADDRESS_ALREADY_SET);\n        require(strategy_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        _setConfig(_STRATEGY_KEY, strategy_);\n        _activateStrategy();\n        require(IStrategy(strategy_).strategist() != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        return true;\n    }\n\n    /**\n     * @notice Prepare update of the vault's strategy (with time delay enforced).\n     * @param newStrategy Address of the new strategy.\n     * @return `true` if successful.\n     */\n    function prepareNewStrategy(address newStrategy)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_STRATEGY_KEY, newStrategy, STRATEGY_DELAY);\n    }\n\n    /**\n     * @notice Execute strategy update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New strategy address.\n     */\n    function executeNewStrategy() external override returns (address) {\n        _executeDeadline(_STRATEGY_KEY);\n        IStrategy strategy = getStrategy();\n        if (address(strategy) != address(0)) {\n            _harvest();\n            strategy.shutdown();\n            strategy.withdrawAll();\n\n            // there might still be some balance left if the strategy did not\n            // manage to withdraw all funds (e.g. due to locking)\n            uint256 remainingStrategyBalance = strategy.balance();\n            if (remainingStrategyBalance > 0) {\n                _strategiesWaitingForRemoval.set(address(strategy), remainingStrategyBalance);\n                waitingForRemovalAllocated += remainingStrategyBalance;\n            }\n        }\n        _deactivateStrategy();\n        currentAllocated = 0;\n        totalDebt = 0;\n        address newStrategy = pendingAddresses[_STRATEGY_KEY];\n        _setConfig(_STRATEGY_KEY, newStrategy);\n\n        if (newStrategy != address(0)) {\n            _activateStrategy();\n        }\n\n        return newStrategy;\n    }\n\n    function resetNewStrategy() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_STRATEGY_KEY);\n    }\n\n    /**\n     * @notice Prepare update of performance fee (with time delay enforced).\n     * @param newPerformanceFee New performance fee value.\n     * @return `true` if successful.\n     */\n    function preparePerformanceFee(uint256 newPerformanceFee)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(newPerformanceFee <= MAX_PERFORMANCE_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_PERFORMANCE_FEE_KEY, newPerformanceFee);\n    }\n\n    /**\n     * @notice Execute update of performance fee (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New performance fee.\n     */\n    function executePerformanceFee() external returns (uint256) {\n        return _executeUInt256(_PERFORMANCE_FEE_KEY);\n    }\n\n    function resetPerformanceFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_PERFORMANCE_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare update of strategist fee (with time delay enforced).\n     * @param newStrategistFee New strategist fee value.\n     * @return `true` if successful.\n     */\n    function prepareStrategistFee(uint256 newStrategistFee) external onlyGovernance returns (bool) {\n        _checkFeesInvariant(getReserveFee(), newStrategistFee);\n        return _prepare(_STRATEGIST_FEE_KEY, newStrategistFee);\n    }\n\n    /**\n     * @notice Execute update of strategist fee (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New strategist fee.\n     */\n    function executeStrategistFee() external returns (uint256) {\n        uint256 newStrategistFee = _executeUInt256(_STRATEGIST_FEE_KEY);\n        _checkFeesInvariant(getReserveFee(), newStrategistFee);\n        return newStrategistFee;\n    }\n\n    function resetStrategistFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_STRATEGIST_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare update of debt limit (with time delay enforced).\n     * @param newDebtLimit New debt limit.\n     * @return `true` if successful.\n     */\n    function prepareDebtLimit(uint256 newDebtLimit) external onlyGovernance returns (bool) {\n        return _prepare(_DEBT_LIMIT_KEY, newDebtLimit);\n    }\n\n    /**\n     * @notice Execute update of debt limit (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New debt limit.\n     */\n    function executeDebtLimit() external returns (uint256) {\n        uint256 debtLimit = _executeUInt256(_DEBT_LIMIT_KEY);\n        uint256 debtLimitAllocated = currentAllocated.scaledMul(debtLimit);\n        if (totalDebt >= debtLimitAllocated) {\n            _handleExcessDebt();\n        }\n        return debtLimit;\n    }\n\n    function resetDebtLimit() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_DEBT_LIMIT_KEY);\n    }\n\n    /**\n     * @notice Prepare update of target allocation (with time delay enforced).\n     * @param newTargetAllocation New target allocation.\n     * @return `true` if successful.\n     */\n    function prepareTargetAllocation(uint256 newTargetAllocation)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_TARGET_ALLOCATION_KEY, newTargetAllocation);\n    }\n\n    /**\n     * @notice Execute update of target allocation (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New target allocation.\n     */\n    function executeTargetAllocation() external returns (uint256) {\n        uint256 targetAllocation = _executeUInt256(_TARGET_ALLOCATION_KEY);\n        _deposit();\n        return targetAllocation;\n    }\n\n    function resetTargetAllocation() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_TARGET_ALLOCATION_KEY);\n    }\n\n    /**\n     * @notice Prepare update of reserve fee (with time delay enforced).\n     * @param newReserveFee New reserve fee.\n     * @return `true` if successful.\n     */\n    function prepareReserveFee(uint256 newReserveFee) external onlyGovernance returns (bool) {\n        _checkFeesInvariant(newReserveFee, getStrategistFee());\n        return _prepare(_RESERVE_FEE_KEY, newReserveFee);\n    }\n\n    /**\n     * @notice Execute update of reserve fee (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New reserve fee.\n     */\n    function executeReserveFee() external returns (uint256) {\n        uint256 newReserveFee = _executeUInt256(_RESERVE_FEE_KEY);\n        _checkFeesInvariant(newReserveFee, getStrategistFee());\n        return newReserveFee;\n    }\n\n    function resetReserveFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_RESERVE_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare update of deviation bound for strategy allocation (with time delay enforced).\n     * @param newBound New deviation bound for target allocation.\n     * @return `true` if successful.\n     */\n    function prepareBound(uint256 newBound) external onlyGovernance returns (bool) {\n        require(newBound <= MAX_DEVIATION_BOUND, Error.INVALID_AMOUNT);\n        return _prepare(_BOUND_KEY, newBound);\n    }\n\n    /**\n     * @notice Execute update of deviation bound for strategy allocation (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New deviation bound.\n     */\n    function executeBound() external returns (uint256) {\n        uint256 bound = _executeUInt256(_BOUND_KEY);\n        _deposit();\n        return bound;\n    }\n\n    function resetBound() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_BOUND_KEY);\n    }\n\n    /**\n     * @notice Withdraws an amount of underlying from the strategy to the vault.\n     * @param amount Amount of underlying to withdraw.\n     * @return True if successful withdrawal.\n     */\n    function withdrawFromStrategy(uint256 amount) external onlyGovernance returns (bool) {\n        IStrategy strategy = getStrategy();\n        if (address(strategy) == address(0)) return false;\n        if (strategy.balance() < amount) return false;\n        uint256 oldBalance = _availableUnderlying();\n        strategy.withdraw(amount);\n        uint256 newBalance = _availableUnderlying();\n        currentAllocated -= newBalance - oldBalance;\n        return true;\n    }\n\n    function withdrawFromStrategyWaitingForRemoval(address strategy) external returns (uint256) {\n        (bool exists, uint256 allocated) = _strategiesWaitingForRemoval.tryGet(strategy);\n        require(exists, Error.STRATEGY_DOES_NOT_EXIST);\n\n        IStrategy strategy_ = IStrategy(strategy);\n\n        strategy_.harvest();\n        uint256 withdrawn = strategy_.withdrawAll();\n\n        uint256 _waitingForRemovalAllocated = waitingForRemovalAllocated;\n        if (withdrawn >= _waitingForRemovalAllocated) {\n            waitingForRemovalAllocated = 0;\n        } else {\n            waitingForRemovalAllocated = _waitingForRemovalAllocated - withdrawn;\n        }\n\n        if (withdrawn > allocated) {\n            uint256 profit = withdrawn - allocated;\n            uint256 strategistShare = _shareFees(profit.scaledMul(getPerformanceFee()));\n            if (strategistShare > 0) {\n                _payStrategist(strategistShare, strategy_.strategist());\n            }\n            allocated = 0;\n            emit Harvest(profit, 0);\n        } else {\n            allocated -= withdrawn;\n        }\n\n        if (strategy_.balance() == 0) {\n            _strategiesWaitingForRemoval.remove(address(strategy_));\n        } else {\n            _strategiesWaitingForRemoval.set(address(strategy_), allocated);\n        }\n\n        return withdrawn;\n    }\n\n    function getStrategiesWaitingForRemoval() external view returns (address[] memory) {\n        return _strategiesWaitingForRemoval.keysArray();\n    }\n\n    /**\n     * @notice Computes the total underlying of the vault: idle funds + allocated funds - debt\n     * @return Total amount of underlying.\n     */\n    function getTotalUnderlying() external view override returns (uint256) {\n        uint256 availableUnderlying_ = _availableUnderlying();\n\n        if (address(getStrategy()) == address(0)) {\n            return availableUnderlying_;\n        }\n\n        uint256 netUnderlying = availableUnderlying_ +\n            currentAllocated +\n            waitingForRemovalAllocated;\n        if (totalDebt <= netUnderlying) return netUnderlying - totalDebt;\n        return 0;\n    }\n\n    function getAllocatedToStrategyWaitingForRemoval(address strategy)\n        external\n        view\n        returns (uint256)\n    {\n        return _strategiesWaitingForRemoval.get(strategy);\n    }\n\n    /**\n     * @notice Withdraws all funds from strategy to vault.\n     * @dev Harvests profits before withdrawing. Deactivates strategy after withdrawing.\n     * @return `true` if successful.\n     */\n    function withdrawAllFromStrategy() public onlyPoolOrGovernance returns (bool) {\n        return _withdrawAllFromStrategy();\n    }\n\n    /**\n     * @notice Harvest profits from the vault's strategy.\n     * @dev Harvesting adds profits to the vault's balance and deducts fees.\n     *  No performance fees are charged on profit used to repay debt.\n     * @return `true` if successful.\n     */\n    function harvest() public onlyPoolOrMaintenance returns (bool) {\n        return _harvest();\n    }\n\n    /**\n     * @notice Returns the percentage of the performance fee that goes to the strategist.\n     */\n    function getStrategistFee() public view returns (uint256) {\n        return currentUInts256[_STRATEGIST_FEE_KEY];\n    }\n\n    function getStrategy() public view override returns (IStrategy) {\n        return IStrategy(currentAddresses[_STRATEGY_KEY]);\n    }\n\n    /**\n     * @notice Returns the percentage of the performance fee which is allocated to the vault reserve\n     */\n    function getReserveFee() public view returns (uint256) {\n        return currentUInts256[_RESERVE_FEE_KEY];\n    }\n\n    /**\n     * @notice Returns the fee charged on a strategy's generated profits.\n     * @dev The strategist is paid in LP tokens, while the remainder of the profit stays in the vault.\n     *      Default performance fee is set to 5% of harvested profits.\n     */\n    function getPerformanceFee() public view returns (uint256) {\n        return currentUInts256[_PERFORMANCE_FEE_KEY];\n    }\n\n    /**\n     * @notice Returns the allowed symmetric bound for target allocation (e.g. +- 5%)\n     */\n    function getBound() public view returns (uint256) {\n        return currentUInts256[_BOUND_KEY];\n    }\n\n    /**\n     * @notice The target percentage of total underlying funds to be allocated towards a strategy.\n     * @dev this is to reduce gas costs. Withdrawals first come from idle funds and can therefore\n     *      avoid unnecessary gas costs.\n     */\n    function getTargetAllocation() public view returns (uint256) {\n        return currentUInts256[_TARGET_ALLOCATION_KEY];\n    }\n\n    /**\n     * @notice The debt limit that the total debt of a strategy may not exceed.\n     */\n    function getDebtLimit() public view returns (uint256) {\n        return currentUInts256[_DEBT_LIMIT_KEY];\n    }\n\n    function getUnderlying() public view virtual override returns (address);\n\n    function _activateStrategy() internal returns (bool) {\n        IStrategy strategy = getStrategy();\n        if (address(strategy) == address(0)) return false;\n\n        strategyActive = true;\n        emit StrategyActivated(address(strategy));\n        _deposit();\n        return true;\n    }\n\n    function _harvest() internal returns (bool) {\n        IStrategy strategy = getStrategy();\n        if (address(strategy) == address(0)) {\n            return false;\n        }\n\n        strategy.harvest();\n\n        uint256 strategistShare = 0;\n\n        uint256 allocatedUnderlying = strategy.balance();\n        uint256 amountAllocated = currentAllocated;\n        uint256 currentDebt = totalDebt;\n\n        if (allocatedUnderlying > amountAllocated) {\n            // we made profits\n            uint256 profit = allocatedUnderlying - amountAllocated;\n\n            if (profit > currentDebt) {\n                if (currentDebt > 0) {\n                    profit -= currentDebt;\n                    currentDebt = 0;\n                }\n                (profit, strategistShare) = _shareProfit(profit);\n            } else {\n                currentDebt -= profit;\n            }\n            emit Harvest(profit, 0);\n        } else if (allocatedUnderlying < amountAllocated) {\n            // we made a loss\n            uint256 loss = amountAllocated - allocatedUnderlying;\n            currentDebt += loss;\n\n            // check debt limit and withdraw funds if exceeded\n            uint256 debtLimit = getDebtLimit();\n            uint256 debtLimitAllocated = amountAllocated.scaledMul(debtLimit);\n            if (currentDebt > debtLimitAllocated) {\n                currentDebt = _handleExcessDebt(currentDebt);\n            }\n            emit Harvest(0, loss);\n        } else {\n            // nothing to declare\n            return true;\n        }\n\n        totalDebt = currentDebt;\n        currentAllocated = strategy.balance();\n\n        if (strategistShare > 0) {\n            _payStrategist(strategistShare);\n        }\n\n        return true;\n    }\n\n    function _withdrawAllFromStrategy() internal returns (bool) {\n        IStrategy strategy = getStrategy();\n        if (address(strategy) == address(0)) return false;\n        _harvest();\n        uint256 oldBalance = _availableUnderlying();\n        strategy.withdrawAll();\n        uint256 newBalance = _availableUnderlying();\n        uint256 withdrawnAmount = newBalance - oldBalance;\n\n        currentAllocated = _computeNewAllocated(currentAllocated, withdrawnAmount);\n        _deactivateStrategy();\n        return true;\n    }\n\n    function _handleExcessDebt(uint256 currentDebt) internal returns (uint256) {\n        uint256 underlyingReserves = reserve.getBalance(address(this), getUnderlying());\n        if (currentDebt > underlyingReserves) {\n            _emergencyStop(underlyingReserves);\n        } else if (reserve.canWithdraw(address(this))) {\n            reserve.withdraw(getUnderlying(), currentDebt);\n            currentDebt = 0;\n            _deposit();\n        }\n        return currentDebt;\n    }\n\n    function _handleExcessDebt() internal {\n        uint256 currentDebt = totalDebt;\n        uint256 newDebt = _handleExcessDebt(totalDebt);\n        if (currentDebt != newDebt) {\n            totalDebt = newDebt;\n        }\n    }\n\n    /**\n     * @notice Invest the underlying money in the vault after a deposit from the pool is made.\n     * @dev After each deposit, the vault checks whether it needs to rebalance underlying funds allocated to strategy.\n     * If no strategy is set then all deposited funds will be idle.\n     */\n    function _deposit() internal {\n        if (!strategyActive) return;\n\n        uint256 allocatedUnderlying = getStrategy().balance();\n        uint256 totalUnderlying = _availableUnderlying() +\n            allocatedUnderlying +\n            waitingForRemovalAllocated;\n\n        if (totalUnderlying == 0) return;\n        _rebalance(totalUnderlying, allocatedUnderlying);\n    }\n\n    function _shareProfit(uint256 profit) internal returns (uint256, uint256) {\n        uint256 totalFeeAmount = profit.scaledMul(getPerformanceFee());\n        if (_availableUnderlying() < totalFeeAmount) {\n            getStrategy().withdraw(totalFeeAmount);\n        }\n        uint256 strategistShare = _shareFees(totalFeeAmount);\n\n        return ((profit - totalFeeAmount), strategistShare);\n    }\n\n    function _shareFees(uint256 totalFeeAmount) internal returns (uint256) {\n        uint256 strategistShare = totalFeeAmount.scaledMul(getStrategistFee());\n\n        uint256 reserveShare = totalFeeAmount.scaledMul(getReserveFee());\n        uint256 treasuryShare = totalFeeAmount - strategistShare - reserveShare;\n\n        _depositToReserve(reserveShare);\n        if (treasuryShare > 0) {\n            _depositToTreasury(treasuryShare);\n        }\n        return strategistShare;\n    }\n\n    function _emergencyStop(uint256 underlyingReserves) internal {\n        // debt limit exceeded: withdraw funds from strategy\n        uint256 withdrawn = getStrategy().withdrawAll();\n\n        uint256 actualDebt = _computeNewAllocated(currentAllocated, withdrawn);\n\n        if (reserve.canWithdraw(address(this))) {\n            // check if debt can be covered with reserve funds\n            if (underlyingReserves >= actualDebt) {\n                reserve.withdraw(getUnderlying(), actualDebt);\n            } else if (underlyingReserves > 0) {\n                // debt can not be covered with reserves\n                reserve.withdraw(getUnderlying(), underlyingReserves);\n            }\n        }\n\n        // too much money lost, stop the strategy\n        _deactivateStrategy();\n    }\n\n    /**\n     * @notice Deactivates a strategy. All positions of the strategy are exited.\n     * @return `true` if strategy has been deactivated\n     */\n    function _deactivateStrategy() internal returns (bool) {\n        if (!strategyActive) return false;\n\n        strategyActive = false;\n        emit StrategyDeactivated(address(getStrategy()));\n        return true;\n    }\n\n    function _payStrategist(uint256 amount) internal {\n        _payStrategist(amount, getStrategy().strategist());\n    }\n\n    function _payStrategist(uint256 amount, address strategist) internal virtual;\n\n    function _transfer(address to, uint256 amount) internal virtual;\n\n    function _depositToReserve(uint256 amount) internal virtual;\n\n    function _depositToTreasury(uint256 amount) internal virtual;\n\n    function _availableUnderlying() internal view virtual returns (uint256);\n\n    function _computeNewAllocated(uint256 allocated, uint256 withdrawn)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (allocated > withdrawn) {\n            return allocated - withdrawn;\n        }\n        return 0;\n    }\n\n    function _checkFeesInvariant(uint256 reserveFee, uint256 strategistFee) internal pure {\n        require(\n            reserveFee + strategistFee <= ScaledMath.ONE,\n            \"sum of strategist fee and reserve fee should be below 1\"\n        );\n    }\n\n    function _rebalance(uint256 totalUnderlying, uint256 allocatedUnderlying)\n        private\n        returns (bool)\n    {\n        if (!strategyActive) return false;\n        uint256 targetAllocation = getTargetAllocation();\n\n        IStrategy strategy = getStrategy();\n        uint256 bound = getBound();\n\n        uint256 target = totalUnderlying.scaledMul(targetAllocation);\n        uint256 upperBound = targetAllocation == 0 ? 0 : targetAllocation + bound;\n        upperBound = upperBound > ScaledMath.ONE ? ScaledMath.ONE : upperBound;\n        uint256 lowerBound = bound > targetAllocation ? 0 : targetAllocation - bound;\n        if (allocatedUnderlying > totalUnderlying.scaledMul(upperBound)) {\n            // withdraw funds from strategy\n            uint256 withdrawAmount = allocatedUnderlying - target;\n            strategy.withdraw(withdrawAmount);\n\n            currentAllocated = _computeNewAllocated(currentAllocated, withdrawAmount);\n        } else if (allocatedUnderlying < totalUnderlying.scaledMul(lowerBound)) {\n            // allocate more funds to strategy\n            uint256 depositAmount = target - allocatedUnderlying;\n            _transfer(address(strategy), depositAmount);\n            currentAllocated += depositAmount;\n            strategy.deposit();\n        }\n        return true;\n    }\n}\ncontract AddressProvider is IAddressProvider, AuthorizationBase, Initializable, Preparable {\n    using EnumerableMapping for EnumerableMapping.AddressToAddressMap;\n    using EnumerableMapping for EnumerableMapping.Bytes32ToUIntMap;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using EnumerableExtensions for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableMapping.AddressToAddressMap;\n    using EnumerableExtensions for EnumerableMapping.Bytes32ToUIntMap;\n    using AddressProviderMeta for AddressProviderMeta.Meta;\n\n    // LpToken -> stakerVault\n    EnumerableMapping.AddressToAddressMap internal _stakerVaults;\n\n    EnumerableSet.AddressSet internal _whiteListedFeeHandlers;\n\n    // value is encoded as (bool freezable, bool frozen)\n    EnumerableMapping.Bytes32ToUIntMap internal _addressKeyMetas;\n\n    EnumerableSet.AddressSet internal _actions; // list of all actions ever registered\n\n    EnumerableSet.AddressSet internal _vaults; // list of all active vaults\n\n    EnumerableMapping.AddressToAddressMap internal _tokenToPools;\n\n    constructor(address treasury) {\n        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, false);\n        _addressKeyMetas.set(AddressProviderKeys._TREASURY_KEY, meta.toUInt());\n        _setConfig(AddressProviderKeys._TREASURY_KEY, treasury);\n    }\n\n    function initialize(address roleManager) external initializer {\n        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true);\n        _addressKeyMetas.set(AddressProviderKeys._ROLE_MANAGER_KEY, meta.toUInt());\n        _setConfig(AddressProviderKeys._ROLE_MANAGER_KEY, roleManager);\n    }\n\n    function getKnownAddressKeys() external view returns (bytes32[] memory) {\n        return _addressKeyMetas.keysArray();\n    }\n\n    function addFeeHandler(address feeHandler) external onlyGovernance returns (bool) {\n        require(!_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_WHITELISTED);\n        _whiteListedFeeHandlers.add(feeHandler);\n        return true;\n    }\n\n    function removeFeeHandler(address feeHandler) external onlyGovernance returns (bool) {\n        require(_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_NOT_WHITELISTED);\n        _whiteListedFeeHandlers.remove(feeHandler);\n        return true;\n    }\n\n    /**\n     * @notice Adds action.\n     * @param action Address of action to add.\n     */\n    function addAction(address action) external onlyGovernance returns (bool) {\n        bool result = _actions.add(action);\n        if (result) {\n            emit ActionListed(action);\n        }\n        return result;\n    }\n\n    /**\n     * @notice Adds pool.\n     * @param pool Address of pool to add.\n     */\n    function addPool(address pool)\n        external\n        override\n        onlyRoles2(Roles.POOL_FACTORY, Roles.GOVERNANCE)\n    {\n        require(pool != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n\n        ILiquidityPool ipool = ILiquidityPool(pool);\n        address poolToken = ipool.getLpToken();\n        require(poolToken != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        if (_tokenToPools.set(poolToken, pool)) {\n            address vault = address(ipool.getVault());\n            if (vault != address(0)) {\n                _vaults.add(vault);\n            }\n            emit PoolListed(pool);\n        }\n    }\n\n    /**\n     * @notice Delists pool.\n     * @param pool Address of pool to delist.\n     * @return `true` if successful.\n     */\n    function removePool(address pool) external override onlyRole(Roles.CONTROLLER) returns (bool) {\n        address lpToken = ILiquidityPool(pool).getLpToken();\n        bool removed = _tokenToPools.remove(lpToken);\n        if (removed) {\n            address vault = address(ILiquidityPool(pool).getVault());\n            if (vault != address(0)) {\n                _vaults.remove(vault);\n            }\n            emit PoolDelisted(pool);\n        }\n\n        return removed;\n    }\n\n    /** Vault functions  */\n\n    /**\n     * @notice returns all the registered vaults\n     */\n    function allVaults() external view returns (address[] memory) {\n        return _vaults.toArray();\n    }\n\n    /**\n     * @notice returns the vault at the given index\n     */\n    function getVaultAtIndex(uint256 index) external view returns (address) {\n        return _vaults.at(index);\n    }\n\n    /**\n     * @notice returns the number of vaults\n     */\n    function vaultsCount() external view returns (uint256) {\n        return _vaults.length();\n    }\n\n    function isVault(address vault) external view returns (bool) {\n        return _vaults.contains(vault);\n    }\n\n    function updateVault(address previousVault, address newVault) external onlyRole(Roles.POOL) {\n        if (previousVault != address(0)) {\n            _vaults.remove(previousVault);\n        }\n        if (newVault != address(0)) {\n            _vaults.add(newVault);\n        }\n        emit VaultUpdated(previousVault, newVault);\n    }\n\n    /**\n     * @notice Returns the address for the given key\n     */\n    function getAddress(bytes32 key) public view returns (address) {\n        require(_addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);\n        return currentAddresses[key];\n    }\n\n    /**\n     * @notice Returns the address for the given key\n     * @dev if `checkExists` is true, it will fail if the key does not exist\n     */\n    function getAddress(bytes32 key, bool checkExists) public view returns (address) {\n        require(!checkExists || _addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);\n        return currentAddresses[key];\n    }\n\n    /**\n     * @notice returns the address metadata for the given key\n     */\n    function getAddressMeta(bytes32 key) public view returns (AddressProviderMeta.Meta memory) {\n        (bool exists, uint256 metadata) = _addressKeyMetas.tryGet(key);\n        require(exists, Error.ADDRESS_DOES_NOT_EXIST);\n        return AddressProviderMeta.fromUInt(metadata);\n    }\n\n    function initializeAddress(bytes32 key, address initialAddress) external {\n        initializeAddress(key, initialAddress, false);\n    }\n\n    /**\n     * @notice Initializes an address\n     * @param key Key to initialize\n     * @param initialAddress Address for `key`\n     */\n    function initializeAddress(\n        bytes32 key,\n        address initialAddress,\n        bool freezable\n    ) public override onlyGovernance {\n        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(freezable, false);\n        _initializeAddress(key, initialAddress, meta);\n    }\n\n    /**\n     * @notice Initializes and freezes address\n     * @param key Key to initialize\n     * @param initialAddress Address for `key`\n     */\n    function initializeAndFreezeAddress(bytes32 key, address initialAddress)\n        external\n        override\n        onlyGovernance\n    {\n        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true);\n        _initializeAddress(key, initialAddress, meta);\n    }\n\n    /**\n     * @notice Freezes a configuration key, making it immutable\n     * @param key Key to feeze\n     */\n    function freezeAddress(bytes32 key) external override onlyGovernance {\n        AddressProviderMeta.Meta memory meta = getAddressMeta(key);\n        require(!meta.frozen, Error.ADDRESS_FROZEN);\n        require(meta.freezable, Error.INVALID_ARGUMENT);\n        meta.frozen = true;\n        _addressKeyMetas.set(key, meta.toUInt());\n    }\n\n    /**\n     * @notice Prepare update of an address\n     * @param key Key to update\n     * @param newAddress New address for `key`\n     * @return `true` if successful.\n     */\n    function prepareAddress(bytes32 key, address newAddress)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        AddressProviderMeta.Meta memory meta = getAddressMeta(key);\n        require(!meta.frozen, Error.ADDRESS_FROZEN);\n        return _prepare(key, newAddress);\n    }\n\n    /**\n     * @notice Execute update of `key`\n     * @return New address.\n     */\n    function executeAddress(bytes32 key) external override returns (address) {\n        AddressProviderMeta.Meta memory meta = getAddressMeta(key);\n        require(!meta.frozen, Error.ADDRESS_FROZEN);\n        return _executeAddress(key);\n    }\n\n    /**\n     * @notice Reset `key`\n     * @return true if it was reset\n     */\n    function resetAddress(bytes32 key) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(key);\n    }\n\n    /**\n     * @notice Add a new staker vault and add it's lpGauge if set in vault.\n     * @dev This fails if the token of the staker vault is the token of an existing staker vault.\n     * @param stakerVault Vault to add.\n     * @return `true` if successful.\n     */\n    function addStakerVault(address stakerVault)\n        external\n        override\n        onlyRole(Roles.CONTROLLER)\n        returns (bool)\n    {\n        address token = IStakerVault(stakerVault).getToken();\n        require(token != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        require(!_stakerVaults.contains(token), Error.STAKER_VAULT_EXISTS);\n        _stakerVaults.set(token, stakerVault);\n        emit StakerVaultListed(stakerVault);\n        return true;\n    }\n\n    function isWhiteListedFeeHandler(address feeHandler) external view override returns (bool) {\n        return _whiteListedFeeHandlers.contains(feeHandler);\n    }\n\n    /**\n     * @notice Get the liquidity pool for a given token\n     * @dev Does not revert if the pool deos not exist\n     * @param token Token for which to get the pool.\n     * @return Pool address.\n     */\n    function safeGetPoolForToken(address token) external view override returns (address) {\n        (, address poolAddress) = _tokenToPools.tryGet(token);\n        return poolAddress;\n    }\n\n    /**\n     * @notice Get the liquidity pool for a given token\n     * @dev Reverts if the pool deos not exist\n     * @param token Token for which to get the pool.\n     * @return Pool address.\n     */\n    function getPoolForToken(address token) external view override returns (ILiquidityPool) {\n        (bool exists, address poolAddress) = _tokenToPools.tryGet(token);\n        require(exists, Error.ADDRESS_NOT_FOUND);\n        return ILiquidityPool(poolAddress);\n    }\n\n    /**\n     * @notice Get list of all action addresses.\n     * @return Array with action addresses.\n     */\n    function allActions() external view override returns (address[] memory) {\n        return _actions.toArray();\n    }\n\n    /**\n     * @notice Check whether an address is an action.\n     * @param action Address to check whether it is action.\n     * @return True if address is an action.\n     */\n    function isAction(address action) external view override returns (bool) {\n        return _actions.contains(action);\n    }\n\n    /**\n     * @notice Check whether an address is an pool.\n     * @param pool Address to check whether it is a pool.\n     * @return True if address is a pool.\n     */\n    function isPool(address pool) external view returns (bool) {\n        address lpToken = ILiquidityPool(pool).getLpToken();\n        (bool exists, address poolAddress) = _tokenToPools.tryGet(lpToken);\n        return exists && pool == poolAddress;\n    }\n\n    /**\n     * @notice Get list of all pool addresses.\n     * @return Array with pool addresses.\n     */\n    function allPools() external view override returns (address[] memory) {\n        return _tokenToPools.valuesArray();\n    }\n\n    /**\n     * @notice returns the pool at the given index\n     */\n    function getPoolAtIndex(uint256 index) external view returns (address) {\n        return _tokenToPools.valueAt(index);\n    }\n\n    /**\n     * @notice returns the number of pools\n     */\n    function poolsCount() external view returns (uint256) {\n        return _tokenToPools.length();\n    }\n\n    /**\n     * @notice Returns all the staker vaults.\n     */\n    function allStakerVaults() external view override returns (address[] memory) {\n        return _stakerVaults.valuesArray();\n    }\n\n    /**\n     * @notice Get the staker vault for a given token\n     * @dev There can only exist one staker vault per unique token.\n     * @param token Token for which to get the vault.\n     * @return Vault address.\n     */\n    function getStakerVault(address token) external view override returns (address) {\n        return _stakerVaults.get(token);\n    }\n\n    /**\n     * @notice Tries to get the staker vault for a given token but does not throw if it does not exist\n     * @return A boolean set to true if the vault exists and the vault address.\n     */\n    function tryGetStakerVault(address token) external view override returns (bool, address) {\n        return _stakerVaults.tryGet(token);\n    }\n\n    /**\n     * @notice Check if a vault is registered (exists).\n     * @param stakerVault Address of staker vault to check.\n     * @return `true` if registered, `false` if not.\n     */\n    function isStakerVaultRegistered(address stakerVault) external view override returns (bool) {\n        address token = IStakerVault(stakerVault).getToken();\n        return isStakerVault(stakerVault, token);\n    }\n\n    function isStakerVault(address stakerVault, address token) public view override returns (bool) {\n        (bool exists, address vault) = _stakerVaults.tryGet(token);\n        return exists && vault == stakerVault;\n    }\n\n    function _roleManager() internal view override returns (IRoleManager) {\n        return IRoleManager(getAddress(AddressProviderKeys._ROLE_MANAGER_KEY));\n    }\n\n    function _initializeAddress(\n        bytes32 key,\n        address initialAddress,\n        AddressProviderMeta.Meta memory meta\n    ) internal {\n        require(!_addressKeyMetas.contains(key), Error.INVALID_ARGUMENT);\n        _addKnownAddressKey(key, meta);\n        _setConfig(key, initialAddress);\n    }\n\n    function _addKnownAddressKey(bytes32 key, AddressProviderMeta.Meta memory meta) internal {\n        require(_addressKeyMetas.set(key, meta.toUInt()), Error.INVALID_ARGUMENT);\n        emit KnownAddressKeyAdded(key);\n    }\n}\ncontract VaultStorageV1 is VaultStorage {\n    /**\n     * @dev This is to avoid breaking contracts inheriting from `VaultStorage`\n     * such as `Erc20Vault`, especially if they have storage variables\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     * for more details\n     *\n     * A new field can be added using a new contract such as\n     *\n     * ```solidity\n     * contract VaultStorageV2 is VaultStorage {\n     *   uint256 someNewField;\n     *   uint256[49] private __gap;\n     * }\n     */\n    uint256[50] private __gap;\n}\ncontract StakerVault is IStakerVault, Authorization, Pausable, Initializable, Preparable {\n    using AddressProviderHelpers for IAddressProvider;\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n\n    bytes32 internal constant _LP_GAUGE = \"lpGauge\";\n\n    IController public immutable controller;\n\n    address public token;\n\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public actionLockedBalances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    // All the data fields required for the staking tracking\n    uint256 private _poolTotalStaked;\n\n    mapping(address => bool) public strategies;\n    uint256 public strategiesTotalStaked;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        require(address(_controller) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        controller = _controller;\n    }\n\n    function initialize(address _token) external override initializer {\n        token = _token;\n    }\n\n    function initializeLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {\n        require(currentAddresses[_LP_GAUGE] == address(0), Error.ROLE_EXISTS);\n        _setConfig(_LP_GAUGE, _lpGauge);\n        controller.inflationManager().addGaugeForVault(token);\n        return true;\n    }\n\n    function prepareLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {\n        _prepare(_LP_GAUGE, _lpGauge);\n        return true;\n    }\n\n    function executeLpGauge() external override onlyGovernance returns (bool) {\n        _executeAddress(_LP_GAUGE);\n        controller.inflationManager().addGaugeForVault(token);\n        return true;\n    }\n\n    /**\n     * @notice Registers an address as a strategy to be excluded from token accumulation.\n     * @dev This should be used is a strategy deposits into a stakerVault and should not get gov. tokens.\n     * @return `true` if success.\n     */\n    function addStrategy(address strategy) external override returns (bool) {\n        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);\n        strategies[strategy] = true;\n        return true;\n    }\n\n    /**\n     * @notice Transfer staked tokens to an account.\n     * @dev This is not an ERC20 transfer, as tokens are still owned by this contract, but fees get updated in the LP pool.\n     * @param account Address to transfer to.\n     * @param amount Amount to transfer.\n     * @return `true` if success.\n     */\n    function transfer(address account, uint256 amount) external override notPaused returns (bool) {\n        require(msg.sender != account, Error.SELF_TRANSFER_NOT_ALLOWED);\n        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);\n\n        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);\n        pool.handleLpTokenTransfer(msg.sender, account, amount);\n\n        balances[msg.sender] -= amount;\n        balances[account] += amount;\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(msg.sender);\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n\n        emit Transfer(msg.sender, account, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer staked tokens from src to dst.\n     * @dev This is not an ERC20 transfer, as tokens are still owned by this contract, but fees get updated in the LP pool.\n     * @param src Address to transfer from.\n     * @param dst Address to transfer to.\n     * @param amount Amount to transfer.\n     * @return `true` if success.\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external override notPaused returns (bool) {\n        /* Do not allow self transfers */\n        require(src != dst, Error.SAME_ADDRESS_NOT_ALLOWED);\n\n        address spender = msg.sender;\n\n        /* Get the allowance, infinite for the account owner */\n        uint256 startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = type(uint256).max;\n        } else {\n            startingAllowance = _allowances[src][spender];\n        }\n        require(startingAllowance >= amount, Error.INSUFFICIENT_BALANCE);\n\n        uint256 srcTokens = balances[src];\n        require(srcTokens >= amount, Error.INSUFFICIENT_BALANCE);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(src);\n            ILpGauge(lpGauge).userCheckpoint(dst);\n        }\n        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);\n        pool.handleLpTokenTransfer(src, dst, amount);\n\n        uint256 allowanceNew = startingAllowance - amount;\n        uint256 srcTokensNew = srcTokens - amount;\n        uint256 dstTokensNew = balances[dst] + amount;\n\n        /* Update token balances */\n        balances[src] = srcTokensNew;\n        balances[dst] = dstTokensNew;\n\n        /* Update allowance if necessary */\n        if (startingAllowance != type(uint256).max) {\n            _allowances[src][spender] = allowanceNew;\n        }\n        emit Transfer(src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Approve staked tokens for spender.\n     * @param spender Address to approve tokens for.\n     * @param amount Amount to approve.\n     * @return `true` if success.\n     */\n    function approve(address spender, uint256 amount) external override notPaused returns (bool) {\n        address src = msg.sender;\n        _allowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice If an action is registered and stakes funds, this updates the actionLockedBalances for the user.\n     * @param account Address that registered the action.\n     * @param amount Amount staked by the action.\n     * @return `true` if success.\n     */\n    function increaseActionLockedBalance(address account, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        require(controller.addressProvider().isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n        actionLockedBalances[account] += amount;\n        return true;\n    }\n\n    /**\n     * @notice If an action is executed/reset, this updates the actionLockedBalances for the user.\n     * @param account Address that registered the action.\n     * @param amount Amount executed/reset by the action.\n     * @return `true` if success.\n     */\n    function decreaseActionLockedBalance(address account, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        require(controller.addressProvider().isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n        if (actionLockedBalances[account] > amount) {\n            actionLockedBalances[account] -= amount;\n        } else {\n            actionLockedBalances[account] = 0;\n        }\n        return true;\n    }\n\n    function poolCheckpoint() external override returns (bool) {\n        if (currentAddresses[_LP_GAUGE] != address(0)) {\n            return ILpGauge(currentAddresses[_LP_GAUGE]).poolCheckpoint();\n        }\n        return false;\n    }\n\n    function getLpGauge() external view override returns (address) {\n        return currentAddresses[_LP_GAUGE];\n    }\n\n    function isStrategy(address user) external view override returns (bool) {\n        return strategies[user];\n    }\n\n    /**\n     * @notice Get the total amount of tokens that are staked by actions\n     * @return Total amount staked by actions\n     */\n    function getStakedByActions() external view override returns (uint256) {\n        address[] memory actions = controller.addressProvider().allActions();\n        uint256 total;\n        for (uint256 i = 0; i < actions.length; i++) {\n            total += balances[actions[i]];\n        }\n        return total;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function balanceOf(address account) external view override returns (uint256) {\n        return balances[account];\n    }\n\n    function getPoolTotalStaked() external view override returns (uint256) {\n        return _poolTotalStaked;\n    }\n\n    /**\n     * @notice Returns the total balance in the staker vault, including that locked in positions.\n     * @param account Account to query balance for.\n     * @return Total balance in staker vault for account.\n     */\n    function stakedAndActionLockedBalanceOf(address account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return balances[account] + actionLockedBalances[account];\n    }\n\n    function actionLockedBalanceOf(address account) external view override returns (uint256) {\n        return actionLockedBalances[account];\n    }\n\n    function decimals() external view returns (uint8) {\n        return IERC20Full(token).decimals();\n    }\n\n    function getToken() external view override returns (address) {\n        return token;\n    }\n\n    function unstake(uint256 amount) public override returns (bool) {\n        return unstakeFor(msg.sender, msg.sender, amount);\n    }\n\n    /**\n     * @notice Stake an amount of vault tokens.\n     * @param amount Amount of token to stake.\n     * @return `true` if success.\n     */\n    function stake(uint256 amount) public override returns (bool) {\n        return stakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Stake amount of vault token on behalf of another account.\n     * @param account Account for which tokens will be staked.\n     * @param amount Amount of token to stake.\n     * @return `true` if success.\n     */\n    function stakeFor(address account, uint256 amount) public override notPaused returns (bool) {\n        require(IERC20(token).balanceOf(msg.sender) >= amount, Error.INSUFFICIENT_BALANCE);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n\n        uint256 oldBal = IERC20(token).balanceOf(address(this));\n\n        if (msg.sender != account) {\n            ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);\n            pool.handleLpTokenTransfer(msg.sender, account, amount);\n        }\n\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal;\n        require(staked == amount, Error.INVALID_AMOUNT);\n        balances[account] += staked;\n\n        if (strategies[account]) {\n            strategiesTotalStaked += staked;\n        } else {\n            _poolTotalStaked += staked;\n        }\n        emit Staked(account, amount);\n        return true;\n    }\n\n    /**\n     * @notice Unstake tokens on behalf of another account.\n     * @dev Needs to be approved.\n     * @param src Account for which tokens will be unstaked.\n     * @param dst Account receiving the tokens.\n     * @param amount Amount of token to unstake/receive.\n     * @return `true` if success.\n     */\n    function unstakeFor(\n        address src,\n        address dst,\n        uint256 amount\n    ) public override returns (bool) {\n        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);\n        uint256 allowance_ = _allowances[src][msg.sender];\n        require(\n            src == msg.sender || allowance_ >= amount || address(pool) == msg.sender,\n            Error.UNAUTHORIZED_ACCESS\n        );\n        require(balances[src] >= amount, Error.INSUFFICIENT_BALANCE);\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(src);\n        }\n        uint256 oldBal = IERC20(token).balanceOf(address(this));\n\n        if (src != dst) {\n            pool.handleLpTokenTransfer(src, dst, amount);\n        }\n\n        IERC20(token).safeTransfer(dst, amount);\n\n        uint256 unstaked = oldBal - IERC20(token).balanceOf(address(this));\n\n        if (src != msg.sender && allowance_ != type(uint256).max && address(pool) != msg.sender) {\n            // update allowance\n            _allowances[src][msg.sender] -= unstaked;\n        }\n        balances[src] -= unstaked;\n\n        if (strategies[src]) {\n            strategiesTotalStaked -= unstaked;\n        } else {\n            _poolTotalStaked -= unstaked;\n        }\n        emit Unstaked(src, amount);\n        return true;\n    }\n\n    function _isAuthorizedToPause(address account) internal view override returns (bool) {\n        return _roleManager().hasRole(Roles.GOVERNANCE, account);\n    }\n}\nabstract contract Pausable {\n    bool public isPaused;\n\n    modifier notPaused() {\n        require(!isPaused, Error.CONTRACT_PAUSED);\n        _;\n    }\n\n    modifier onlyAuthorizedToPause() {\n        require(_isAuthorizedToPause(msg.sender), Error.UNAUTHORIZED_PAUSE);\n        _;\n    }\n\n    /**\n     * @notice Pause the contract.\n     * @return `true` if success.\n     */\n    function pause() external onlyAuthorizedToPause returns (bool) {\n        isPaused = true;\n        return true;\n    }\n\n    /**\n     * @notice Unpause the contract.\n     * @return `true` if success.\n     */\n    function unpause() external onlyAuthorizedToPause returns (bool) {\n        isPaused = false;\n        return true;\n    }\n\n    /**\n     * @notice Returns true if `account` is authorized to pause the contract\n     * @dev This should be implemented in contracts inheriting `Pausable`\n     * to provide proper access control\n     */\n    function _isAuthorizedToPause(address account) internal view virtual returns (bool);\n}\ncontract Erc20Pool is LiquidityPool, IErc20Pool {\n    using SafeERC20 for IERC20;\n\n    address private _underlying;\n\n    constructor(IController _controller) LiquidityPool(_controller) {}\n\n    function initialize(\n        string memory name_,\n        address underlying_,\n        uint256 depositCap_,\n        address vault_\n    ) public override returns (bool) {\n        require(underlying_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        _underlying = underlying_;\n        return _initialize(name_, depositCap_, vault_);\n    }\n\n    function getUnderlying() public view override returns (address) {\n        return _underlying;\n    }\n\n    function _doTransferIn(address from, uint256 amount) internal override {\n        require(msg.value == 0, Error.INVALID_VALUE);\n        IERC20(_underlying).safeTransferFrom(from, address(this), amount);\n    }\n\n    function _doTransferOut(address payable to, uint256 amount) internal override {\n        IERC20(_underlying).safeTransfer(to, amount);\n    }\n\n    function _getBalanceUnderlying() internal view override returns (uint256) {\n        return IERC20(_underlying).balanceOf(address(this));\n    }\n\n    function _getBalanceUnderlying(bool) internal view override returns (uint256) {\n        return _getBalanceUnderlying();\n    }\n}\nabstract contract AuthorizationBase {\n    /**\n     * @notice Only allows a sender with `role` to perform the given action\n     */\n    modifier onlyRole(bytes32 role) {\n        require(_roleManager().hasRole(role, msg.sender), Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    /**\n     * @notice Only allows a sender with GOVERNANCE role to perform the given action\n     */\n    modifier onlyGovernance() {\n        require(_roleManager().hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    /**\n     * @notice Only allows a sender with any of `roles` to perform the given action\n     */\n    modifier onlyRoles2(bytes32 role1, bytes32 role2) {\n        require(_roleManager().hasAnyRole(role1, role2, msg.sender), Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    /**\n     * @notice Only allows a sender with any of `roles` to perform the given action\n     */\n    modifier onlyRoles3(\n        bytes32 role1,\n        bytes32 role2,\n        bytes32 role3\n    ) {\n        require(\n            _roleManager().hasAnyRole(role1, role2, role3, msg.sender),\n            Error.UNAUTHORIZED_ACCESS\n        );\n        _;\n    }\n\n    function roleManager() external view virtual returns (IRoleManager) {\n        return _roleManager();\n    }\n\n    function _roleManager() internal view virtual returns (IRoleManager);\n}\ncontract Preparable is IPreparable {\n    uint256 private constant _MIN_DELAY = 3 days;\n\n    mapping(bytes32 => address) public pendingAddresses;\n    mapping(bytes32 => uint256) public pendingUInts256;\n\n    mapping(bytes32 => address) public currentAddresses;\n    mapping(bytes32 => uint256) public currentUInts256;\n\n    /**\n     * @dev Deadlines shares the same namespace regardless of the type\n     * of the pending variable so this needs to be enforced in the caller\n     */\n    mapping(bytes32 => uint256) public deadlines;\n\n    function _prepareDeadline(bytes32 key, uint256 delay) internal {\n        require(deadlines[key] == 0, Error.DEADLINE_NOT_ZERO);\n        require(delay >= _MIN_DELAY, Error.DELAY_TOO_SHORT);\n        deadlines[key] = block.timestamp + delay;\n    }\n\n    /**\n     * @notice Prepares an uint256 that should be commited to the contract\n     * after `_MIN_DELAY` elapsed\n     * @param value The value to prepare\n     * @return `true` if success.\n     */\n    function _prepare(\n        bytes32 key,\n        uint256 value,\n        uint256 delay\n    ) internal returns (bool) {\n        _prepareDeadline(key, delay);\n        pendingUInts256[key] = value;\n        emit ConfigPreparedNumber(key, value, delay);\n        return true;\n    }\n\n    /**\n     * @notice Same as `_prepare(bytes32,uint256,uint256)` but uses a default delay\n     */\n    function _prepare(bytes32 key, uint256 value) internal returns (bool) {\n        return _prepare(key, value, _MIN_DELAY);\n    }\n\n    /**\n     * @notice Prepares an address that should be commited to the contract\n     * after `_MIN_DELAY` elapsed\n     * @param value The value to prepare\n     * @return `true` if success.\n     */\n    function _prepare(\n        bytes32 key,\n        address value,\n        uint256 delay\n    ) internal returns (bool) {\n        _prepareDeadline(key, delay);\n        pendingAddresses[key] = value;\n        emit ConfigPreparedAddress(key, value, delay);\n        return true;\n    }\n\n    /**\n     * @notice Same as `_prepare(bytes32,address,uint256)` but uses a default delay\n     */\n    function _prepare(bytes32 key, address value) internal returns (bool) {\n        return _prepare(key, value, _MIN_DELAY);\n    }\n\n    /**\n     * @notice Reset a uint256 key\n     * @return `true` if success.\n     */\n    function _resetUInt256Config(bytes32 key) internal returns (bool) {\n        require(deadlines[key] != 0, Error.DEADLINE_NOT_ZERO);\n        deadlines[key] = 0;\n        pendingUInts256[key] = 0;\n        emit ConfigReset(key);\n        return true;\n    }\n\n    /**\n     * @notice Reset an address key\n     * @return `true` if success.\n     */\n    function _resetAddressConfig(bytes32 key) internal returns (bool) {\n        require(deadlines[key] != 0, Error.DEADLINE_NOT_ZERO);\n        deadlines[key] = 0;\n        pendingAddresses[key] = address(0);\n        emit ConfigReset(key);\n        return true;\n    }\n\n    /**\n     * @dev Checks the deadline of the key and reset it\n     */\n    function _executeDeadline(bytes32 key) internal {\n        uint256 deadline = deadlines[key];\n        require(block.timestamp >= deadline, Error.DEADLINE_NOT_REACHED);\n        require(deadline != 0, Error.DEADLINE_NOT_SET);\n        deadlines[key] = 0;\n    }\n\n    /**\n     * @notice Execute uint256 config update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return New value.\n     */\n    function _executeUInt256(bytes32 key) internal returns (uint256) {\n        _executeDeadline(key);\n        uint256 newValue = pendingUInts256[key];\n        _setConfig(key, newValue);\n        return newValue;\n    }\n\n    /**\n     * @notice Execute address config update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return New value.\n     */\n    function _executeAddress(bytes32 key) internal returns (address) {\n        _executeDeadline(key);\n        address newValue = pendingAddresses[key];\n        _setConfig(key, newValue);\n        return newValue;\n    }\n\n    function _setConfig(bytes32 key, address value) internal returns (address) {\n        address oldValue = currentAddresses[key];\n        currentAddresses[key] = value;\n        pendingAddresses[key] = address(0);\n        deadlines[key] = 0;\n        emit ConfigUpdatedAddress(key, oldValue, value);\n        return value;\n    }\n\n    function _setConfig(bytes32 key, uint256 value) internal returns (uint256) {\n        uint256 oldValue = currentUInts256[key];\n        currentUInts256[key] = value;\n        pendingUInts256[key] = 0;\n        deadlines[key] = 0;\n        emit ConfigUpdatedNumber(key, oldValue, value);\n        return value;\n    }\n}\nabstract contract LiquidityPool is\n    ILiquidityPool,\n    Authorization,\n    Preparable,\n    Pausable,\n    Initializable\n{\n    using AddressProviderHelpers for IAddressProvider;\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n\n    struct WithdrawalFeeMeta {\n        uint64 timeToWait;\n        uint64 feeRatio;\n        uint64 lastActionTimestamp;\n    }\n\n    bytes32 internal constant _VAULT_KEY = \"Vault\";\n    bytes32 internal constant _RESERVE_DEVIATION_KEY = \"ReserveDeviation\";\n    bytes32 internal constant _REQUIRED_RESERVES_KEY = \"RequiredReserves\";\n\n    bytes32 internal constant _MAX_WITHDRAWAL_FEE_KEY = \"MaxWithdrawalFee\";\n    bytes32 internal constant _MIN_WITHDRAWAL_FEE_KEY = \"MinWithdrawalFee\";\n    bytes32 internal constant _WITHDRAWAL_FEE_DECREASE_PERIOD_KEY = \"WithdrawalFeeDecreasePeriod\";\n\n    uint256 internal constant _INITIAL_RESERVE_DEVIATION = 0.005e18; // 0.5%\n    uint256 internal constant _INITIAL_FEE_DECREASE_PERIOD = 1 weeks;\n    uint256 internal constant _INITIAL_MAX_WITHDRAWAL_FEE = 0.03e18; // 3%\n\n    /**\n     * @notice even through admin votes and later governance, the withdrawal\n     * fee will never be able to go above this value\n     */\n    uint256 internal constant _MAX_WITHDRAWAL_FEE = 0.05e18;\n\n    /**\n     * @notice Keeps track of the withdrawal fees on a per-address basis\n     */\n    mapping(address => WithdrawalFeeMeta) public withdrawalFeeMetas;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    uint256 public depositCap;\n    IStakerVault public staker;\n    ILpToken public lpToken;\n    string public name;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        require(address(_controller) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        controller = IController(_controller);\n        addressProvider = IController(_controller).addressProvider();\n    }\n\n    /**\n     * @notice Deposit funds into liquidity pool and mint LP tokens in exchange.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @return The actual amount minted.\n     */\n    function deposit(uint256 depositAmount) external payable override returns (uint256) {\n        return depositFor(msg.sender, depositAmount, 0);\n    }\n\n    /**\n     * @notice Deposit funds into liquidity pool and mint LP tokens in exchange.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @param minTokenAmount Minimum amount of LP tokens that should be minted.\n     * @return The actual amount minted.\n     */\n    function deposit(uint256 depositAmount, uint256 minTokenAmount)\n        external\n        payable\n        override\n        returns (uint256)\n    {\n        return depositFor(msg.sender, depositAmount, minTokenAmount);\n    }\n\n    /**\n     * @notice Deposit funds into liquidity pool and stake LP Tokens in Staker Vault.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @param minTokenAmount Minimum amount of LP tokens that should be minted.\n     * @return The actual amount minted and staked.\n     */\n    function depositAndStake(uint256 depositAmount, uint256 minTokenAmount)\n        external\n        payable\n        override\n        returns (uint256)\n    {\n        uint256 amountMinted_ = depositFor(address(this), depositAmount, minTokenAmount);\n        staker.stakeFor(msg.sender, amountMinted_);\n        return amountMinted_;\n    }\n\n    /**\n     * @notice Withdraws all funds from vault.\n     * @dev Should be called in case of emergencies.\n     */\n    function withdrawAll() external override onlyGovernance {\n        getVault().withdrawAll();\n    }\n\n    function setLpToken(address _lpToken)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY)\n        returns (bool)\n    {\n        require(address(lpToken) == address(0), Error.ADDRESS_ALREADY_SET);\n        require(ILpToken(_lpToken).minter() == address(this), Error.INVALID_MINTER);\n        lpToken = ILpToken(_lpToken);\n        _approveStakerVaultSpendingLpTokens();\n        emit LpTokenSet(_lpToken);\n        return true;\n    }\n\n    /**\n     * @notice Checkpoint function to update a user's withdrawal fees on deposit and redeem\n     * @param from Address sending from\n     * @param to Address sending to\n     * @param amount Amount to redeem or deposit\n     */\n    function handleLpTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) external override {\n        require(\n            msg.sender == address(lpToken) || msg.sender == address(staker),\n            Error.UNAUTHORIZED_ACCESS\n        );\n        if (\n            addressProvider.isStakerVault(to, address(lpToken)) ||\n            addressProvider.isStakerVault(from, address(lpToken)) ||\n            addressProvider.isAction(to) ||\n            addressProvider.isAction(from)\n        ) {\n            return;\n        }\n\n        if (to != address(0)) {\n            _updateUserFeesOnDeposit(to, from, amount);\n        }\n    }\n\n    /**\n     * @notice Prepare update of required reserve ratio (with time delay enforced).\n     * @param _newRatio New required reserve ratio.\n     * @return `true` if success.\n     */\n    function prepareNewRequiredReserves(uint256 _newRatio) external onlyGovernance returns (bool) {\n        require(_newRatio <= ScaledMath.ONE, Error.INVALID_AMOUNT);\n        return _prepare(_REQUIRED_RESERVES_KEY, _newRatio);\n    }\n\n    /**\n     * @notice Execute required reserve ratio update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New required reserve ratio.\n     */\n    function executeNewRequiredReserves() external override returns (uint256) {\n        uint256 requiredReserveRatio = _executeUInt256(_REQUIRED_RESERVES_KEY);\n        _rebalanceVault();\n        return requiredReserveRatio;\n    }\n\n    /**\n     * @notice Reset the prepared required reserves.\n     * @return `true` if success.\n     */\n    function resetRequiredReserves() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_REQUIRED_RESERVES_KEY);\n    }\n\n    /**\n     * @notice Prepare update of reserve deviation ratio (with time delay enforced).\n     * @param newRatio New reserve deviation ratio.\n     * @return `true` if success.\n     */\n    function prepareNewReserveDeviation(uint256 newRatio) external onlyGovernance returns (bool) {\n        require(newRatio <= (ScaledMath.DECIMAL_SCALE * 50) / 100, Error.INVALID_AMOUNT);\n        return _prepare(_RESERVE_DEVIATION_KEY, newRatio);\n    }\n\n    /**\n     * @notice Execute reserve deviation ratio update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New reserve deviation ratio.\n     */\n    function executeNewReserveDeviation() external override returns (uint256) {\n        uint256 reserveDeviation = _executeUInt256(_RESERVE_DEVIATION_KEY);\n        _rebalanceVault();\n        return reserveDeviation;\n    }\n\n    /**\n     * @notice Reset the prepared reserve deviation.\n     * @return `true` if success.\n     */\n    function resetNewReserveDeviation() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_RESERVE_DEVIATION_KEY);\n    }\n\n    /**\n     * @notice Prepare update of min withdrawal fee (with time delay enforced).\n     * @param newFee New min withdrawal fee.\n     * @return `true` if success.\n     */\n    function prepareNewMinWithdrawalFee(uint256 newFee) external onlyGovernance returns (bool) {\n        _checkFeeInvariants(newFee, getMaxWithdrawalFee());\n        return _prepare(_MIN_WITHDRAWAL_FEE_KEY, newFee);\n    }\n\n    /**\n     * @notice Execute min withdrawal fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New withdrawal fee.\n     */\n    function executeNewMinWithdrawalFee() external returns (uint256) {\n        uint256 newFee = _executeUInt256(_MIN_WITHDRAWAL_FEE_KEY);\n        _checkFeeInvariants(newFee, getMaxWithdrawalFee());\n        return newFee;\n    }\n\n    /**\n     * @notice Reset the prepared min withdrawal fee\n     * @return `true` if success.\n     */\n    function resetNewMinWithdrawalFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MIN_WITHDRAWAL_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare update of max withdrawal fee (with time delay enforced).\n     * @param newFee New max withdrawal fee.\n     * @return `true` if success.\n     */\n    function prepareNewMaxWithdrawalFee(uint256 newFee) external onlyGovernance returns (bool) {\n        _checkFeeInvariants(getMinWithdrawalFee(), newFee);\n        return _prepare(_MAX_WITHDRAWAL_FEE_KEY, newFee);\n    }\n\n    /**\n     * @notice Execute max withdrawal fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New max withdrawal fee.\n     */\n    function executeNewMaxWithdrawalFee() external override returns (uint256) {\n        uint256 newFee = _executeUInt256(_MAX_WITHDRAWAL_FEE_KEY);\n        _checkFeeInvariants(getMinWithdrawalFee(), newFee);\n        return newFee;\n    }\n\n    /**\n     * @notice Reset the prepared max fee.\n     * @return `true` if success.\n     */\n    function resetNewMaxWithdrawalFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_WITHDRAWAL_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare update of withdrawal decrease fee period (with time delay enforced).\n     * @param newPeriod New withdrawal fee decrease period.\n     * @return `true` if success.\n     */\n    function prepareNewWithdrawalFeeDecreasePeriod(uint256 newPeriod)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY, newPeriod);\n    }\n\n    /**\n     * @notice Execute withdrawal fee decrease period update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New withdrawal fee decrease period.\n     */\n    function executeNewWithdrawalFeeDecreasePeriod() external returns (uint256) {\n        return _executeUInt256(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY);\n    }\n\n    /**\n     * @notice Reset the prepared withdrawal fee decrease period update.\n     * @return `true` if success.\n     */\n    function resetNewWithdrawalFeeDecreasePeriod() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY);\n    }\n\n    /**\n     * @notice Set the staker vault for this pool's LP token\n     * @dev Staker vault and LP token pairs are immutable and the staker vault can only be set once for a pool.\n     *      Only one vault exists per LP token. This information will be retrieved from the controller of the pool.\n     * @return Address of the new staker vault for the pool.\n     */\n    function setStaker()\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY)\n        returns (bool)\n    {\n        require(address(staker) == address(0), Error.ADDRESS_ALREADY_SET);\n        address stakerVault = addressProvider.getStakerVault(address(lpToken));\n        require(stakerVault != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        staker = IStakerVault(stakerVault);\n        _approveStakerVaultSpendingLpTokens();\n        emit StakerVaultSet(stakerVault);\n        return true;\n    }\n\n    /**\n     * @notice Prepare setting a new Vault (with time delay enforced).\n     * @param _vault Address of new Vault contract.\n     * @return `true` if success.\n     */\n    function prepareNewVault(address _vault) external override onlyGovernance returns (bool) {\n        _prepare(_VAULT_KEY, _vault);\n        return true;\n    }\n\n    /**\n     * @notice Execute Vault update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return Address of new Vault contract.\n     */\n    function executeNewVault() external override returns (address) {\n        IVault vault = getVault();\n        if (address(vault) != address(0)) {\n            vault.withdrawAll();\n        }\n        address newVault = _executeAddress(_VAULT_KEY);\n        addressProvider.updateVault(address(vault), newVault);\n        return newVault;\n    }\n\n    /**\n     * @notice Reset the vault deadline.\n     * @return `true` if success.\n     */\n    function resetNewVault() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_VAULT_KEY);\n    }\n\n    /**\n     * @notice Redeems the underlying asset by burning LP tokens.\n     * @param redeemLpTokens Number of tokens to burn for redeeming the underlying.\n     * @return Actual amount of the underlying redeemed.\n     */\n    function redeem(uint256 redeemLpTokens) external override returns (uint256) {\n        return redeem(redeemLpTokens, 0);\n    }\n\n    /**\n     * @notice Uncap the pool to remove the deposit limit.\n     * @return `true` if success.\n     */\n    function uncap() external override onlyGovernance returns (bool) {\n        require(isCapped(), Error.NOT_CAPPED);\n\n        depositCap = 0;\n        return true;\n    }\n\n    /**\n     * @notice Update the deposit cap value.\n     * @param _depositCap The maximum allowed deposits per address in the pool\n     * @return `true` if success.\n     */\n    function updateDepositCap(uint256 _depositCap) external override onlyGovernance returns (bool) {\n        require(isCapped(), Error.NOT_CAPPED);\n        require(depositCap != _depositCap, Error.SAME_AS_CURRENT);\n        require(_depositCap > 0, Error.INVALID_AMOUNT);\n\n        depositCap = _depositCap;\n        return true;\n    }\n\n    /**\n     * @notice Rebalance vault according to required underlying backing reserves.\n     */\n    function rebalanceVault() external onlyGovernance {\n        _rebalanceVault();\n    }\n\n    /**\n     * @notice Deposit funds for an address into liquidity pool and mint LP tokens in exchange.\n     * @param account Account to deposit for.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @return Actual amount minted.\n     */\n    function depositFor(address account, uint256 depositAmount)\n        external\n        payable\n        override\n        returns (uint256)\n    {\n        return depositFor(account, depositAmount, 0);\n    }\n\n    /**\n     * @notice Redeems the underlying asset by burning LP tokens, unstaking any LP tokens needed.\n     * @param redeemLpTokens Number of tokens to unstake and/or burn for redeeming the underlying.\n     * @param minRedeemAmount Minimum amount of underlying that should be received.\n     * @return Actual amount of the underlying redeemed.\n     */\n    function unstakeAndRedeem(uint256 redeemLpTokens, uint256 minRedeemAmount)\n        external\n        override\n        returns (uint256)\n    {\n        uint256 lpBalance_ = lpToken.balanceOf(msg.sender);\n        require(\n            lpBalance_ + staker.balanceOf(msg.sender) >= redeemLpTokens,\n            Error.INSUFFICIENT_BALANCE\n        );\n        if (lpBalance_ < redeemLpTokens) {\n            staker.unstakeFor(msg.sender, msg.sender, redeemLpTokens - lpBalance_);\n        }\n        return redeem(redeemLpTokens, minRedeemAmount);\n    }\n\n    /**\n     * @notice Returns the address of the LP token of this pool\n     * @return The address of the LP token\n     */\n    function getLpToken() external view override returns (address) {\n        return address(lpToken);\n    }\n\n    /**\n     * @notice Calculates the amount of LP tokens that need to be redeemed to get a certain amount of underlying (includes fees and exchange rate)\n     * @param account Address of the account redeeming.\n     * @param underlyingAmount The amount of underlying desired.\n     * @return Amount of LP tokens that need to be redeemed.\n     */\n    function calcRedeem(address account, uint256 underlyingAmount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(underlyingAmount > 0, Error.INVALID_AMOUNT);\n        ILpToken lpToken_ = lpToken;\n        require(lpToken_.balanceOf(account) > 0, Error.INSUFFICIENT_BALANCE);\n\n        uint256 currentExchangeRate = exchangeRate();\n        uint256 withoutFeesLpAmount = underlyingAmount.scaledDiv(currentExchangeRate);\n        if (withoutFeesLpAmount == lpToken_.totalSupply()) {\n            return withoutFeesLpAmount;\n        }\n\n        WithdrawalFeeMeta memory meta = withdrawalFeeMetas[account];\n\n        uint256 currentFeeRatio = 0;\n        if (!addressProvider.isAction(account)) {\n            currentFeeRatio = getNewCurrentFees(\n                meta.timeToWait,\n                meta.lastActionTimestamp,\n                meta.feeRatio\n            );\n        }\n        uint256 scalingFactor = currentExchangeRate.scaledMul((ScaledMath.ONE - currentFeeRatio));\n        uint256 neededLpTokens = underlyingAmount.scaledDivRoundUp(scalingFactor);\n\n        return neededLpTokens;\n    }\n\n    function getUnderlying() external view virtual override returns (address);\n\n    /**\n     * @notice Deposit funds for an address into liquidity pool and mint LP tokens in exchange.\n     * @param account Account to deposit for.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @param minTokenAmount Minimum amount of LP tokens that should be minted.\n     * @return Actual amount minted.\n     */\n    function depositFor(\n        address account,\n        uint256 depositAmount,\n        uint256 minTokenAmount\n    ) public payable override notPaused returns (uint256) {\n        uint256 rate = exchangeRate();\n\n        if (isCapped()) {\n            uint256 lpBalance = lpToken.balanceOf(account);\n            uint256 stakedAndLockedBalance = staker.stakedAndActionLockedBalanceOf(account);\n            uint256 currentUnderlyingBalance = (lpBalance + stakedAndLockedBalance).scaledMul(rate);\n            require(\n                currentUnderlyingBalance + depositAmount <= depositCap,\n                Error.EXCEEDS_DEPOSIT_CAP\n            );\n        }\n\n        _doTransferIn(msg.sender, depositAmount);\n        uint256 mintedLp = depositAmount.scaledDiv(rate);\n        require(mintedLp >= minTokenAmount, Error.INVALID_AMOUNT);\n\n        lpToken.mint(account, mintedLp);\n        _rebalanceVault();\n\n        if (msg.sender == account || address(this) == account) {\n            emit Deposit(msg.sender, depositAmount, mintedLp);\n        } else {\n            emit DepositFor(msg.sender, account, depositAmount, mintedLp);\n        }\n        return mintedLp;\n    }\n\n    /**\n     * @notice Redeems the underlying asset by burning LP tokens.\n     * @param redeemLpTokens Number of tokens to burn for redeeming the underlying.\n     * @param minRedeemAmount Minimum amount of underlying that should be received.\n     * @return Actual amount of the underlying redeemed.\n     */\n    function redeem(uint256 redeemLpTokens, uint256 minRedeemAmount)\n        public\n        override\n        returns (uint256)\n    {\n        require(redeemLpTokens > 0, Error.INVALID_AMOUNT);\n        ILpToken lpToken_ = lpToken;\n        require(lpToken_.balanceOf(msg.sender) >= redeemLpTokens, Error.INSUFFICIENT_BALANCE);\n\n        uint256 withdrawalFee = addressProvider.isAction(msg.sender)\n            ? 0\n            : getWithdrawalFee(msg.sender, redeemLpTokens);\n        uint256 redeemMinusFees = redeemLpTokens - withdrawalFee;\n        // Pay no fees on the last withdrawal (avoid locking funds in the pool)\n        if (redeemLpTokens == lpToken_.totalSupply()) {\n            redeemMinusFees = redeemLpTokens;\n        }\n        uint256 redeemUnderlying = redeemMinusFees.scaledMul(exchangeRate());\n        require(redeemUnderlying >= minRedeemAmount, Error.NOT_ENOUGH_FUNDS_WITHDRAWN);\n\n        _rebalanceVault(redeemUnderlying);\n\n        lpToken_.burn(msg.sender, redeemLpTokens);\n        _doTransferOut(payable(msg.sender), redeemUnderlying);\n        emit Redeem(msg.sender, redeemUnderlying, redeemLpTokens);\n        return redeemUnderlying;\n    }\n\n    /**\n     * @return the current required reserves ratio\n     */\n    function getRequiredReserveRatio() public view virtual returns (uint256) {\n        return currentUInts256[_REQUIRED_RESERVES_KEY];\n    }\n\n    /**\n     * @return the current maximum reserve deviation ratio\n     */\n    function getMaxReserveDeviationRatio() public view virtual returns (uint256) {\n        return currentUInts256[_RESERVE_DEVIATION_KEY];\n    }\n\n    /**\n     * @notice Returns the current minimum withdrawal fee\n     */\n    function getMinWithdrawalFee() public view returns (uint256) {\n        return currentUInts256[_MIN_WITHDRAWAL_FEE_KEY];\n    }\n\n    /**\n     * @notice Returns the current maximum withdrawal fee\n     */\n    function getMaxWithdrawalFee() public view returns (uint256) {\n        return currentUInts256[_MAX_WITHDRAWAL_FEE_KEY];\n    }\n\n    /**\n     * @notice Returns the current withdrawal fee decrease period\n     */\n    function getWithdrawalFeeDecreasePeriod() public view returns (uint256) {\n        return currentUInts256[_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY];\n    }\n\n    /**\n     * @return the current vault of the liquidity pool\n     */\n    function getVault() public view virtual override returns (IVault) {\n        return IVault(currentAddresses[_VAULT_KEY]);\n    }\n\n    /**\n     * @notice Compute current exchange rate of LP tokens to underlying scaled to 1e18.\n     * @dev Exchange rate means: underlying = LP token * exchangeRate\n     * @return Current exchange rate.\n     */\n    function exchangeRate() public view override returns (uint256) {\n        uint256 totalUnderlying_ = totalUnderlying();\n        uint256 totalSupply = lpToken.totalSupply();\n        if (totalSupply == 0 || totalUnderlying_ == 0) {\n            return ScaledMath.ONE;\n        }\n\n        return totalUnderlying_.scaledDiv(totalSupply);\n    }\n\n    /**\n     * @notice Compute total amount of underlying tokens for this pool.\n     * @return Total amount of underlying in pool.\n     */\n    function totalUnderlying() public view override returns (uint256) {\n        IVault vault = getVault();\n        uint256 balanceUnderlying = _getBalanceUnderlying();\n        if (address(vault) == address(0)) {\n            return balanceUnderlying;\n        }\n        uint256 investedUnderlying = vault.getTotalUnderlying();\n        return investedUnderlying + balanceUnderlying;\n    }\n\n    /**\n     * @notice Retuns if the pool has an active deposit limit\n     * @return `true` if there is currently a deposit limit\n     */\n    function isCapped() public view override returns (bool) {\n        return depositCap != 0;\n    }\n\n    /**\n     * @notice Returns the withdrawal fee for `account`\n     * @param account Address to get the withdrawal fee for\n     * @param amount Amount to calculate the withdrawal fee for\n     * @return Withdrawal fee in LP tokens\n     */\n    function getWithdrawalFee(address account, uint256 amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        WithdrawalFeeMeta memory meta = withdrawalFeeMetas[account];\n\n        if (lpToken.balanceOf(account) == 0) {\n            return 0;\n        }\n        uint256 currentFee = getNewCurrentFees(\n            meta.timeToWait,\n            meta.lastActionTimestamp,\n            meta.feeRatio\n        );\n        return amount.scaledMul(currentFee);\n    }\n\n    /**\n     * @notice Calculates the withdrawal fee a user would currently need to pay on currentBalance.\n     * @param timeToWait The total time to wait until the withdrawal fee reached the min. fee\n     * @param lastActionTimestamp Timestamp of the last fee update\n     * @param feeRatio Fees that would currently be paid on the user's entire balance\n     * @return Updated fee amount on the currentBalance\n     */\n    function getNewCurrentFees(\n        uint256 timeToWait,\n        uint256 lastActionTimestamp,\n        uint256 feeRatio\n    ) public view returns (uint256) {\n        uint256 timeElapsed = _getTime() - lastActionTimestamp;\n        uint256 minFeePercentage = getMinWithdrawalFee();\n        if (timeElapsed >= timeToWait) {\n            return minFeePercentage;\n        }\n        uint256 elapsedShare = timeElapsed.scaledDiv(timeToWait);\n        return feeRatio - (feeRatio - minFeePercentage).scaledMul(elapsedShare);\n    }\n\n    function _rebalanceVault() internal {\n        _rebalanceVault(0);\n    }\n\n    function _initialize(\n        string memory name_,\n        uint256 depositCap_,\n        address vault_\n    ) internal initializer returns (bool) {\n        name = name_;\n        depositCap = depositCap_;\n\n        _setConfig(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY, _INITIAL_FEE_DECREASE_PERIOD);\n        _setConfig(_MAX_WITHDRAWAL_FEE_KEY, _INITIAL_MAX_WITHDRAWAL_FEE);\n        _setConfig(_REQUIRED_RESERVES_KEY, ScaledMath.ONE);\n        _setConfig(_RESERVE_DEVIATION_KEY, _INITIAL_RESERVE_DEVIATION);\n        _setConfig(_VAULT_KEY, vault_);\n        return true;\n    }\n\n    function _approveStakerVaultSpendingLpTokens() internal {\n        address staker_ = address(staker);\n        address lpToken_ = address(lpToken);\n        if (staker_ == address(0) || lpToken_ == address(0)) return;\n        IERC20(lpToken_).safeApprove(staker_, type(uint256).max);\n    }\n\n    function _doTransferIn(address from, uint256 amount) internal virtual;\n\n    function _doTransferOut(address payable to, uint256 amount) internal virtual;\n\n    /**\n     * @dev Rebalances the pool's allocations to the vault\n     * @param underlyingToWithdraw Amount of underlying to withdraw such that after the withdrawal the pool and vault allocations are correctly balanced.\n     */\n    function _rebalanceVault(uint256 underlyingToWithdraw) internal {\n        IVault vault = getVault();\n\n        if (address(vault) == address(0)) return;\n        uint256 lockedLp = staker.getStakedByActions();\n        uint256 totalUnderlyingStaked = lockedLp.scaledMul(exchangeRate());\n\n        uint256 underlyingBalance = _getBalanceUnderlying(true);\n        uint256 maximumDeviation = totalUnderlyingStaked.scaledMul(getMaxReserveDeviationRatio());\n\n        uint256 nextTargetBalance = totalUnderlyingStaked.scaledMul(getRequiredReserveRatio());\n\n        if (\n            underlyingToWithdraw > underlyingBalance ||\n            (underlyingBalance - underlyingToWithdraw) + maximumDeviation < nextTargetBalance\n        ) {\n            uint256 requiredDeposits = nextTargetBalance + underlyingToWithdraw - underlyingBalance;\n            vault.withdraw(requiredDeposits);\n        } else {\n            uint256 nextBalance = underlyingBalance - underlyingToWithdraw;\n            if (nextBalance > nextTargetBalance + maximumDeviation) {\n                uint256 excessDeposits = nextBalance - nextTargetBalance;\n                _doTransferOut(payable(address(vault)), excessDeposits);\n                vault.deposit();\n            }\n        }\n    }\n\n    function _updateUserFeesOnDeposit(\n        address account,\n        address from,\n        uint256 amountAdded\n    ) internal {\n        WithdrawalFeeMeta storage meta = withdrawalFeeMetas[account];\n        uint256 balance = lpToken.balanceOf(account) +\n            staker.stakedAndActionLockedBalanceOf(account);\n        uint256 newCurrentFeeRatio = getNewCurrentFees(\n            meta.timeToWait,\n            meta.lastActionTimestamp,\n            meta.feeRatio\n        );\n        uint256 shareAdded = amountAdded.scaledDiv(amountAdded + balance);\n        uint256 shareExisting = ScaledMath.ONE - shareAdded;\n        uint256 feeOnDeposit;\n        if (from == address(0)) {\n            feeOnDeposit = getMaxWithdrawalFee();\n        } else {\n            WithdrawalFeeMeta storage fromMeta = withdrawalFeeMetas[from];\n            feeOnDeposit = getNewCurrentFees(\n                fromMeta.timeToWait,\n                fromMeta.lastActionTimestamp,\n                fromMeta.feeRatio\n            );\n        }\n\n        uint256 newFeeRatio = shareExisting.scaledMul(newCurrentFeeRatio) +\n            shareAdded.scaledMul(feeOnDeposit);\n\n        meta.feeRatio = uint64(newFeeRatio);\n        meta.timeToWait = uint64(getWithdrawalFeeDecreasePeriod());\n        meta.lastActionTimestamp = uint64(_getTime());\n    }\n\n    function _getBalanceUnderlying() internal view virtual returns (uint256);\n\n    function _getBalanceUnderlying(bool transferInDone) internal view virtual returns (uint256);\n\n    function _isAuthorizedToPause(address account) internal view override returns (bool) {\n        return _roleManager().hasRole(Roles.GOVERNANCE, account);\n    }\n\n    /**\n     * @dev Overriden for testing\n     */\n    function _getTime() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    function _checkFeeInvariants(uint256 minFee, uint256 maxFee) internal pure {\n        require(maxFee >= minFee, Error.INVALID_AMOUNT);\n        require(maxFee <= _MAX_WITHDRAWAL_FEE, Error.INVALID_AMOUNT);\n    }\n}\n",
    "bin": []
}