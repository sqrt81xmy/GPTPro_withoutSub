{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/123",
    "external_functions": [
        [
            "IStaker"
        ],
        [
            "AuraToken",
            "IStaker"
        ],
        [
            "AuraBalRewardPool",
            "IERC20",
            "IAuraLocker"
        ],
        [
            "IBasicRewards"
        ],
        [
            "AuraClaimZap",
            "IBasicRewards",
            "IERC20",
            "IAuraLocker",
            "ICrvDepositorWrapper"
        ],
        [
            "IRewardStaking"
        ],
        [
            "AuraLocker",
            "IRewardStaking"
        ],
        [],
        [],
        [],
        [],
        [
            "AuraMerkleDrop",
            "IERC20",
            "IAuraLocker"
        ],
        [
            "AuraStakingProxy",
            "IERC20",
            "ICrvDepositorWrapper",
            "IAuraLocker"
        ],
        [
            "AuraVestedEscrow",
            "IAuraLocker"
        ],
        [
            "ICrvDepositor"
        ],
        [
            "BalInvestor",
            "IVault",
            "IPriceOracle"
        ],
        [
            "CrvDepositorWrapper",
            "IVault",
            "IPriceOracle",
            "IERC20",
            "ICrvDepositor"
        ],
        [
            "ExtraRewardsDistributor",
            "IAuraLocker"
        ]
    ],
    "new_contract": "contract AuraBalRewardPool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable rewardToken;\n    IERC20 public immutable stakingToken;\n    uint256 public constant duration = 14 days;\n\n    address public immutable rewardManager;\n\n    IAuraLocker public immutable auraLocker;\n    address public immutable penaltyForwarder;\n    uint256 public pendingPenalty = 0;\n    uint256 public immutable startTime;\n\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward, bool locked);\n    event PenaltyForwarded(uint256 amount);\n\n    /**\n     * @dev Simple constructoor\n     * @param _stakingToken  Pool LP token\n     * @param _rewardToken   $AURA\n     * @param _rewardManager Depositor\n     * @param _auraLocker    $AURA lock contract\n     * @param _penaltyForwarder Address to which penalties are sent\n     */\n    constructor(\n        address _stakingToken,\n        address _rewardToken,\n        address _rewardManager,\n        address _auraLocker,\n        address _penaltyForwarder,\n        uint256 _startDelay\n    ) {\n        stakingToken = IERC20(_stakingToken);\n        rewardToken = IERC20(_rewardToken);\n        rewardManager = _rewardManager;\n        auraLocker = IAuraLocker(_auraLocker);\n        penaltyForwarder = _penaltyForwarder;\n        rewardToken.safeApprove(_auraLocker, type(uint256).max);\n\n        require(_startDelay < 2 weeks, \"!delay\");\n        startTime = block.timestamp + _startDelay;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return AuraMath.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(\n                rewards[account]\n            );\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(msg.sender, _amount);\n\n        return true;\n    }\n\n    function stakeAll() external returns (bool) {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n        return true;\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //give to _for\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n\n        return true;\n    }\n\n    function withdraw(\n        uint256 amount,\n        bool claim,\n        bool lock\n    ) public updateReward(msg.sender) returns (bool) {\n        require(amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n\n        if (claim) {\n            getReward(lock);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Gives a staker their rewards\n     * @param _lock Lock the rewards? If false, takes a 20% haircut\n     */\n    function getReward(bool _lock) public updateReward(msg.sender) returns (bool) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            if (_lock) {\n                auraLocker.lock(msg.sender, reward);\n            } else {\n                uint256 penalty = (reward * 2) / 10;\n                pendingPenalty += penalty;\n                rewardToken.safeTransfer(msg.sender, reward - penalty);\n            }\n            emit RewardPaid(msg.sender, reward, _lock);\n        }\n        return true;\n    }\n\n    /**\n     * @dev Forwards to the penalty forwarder for distro to Aura Lockers\n     */\n    function forwardPenalty() public {\n        uint256 toForward = pendingPenalty;\n        pendingPenalty = 0;\n        rewardToken.safeTransfer(penaltyForwarder, toForward);\n        emit PenaltyForwarded(toForward);\n    }\n\n    /**\n     * @dev Called once to initialise the rewards based on balance of stakeToken\n     */\n    function initialiseRewards() external returns (bool) {\n        require(msg.sender == rewardManager || block.timestamp > startTime, \"!authorized\");\n        require(rewardRate == 0, \"!one time\");\n\n        uint256 rewardsAvailable = rewardToken.balanceOf(address(this));\n        require(rewardsAvailable > 0, \"!balance\");\n\n        rewardRate = rewardsAvailable.div(duration);\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n\n        emit RewardAdded(rewardsAvailable);\n\n        return true;\n    }\n}\ncontract AuraMerkleDrop {\n    using SafeERC20 for IERC20;\n\n    address public dao;\n    bytes32 public merkleRoot;\n\n    IERC20 public immutable aura;\n    IAuraLocker public auraLocker;\n\n    address public immutable penaltyForwarder;\n    uint256 public pendingPenalty = 0;\n\n    uint256 public startTime;\n    uint256 public immutable expiryTime;\n\n    mapping(address => bool) public hasClaimed;\n\n    event DaoSet(address newDao);\n    event RootSet(bytes32 newRoot);\n    event StartedEarly();\n    event ExpiredWithdrawn(uint256 amount);\n    event LockerSet(address newLocker);\n    event Claimed(address addr, uint256 amt, bool locked);\n    event PenaltyForwarded(uint256 amount);\n\n    /**\n     * @param _dao              The Aura Dao\n     * @param _merkleRoot       Merkle root\n     * @param _aura             Aura token\n     * @param _auraLocker       Aura locker contract\n     * @param _penaltyForwarder PenaltyForwarded contract\n     * @param _startDelay       Delay until claim is live\n     * @param _expiresAfter     Timestamp claim expires\n     */\n    constructor(\n        address _dao,\n        bytes32 _merkleRoot,\n        address _aura,\n        address _auraLocker,\n        address _penaltyForwarder,\n        uint256 _startDelay,\n        uint256 _expiresAfter\n    ) {\n        dao = _dao;\n        merkleRoot = _merkleRoot;\n        aura = IERC20(_aura);\n        auraLocker = IAuraLocker(_auraLocker);\n        penaltyForwarder = _penaltyForwarder;\n        startTime = block.timestamp + _startDelay;\n\n        require(_expiresAfter > 2 weeks, \"!expiry\");\n        expiryTime = startTime + _expiresAfter;\n    }\n\n    /***************************************\n                    CONFIG\n    ****************************************/\n\n    function setDao(address _newDao) external {\n        require(msg.sender == dao, \"!auth\");\n        dao = _newDao;\n        emit DaoSet(_newDao);\n    }\n\n    function setRoot(bytes32 _merkleRoot) external {\n        require(msg.sender == dao, \"!auth\");\n        require(merkleRoot == bytes32(0), \"already set\");\n        merkleRoot = _merkleRoot;\n        emit RootSet(_merkleRoot);\n    }\n\n    function startEarly() external {\n        require(msg.sender == dao, \"!auth\");\n        startTime = block.timestamp;\n        emit StartedEarly();\n    }\n\n    function withdrawExpired() external {\n        require(msg.sender == dao, \"!auth\");\n        require(block.timestamp > expiryTime, \"!expired\");\n        uint256 amt = aura.balanceOf(address(this));\n        aura.safeTransfer(dao, amt);\n        emit ExpiredWithdrawn(amt);\n    }\n\n    function setLocker(address _newLocker) external {\n        require(msg.sender == dao, \"!auth\");\n        auraLocker = IAuraLocker(_newLocker);\n        emit LockerSet(_newLocker);\n    }\n\n    /***************************************\n                    CLAIM\n    ****************************************/\n\n    function claim(\n        bytes32[] calldata _proof,\n        uint256 _amount,\n        bool _lock\n    ) public returns (bool) {\n        require(merkleRoot != bytes32(0), \"!root\");\n        require(block.timestamp > startTime, \"!started\");\n        require(block.timestamp < expiryTime, \"!active\");\n        require(_amount > 0, \"!amount\");\n        require(hasClaimed[msg.sender] == false, \"already claimed\");\n\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _amount));\n        require(MerkleProof.verify(_proof, merkleRoot, leaf), \"invalid proof\");\n\n        hasClaimed[msg.sender] = true;\n\n        if (_lock) {\n            aura.safeApprove(address(auraLocker), 0);\n            aura.safeApprove(address(auraLocker), _amount);\n            auraLocker.lock(msg.sender, _amount);\n        } else {\n            // If there is an address for auraLocker, and not locking, apply 20% penalty\n            uint256 penalty = address(auraLocker) == address(0) ? 0 : (_amount * 2) / 10;\n            pendingPenalty += penalty;\n            aura.safeTransfer(msg.sender, _amount - penalty);\n        }\n\n        emit Claimed(msg.sender, _amount, _lock);\n        return true;\n    }\n\n    /***************************************\n                    FORWARD\n    ****************************************/\n\n    function forwardPenalty() public {\n        uint256 toForward = pendingPenalty;\n        pendingPenalty = 0;\n        require(penaltyForwarder != address(0), \"!forwarder\");\n        aura.safeTransfer(penaltyForwarder, toForward);\n        emit PenaltyForwarded(toForward);\n    }\n}\nabstract contract BalInvestor {\n    using SafeERC20 for IERC20;\n\n    IVault public immutable BALANCER_VAULT;\n    address public immutable BAL;\n    address public immutable WETH;\n    address public immutable BALANCER_POOL_TOKEN;\n    bytes32 public immutable BAL_ETH_POOL_ID;\n\n    constructor(\n        IVault _balancerVault,\n        address _bal,\n        address _weth,\n        bytes32 _balETHPoolId\n    ) {\n        (\n            address poolAddress, /* */\n\n        ) = _balancerVault.getPool(_balETHPoolId);\n        require(poolAddress != address(0), \"!poolAddress\");\n\n        BALANCER_VAULT = _balancerVault;\n        BAL = _bal;\n        WETH = _weth;\n        BALANCER_POOL_TOKEN = poolAddress;\n        BAL_ETH_POOL_ID = _balETHPoolId;\n    }\n\n    function _setApprovals() internal {\n        IERC20(WETH).safeApprove(address(BALANCER_VAULT), type(uint256).max);\n        IERC20(BAL).safeApprove(address(BALANCER_VAULT), type(uint256).max);\n    }\n\n    function _getBptPrice() internal view returns (uint256) {\n        IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);\n\n        queries[0].variable = IPriceOracle.Variable.BPT_PRICE;\n        queries[0].secs = 3600; // last hour\n        queries[0].ago = 0; // now\n\n        // Gets the balancer time weighted average price denominated in BAL\n        return IPriceOracle(BALANCER_POOL_TOKEN).getTimeWeightedAverage(queries)[0];\n    }\n\n    function _getMinOut(uint256 amount, uint256 minOutBps) internal view returns (uint256) {\n        // Gets the balancer time weighted average price denominated in BAL\n        // e.g.  if 1 BAL == 0.4 BPT, bptOraclePrice == 2.5\n        uint256 bptOraclePrice = _getBptPrice();\n        // e.g. minOut = (((100e18 * 1e18) / 2.5e18) * 9980) / 10000;\n        // e.g. minout = 39.92e18\n        uint256 minOut = (((amount * 1e18) / bptOraclePrice) * minOutBps) / 10000;\n        return minOut;\n    }\n\n    function _investBalToPool(uint256 amount, uint256 minOut) internal {\n        IERC20(BAL).safeTransferFrom(msg.sender, address(this), amount);\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(BAL);\n        assets[1] = IAsset(WETH);\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = amount;\n        maxAmountsIn[1] = 0;\n\n        BALANCER_VAULT.joinPool(\n            BAL_ETH_POOL_ID,\n            address(this),\n            address(this),\n            IVault.JoinPoolRequest(\n                assets,\n                maxAmountsIn,\n                abi.encode(IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, maxAmountsIn, minOut),\n                false // Don't use internal balances\n            )\n        );\n    }\n}\ncontract AuraLocker is ReentrancyGuard, Ownable, IAuraLocker {\n    using AuraMath for uint256;\n    using AuraMath224 for uint224;\n    using AuraMath112 for uint112;\n    using AuraMath32 for uint32;\n    using SafeERC20 for IERC20;\n\n    /* ==========     STRUCTS     ========== */\n\n    struct RewardData {\n        /// Timestamp for current period finish\n        uint32 periodFinish;\n        /// Last time any user took action\n        uint32 lastUpdateTime;\n        /// RewardRate for the rest of the period\n        uint96 rewardRate;\n        /// Ever increasing rewardPerToken rate, based on % of total supply\n        uint96 rewardPerTokenStored;\n    }\n    struct UserData {\n        uint128 rewardPerTokenPaid;\n        uint128 rewards;\n    }\n    struct EarnedData {\n        address token;\n        uint256 amount;\n    }\n    struct Balances {\n        uint112 locked;\n        uint32 nextUnlockIndex;\n    }\n    struct LockedBalance {\n        uint112 amount;\n        uint32 unlockTime;\n    }\n    struct Epoch {\n        uint224 supply;\n        uint32 date; //epoch start date\n    }\n    struct DelegateeCheckpoint {\n        uint224 votes;\n        uint32 epochStart;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Rewards\n    address[] public rewardTokens;\n    uint256 public queuedCvxCrvRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    //     Core reward data\n    mapping(address => RewardData) public rewardData;\n    //     Reward token -> distributor -> is approved to add rewards\n    mapping(address => mapping(address => bool)) public rewardDistributors;\n    //     User -> reward token -> amount\n    mapping(address => mapping(address => UserData)) public userData;\n    //     Duration that rewards are streamed over\n    uint256 public constant rewardsDuration = 86400 * 7;\n    //     Duration of lock/earned penalty period\n    uint256 public constant lockDuration = rewardsDuration * 17;\n\n    // Balances\n    //     Supplies and historic supply\n    uint256 public lockedSupply;\n    //     Epochs contains only the tokens that were locked at that epoch, not a cumulative supply\n    Epoch[] public epochs;\n    //     Mappings for balance data\n    mapping(address => Balances) public balances;\n    mapping(address => LockedBalance[]) public userLocks;\n\n    // Voting\n    //     Stored delegations\n    mapping(address => address) private _delegates;\n    //     Checkpointed votes\n    mapping(address => DelegateeCheckpoint[]) private _checkpointedVotes;\n    //     Delegatee balances (user -> unlock timestamp -> amount)\n    mapping(address => mapping(uint256 => uint256)) public delegateeUnlocks;\n\n    // Config\n    //     Tokens\n    IERC20 public immutable stakingToken;\n    address public immutable cvxCrv;\n    //     Denom for calcs\n    uint256 public constant denominator = 10000;\n    //     Staking cvxCrv\n    address public immutable cvxcrvStaking;\n    //     Incentives\n    uint256 public kickRewardPerEpoch = 100;\n    uint256 public kickRewardEpochDelay = 3;\n    //     Shutdown\n    bool public isShutdown = false;\n\n    // Basic token data\n    string private _name;\n    string private _symbol;\n    uint8 private immutable _decimals;\n\n    /* ========== EVENTS ========== */\n\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    event DelegateCheckpointed(address indexed delegate);\n\n    event Recovered(address _token, uint256 _amount);\n    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);\n    event Staked(address indexed _user, uint256 _paidAmount, uint256 _lockedAmount);\n    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);\n    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);\n    event RewardAdded(address indexed _token, uint256 _reward);\n\n    event KickIncentiveSet(uint256 rate, uint256 delay);\n    event Shutdown();\n\n    /***************************************\n                    CONSTRUCTOR\n    ****************************************/\n\n    /**\n     * @param _nameArg          Token name, simples\n     * @param _symbolArg        Token symbol\n     * @param _stakingToken     CVX (0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)\n     * @param _cvxCrv           cvxCRV (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7)\n     * @param _cvxCrvStaking    cvxCRV rewards (0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e)\n     */\n    constructor(\n        string memory _nameArg,\n        string memory _symbolArg,\n        address _stakingToken,\n        address _cvxCrv,\n        address _cvxCrvStaking\n    ) Ownable() {\n        _name = _nameArg;\n        _symbol = _symbolArg;\n        _decimals = 18;\n\n        stakingToken = IERC20(_stakingToken);\n        cvxCrv = _cvxCrv;\n        cvxcrvStaking = _cvxCrvStaking;\n\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        epochs.push(Epoch({ supply: 0, date: uint32(currentEpoch) }));\n    }\n\n    /***************************************\n                    MODIFIER\n    ****************************************/\n\n    modifier updateReward(address _account) {\n        {\n            Balances storage userBalance = balances[_account];\n            uint256 rewardTokensLength = rewardTokens.length;\n            for (uint256 i = 0; i < rewardTokensLength; i++) {\n                address token = rewardTokens[i];\n                uint256 newRewardPerToken = _rewardPerToken(token);\n                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();\n                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(rewardData[token].periodFinish).to32();\n                if (_account != address(0)) {\n                    userData[_account][token] = UserData({\n                        rewardPerTokenPaid: newRewardPerToken.to128(),\n                        rewards: _earned(_account, token, userBalance.locked).to128()\n                    });\n                }\n            }\n        }\n        _;\n    }\n\n    /***************************************\n                    ADMIN\n    ****************************************/\n\n    // Add a new reward token to be distributed to stakers\n    function addReward(address _rewardsToken, address _distributor) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime == 0, \"Reward already exists\");\n        require(_rewardsToken != address(stakingToken), \"Cannot add StakingToken as reward\");\n        rewardTokens.push(_rewardsToken);\n        rewardData[_rewardsToken].lastUpdateTime = uint32(block.timestamp);\n        rewardData[_rewardsToken].periodFinish = uint32(block.timestamp);\n        rewardDistributors[_rewardsToken][_distributor] = true;\n    }\n\n    // Modify approval for an address to call notifyRewardAmount\n    function approveRewardDistributor(\n        address _rewardsToken,\n        address _distributor,\n        bool _approved\n    ) external onlyOwner {\n        require(rewardData[_rewardsToken].lastUpdateTime > 0, \"Reward does not exist\");\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\n    }\n\n    //set kick incentive\n    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {\n        require(_rate <= 500, \"over max rate\"); //max 5% per epoch\n        require(_delay >= 2, \"min delay\"); //minimum 2 epochs of grace\n        kickRewardPerEpoch = _rate;\n        kickRewardEpochDelay = _delay;\n\n        emit KickIncentiveSet(_rate, _delay);\n    }\n\n    //shutdown the contract. unstake all tokens. release all locks\n    function shutdown() external onlyOwner {\n        isShutdown = true;\n        emit Shutdown();\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\n        require(_tokenAddress != address(stakingToken), \"Cannot withdraw staking token\");\n        require(rewardData[_tokenAddress].lastUpdateTime == 0, \"Cannot withdraw reward token\");\n        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);\n        emit Recovered(_tokenAddress, _tokenAmount);\n    }\n\n    // Set approvals for staking cvx and cvxcrv\n    function setApprovals() external {\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);\n        IERC20(cvxCrv).safeApprove(cvxcrvStaking, type(uint256).max);\n    }\n\n    /***************************************\n                    ACTIONS\n    ****************************************/\n\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\n    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {\n        //pull tokens\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        //lock\n        _lock(_account, _amount);\n    }\n\n    //lock tokens\n    function _lock(address _account, uint256 _amount) internal {\n        require(_amount > 0, \"Cannot stake 0\");\n        require(!isShutdown, \"shutdown\");\n\n        Balances storage bal = balances[_account];\n\n        //must try check pointing epoch first\n        _checkpointEpoch();\n\n        //add user balances\n        uint112 lockAmount = _amount.to112();\n        bal.locked = bal.locked.add(lockAmount);\n\n        //add to total supplies\n        lockedSupply = lockedSupply.add(_amount);\n\n        //add user lock records or add to current\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 unlockTime = currentEpoch.add(lockDuration);\n        uint256 idx = userLocks[_account].length;\n        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {\n            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));\n        } else {\n            LockedBalance storage userL = userLocks[_account][idx - 1];\n            userL.amount = userL.amount.add(lockAmount);\n        }\n\n        address delegatee = delegates(_account);\n        if (delegatee != address(0)) {\n            delegateeUnlocks[delegatee][unlockTime] += lockAmount;\n            _checkpointDelegate(delegatee, lockAmount, 0);\n        }\n\n        //update epoch supply, epoch checkpointed above so safe to add to latest\n        Epoch storage e = epochs[epochs.length - 1];\n        e.supply = e.supply.add(lockAmount);\n\n        emit Staked(_account, lockAmount, lockAmount);\n    }\n\n    // claim all pending rewards\n    function getReward(address _account) external {\n        getReward(_account, false);\n    }\n\n    // Claim all pending rewards\n    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {\n        uint256 rewardTokensLength = rewardTokens.length;\n        for (uint256 i; i < rewardTokensLength; i++) {\n            address _rewardsToken = rewardTokens[i];\n            uint256 reward = userData[_account][_rewardsToken].rewards;\n            if (reward > 0) {\n                userData[_account][_rewardsToken].rewards = 0;\n                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {\n                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);\n                } else {\n                    IERC20(_rewardsToken).safeTransfer(_account, reward);\n                }\n                emit RewardPaid(_account, _rewardsToken, reward);\n            }\n        }\n    }\n\n    function checkpointEpoch() external {\n        _checkpointEpoch();\n    }\n\n    //insert a new epoch if needed. fill in any gaps\n    function _checkpointEpoch() internal {\n        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);\n        uint256 epochindex = epochs.length;\n\n        //first epoch add in constructor, no need to check 0 length\n        //check to add\n        if (epochs[epochindex - 1].date < currentEpoch) {\n            //fill any epoch gaps until the next epoch date.\n            while (epochs[epochs.length - 1].date != currentEpoch) {\n                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);\n                epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));\n            }\n        }\n    }\n\n    // Withdraw/relock all currently locked tokens where the unlock time has passed\n    function processExpiredLocks(bool _relock) external nonReentrant {\n        _processExpiredLocks(msg.sender, _relock, msg.sender, 0);\n    }\n\n    function kickExpiredLocks(address _account) external nonReentrant {\n        //allow kick after grace period of 'kickRewardEpochDelay'\n        _processExpiredLocks(_account, false, msg.sender, rewardsDuration.mul(kickRewardEpochDelay));\n    }\n\n    // Withdraw without checkpointing or accruing any rewards, providing system is shutdown\n    function emergencyWithdraw() external nonReentrant {\n        require(isShutdown, \"Must be shutdown\");\n\n        LockedBalance[] memory locks = userLocks[msg.sender];\n        Balances storage userBalance = balances[msg.sender];\n\n        uint256 amt = userBalance.locked;\n        require(amt > 0, \"Nothing locked\");\n\n        userBalance.locked = 0;\n        userBalance.nextUnlockIndex = locks.length.to32();\n        lockedSupply -= amt;\n\n        emit Withdrawn(msg.sender, amt, false);\n\n        stakingToken.safeTransfer(msg.sender, amt);\n    }\n\n    // Withdraw all currently locked tokens where the unlock time has passed\n    function _processExpiredLocks(\n        address _account,\n        bool _relock,\n        address _rewardAddress,\n        uint256 _checkDelay\n    ) internal updateReward(_account) {\n        LockedBalance[] storage locks = userLocks[_account];\n        Balances storage userBalance = balances[_account];\n        uint112 locked;\n        uint256 length = locks.length;\n        uint256 reward = 0;\n        uint256 expiryTime = _checkDelay == 0 && _relock\n            ? block.timestamp.add(rewardsDuration)\n            : block.timestamp.sub(_checkDelay);\n        require(length > 0, \"no locks\");\n        // e.g. now = 16\n        // if contract is shutdown OR latest lock unlock time (e.g. 17) <= now - (1)\n        // e.g. 17 <= (16 + 1)\n        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {\n            //if time is beyond last lock, can just bundle everything together\n            locked = userBalance.locked;\n\n            //dont delete, just set next index\n            userBalance.nextUnlockIndex = length.to32();\n\n            //check for kick reward\n            //this wont have the exact reward rate that you would get if looped through\n            //but this section is supposed to be for quick and easy low gas processing of all locks\n            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch\n            if (_checkDelay > 0) {\n                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);\n                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);\n                uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);\n                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);\n            }\n        } else {\n            //use a processed index(nextUnlockIndex) to not loop as much\n            //deleting does not change array length\n            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;\n            for (uint256 i = nextUnlockIndex; i < length; i++) {\n                //unlock time must be less or equal to time\n                if (locks[i].unlockTime > expiryTime) break;\n\n                //add to cumulative amounts\n                locked = locked.add(locks[i].amount);\n\n                //check for kick reward\n                //each epoch over due increases reward\n                if (_checkDelay > 0) {\n                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);\n                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);\n                    uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);\n                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));\n                }\n                //set next unlock index\n                nextUnlockIndex++;\n            }\n            //update next unlock index\n            userBalance.nextUnlockIndex = nextUnlockIndex;\n        }\n        require(locked > 0, \"no exp locks\");\n\n        //update user balances and total supplies\n        userBalance.locked = userBalance.locked.sub(locked);\n        lockedSupply = lockedSupply.sub(locked);\n\n        //checkpoint the delegatee\n        _checkpointDelegate(delegates(_account), 0, 0);\n\n        emit Withdrawn(_account, locked, _relock);\n\n        //send process incentive\n        if (reward > 0) {\n            //reduce return amount by the kick reward\n            locked = locked.sub(reward.to112());\n\n            //transfer reward\n            stakingToken.safeTransfer(_rewardAddress, reward);\n            emit KickReward(_rewardAddress, _account, reward);\n        }\n\n        //relock or return to user\n        if (_relock) {\n            _lock(_account, locked);\n        } else {\n            stakingToken.safeTransfer(_account, locked);\n        }\n    }\n\n    /***************************************\n            DELEGATION & VOTE BALANCE\n    ****************************************/\n\n    /**\n     * @dev Delegate votes from the sender to `newDelegatee`.\n     */\n    function delegate(address newDelegatee) external virtual nonReentrant {\n        // Step 1: Get lock data\n        LockedBalance[] storage locks = userLocks[msg.sender];\n        uint256 len = locks.length;\n        require(len > 0, \"Nothing to delegate\");\n        require(newDelegatee != address(0), \"Must delegate to someone\");\n\n        // Step 2: Update delegatee storage\n        address oldDelegatee = delegates(msg.sender);\n        require(newDelegatee != oldDelegatee, \"Must choose new delegatee\");\n        _delegates[msg.sender] = newDelegatee;\n\n        emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);\n\n        // Step 3: Move balances around\n        //         Delegate for the upcoming epoch\n        uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);\n        uint256 i = len - 1;\n        uint256 futureUnlocksSum = 0;\n        LockedBalance memory currentLock = locks[i];\n        // Step 3.1: Add future unlocks and sum balances\n        while (currentLock.unlockTime > upcomingEpoch) {\n            futureUnlocksSum += currentLock.amount;\n\n            if (oldDelegatee != address(0)) {\n                delegateeUnlocks[oldDelegatee][currentLock.unlockTime] -= currentLock.amount;\n            }\n            delegateeUnlocks[newDelegatee][currentLock.unlockTime] += currentLock.amount;\n\n            if (i > 0) {\n                i--;\n                currentLock = locks[i];\n            } else {\n                break;\n            }\n        }\n\n        // Step 3.2: Checkpoint old delegatee\n        _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);\n\n        // Step 3.3: Checkpoint new delegatee\n        _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);\n    }\n\n    function _checkpointDelegate(\n        address _account,\n        uint256 _upcomingAddition,\n        uint256 _upcomingDeduction\n    ) internal {\n        // This would only skip on first checkpointing\n        if (_account != address(0)) {\n            uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);\n            DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];\n            if (ckpts.length > 0) {\n                DelegateeCheckpoint memory prevCkpt = ckpts[ckpts.length - 1];\n                // If there has already been a record for the upcoming epoch, no need to deduct the unlocks\n                if (prevCkpt.epochStart == upcomingEpoch) {\n                    ckpts[ckpts.length - 1] = DelegateeCheckpoint({\n                        votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),\n                        epochStart: upcomingEpoch.to32()\n                    });\n                }\n                // else if it has been over 16 weeks since the previous checkpoint, all locks have since expired\n                // e.g. week 1 + 17 <= 18\n                else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {\n                    ckpts.push(\n                        DelegateeCheckpoint({\n                            votes: (_upcomingAddition - _upcomingDeduction).to224(),\n                            epochStart: upcomingEpoch.to32()\n                        })\n                    );\n                } else {\n                    uint256 nextEpoch = upcomingEpoch;\n                    uint256 unlocksSinceLatestCkpt = 0;\n                    // Should be maximum 18 iterations\n                    while (nextEpoch > prevCkpt.epochStart) {\n                        unlocksSinceLatestCkpt += delegateeUnlocks[_account][nextEpoch];\n                        nextEpoch -= rewardsDuration;\n                    }\n                    ckpts.push(\n                        DelegateeCheckpoint({\n                            votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)\n                                .to224(),\n                            epochStart: upcomingEpoch.to32()\n                        })\n                    );\n                }\n            } else {\n                ckpts.push(\n                    DelegateeCheckpoint({\n                        votes: (_upcomingAddition - _upcomingDeduction).to224(),\n                        epochStart: upcomingEpoch.to32()\n                    })\n                );\n            }\n            emit DelegateCheckpointed(_account);\n        }\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) external view returns (uint256) {\n        return getPastVotes(account, block.timestamp);\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) external view virtual returns (DelegateeCheckpoint memory) {\n        return _checkpointedVotes[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) external view virtual returns (uint32) {\n        return _checkpointedVotes[account].length.to32();\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     */\n    function getPastVotes(address account, uint256 timestamp) public view returns (uint256 votes) {\n        require(timestamp <= block.timestamp, \"ERC20Votes: block not yet mined\");\n        uint256 epoch = timestamp.div(rewardsDuration).mul(rewardsDuration);\n        DelegateeCheckpoint memory ckpt = _checkpointsLookup(_checkpointedVotes[account], epoch);\n        votes = ckpt.votes;\n        if (votes == 0 || ckpt.epochStart + lockDuration <= epoch) {\n            return 0;\n        }\n        while (epoch > ckpt.epochStart) {\n            votes -= delegateeUnlocks[account][epoch];\n            epoch -= rewardsDuration;\n        }\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `timestamp`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     */\n    function getPastTotalSupply(uint256 timestamp) external view returns (uint256) {\n        require(timestamp < block.timestamp, \"ERC20Votes: block not yet mined\");\n        return totalSupplyAtEpoch(findEpochId(timestamp));\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     *      Copied from oz/ERC20Votes.sol\n     */\n    function _checkpointsLookup(DelegateeCheckpoint[] storage ckpts, uint256 epochStart)\n        private\n        view\n        returns (DelegateeCheckpoint memory)\n    {\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = AuraMath.average(low, high);\n            if (ckpts[mid].epochStart > epochStart) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? DelegateeCheckpoint(0, 0) : ckpts[high - 1];\n    }\n\n    /***************************************\n                VIEWS - BALANCES\n    ****************************************/\n\n    // Balance of an account which only includes properly locked tokens as of the most recent eligible epoch\n    function balanceOf(address _user) external view returns (uint256 amount) {\n        return balanceAtEpochOf(findEpochId(block.timestamp), _user);\n    }\n\n    // Balance of an account which only includes properly locked tokens at the given epoch\n    function balanceAtEpochOf(uint256 _epoch, address _user) public view returns (uint256 amount) {\n        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));\n        require(epochStart < block.timestamp, \"Epoch is in the future\");\n\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n\n        LockedBalance[] storage locks = userLocks[_user];\n\n        //need to add up since the range could be in the middle somewhere\n        //traverse inversely to make more current queries more gas efficient\n        uint256 locksLength = locks.length;\n        for (uint256 i = locksLength; i > 0; i--) {\n            uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);\n            //lock epoch must be less or equal to the epoch we're basing from.\n            //also not include the current epoch\n            if (lockEpoch < epochStart) {\n                if (lockEpoch > cutoffEpoch) {\n                    amount = amount.add(locks[i - 1].amount);\n                } else {\n                    //stop now as no futher checks matter\n                    break;\n                }\n            }\n        }\n\n        return amount;\n    }\n\n    // Information on a user's locked balances\n    function lockedBalances(address _user)\n        external\n        view\n        returns (\n            uint256 total,\n            uint256 unlockable,\n            uint256 locked,\n            LockedBalance[] memory lockData\n        )\n    {\n        LockedBalance[] storage locks = userLocks[_user];\n        Balances storage userBalance = balances[_user];\n        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;\n        uint256 idx;\n        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {\n            if (locks[i].unlockTime > block.timestamp) {\n                if (idx == 0) {\n                    lockData = new LockedBalance[](locks.length - i);\n                }\n                lockData[idx] = locks[i];\n                idx++;\n                locked = locked.add(locks[i].amount);\n            } else {\n                unlockable = unlockable.add(locks[i].amount);\n            }\n        }\n        return (userBalance.locked, unlockable, locked, lockData);\n    }\n\n    // Supply of all properly locked balances at most recent eligible epoch\n    function totalSupply() external view returns (uint256 supply) {\n        return totalSupplyAtEpoch(findEpochId(block.timestamp));\n    }\n\n    // Supply of all properly locked balances at the given epoch\n    function totalSupplyAtEpoch(uint256 _epoch) public view returns (uint256 supply) {\n        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));\n        require(epochStart < block.timestamp, \"Epoch is in the future\");\n\n        uint256 cutoffEpoch = epochStart.sub(lockDuration);\n        uint256 lastIndex = epochs.length - 1;\n\n        uint256 epochIndex = _epoch > lastIndex ? lastIndex : _epoch;\n\n        for (uint256 i = epochIndex + 1; i > 0; i--) {\n            Epoch memory e = epochs[i - 1];\n            if (e.date == epochStart) {\n                continue;\n            } else if (e.date <= cutoffEpoch) {\n                break;\n            } else {\n                supply += e.supply;\n            }\n        }\n    }\n\n    // Get an epoch index based on timestamp\n    function findEpochId(uint256 _time) public view returns (uint256 epoch) {\n        return _time.sub(epochs[0].date).div(rewardsDuration);\n    }\n\n    /***************************************\n                VIEWS - GENERAL\n    ****************************************/\n\n    // Number of epochs\n    function epochCount() external view returns (uint256) {\n        return epochs.length;\n    }\n\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /***************************************\n                VIEWS - REWARDS\n    ****************************************/\n\n    // Address and claimable amount of all reward tokens for the given account\n    function claimableRewards(address _account) external view returns (EarnedData[] memory userRewards) {\n        userRewards = new EarnedData[](rewardTokens.length);\n        Balances storage userBalance = balances[_account];\n        uint256 userRewardsLength = userRewards.length;\n        for (uint256 i = 0; i < userRewardsLength; i++) {\n            address token = rewardTokens[i];\n            userRewards[i].token = token;\n            userRewards[i].amount = _earned(_account, token, userBalance.locked);\n        }\n        return userRewards;\n    }\n\n    function lastTimeRewardApplicable(address _rewardsToken) external view returns (uint256) {\n        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);\n    }\n\n    function rewardPerToken(address _rewardsToken) external view returns (uint256) {\n        return _rewardPerToken(_rewardsToken);\n    }\n\n    function _earned(\n        address _user,\n        address _rewardsToken,\n        uint256 _balance\n    ) internal view returns (uint256) {\n        UserData memory data = userData[_user][_rewardsToken];\n        return _balance.mul(_rewardPerToken(_rewardsToken).sub(data.rewardPerTokenPaid)).div(1e18).add(data.rewards);\n    }\n\n    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {\n        return AuraMath.min(block.timestamp, _finishTime);\n    }\n\n    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {\n        if (lockedSupply == 0) {\n            return rewardData[_rewardsToken].rewardPerTokenStored;\n        }\n        return\n            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(\n                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)\n                    .sub(rewardData[_rewardsToken].lastUpdateTime)\n                    .mul(rewardData[_rewardsToken].rewardRate)\n                    .mul(1e18)\n                    .div(lockedSupply)\n            );\n    }\n\n    /***************************************\n                REWARD FUNDING\n    ****************************************/\n\n    function queueNewRewards(uint256 _rewards) external nonReentrant {\n        require(rewardDistributors[cvxCrv][msg.sender], \"!authorized\");\n        require(_rewards > 0, \"No reward\");\n\n        RewardData storage rdata = rewardData[cvxCrv];\n\n        IERC20(cvxCrv).safeTransferFrom(msg.sender, address(this), _rewards);\n\n        _rewards = _rewards.add(queuedCvxCrvRewards);\n        if (block.timestamp >= rdata.periodFinish) {\n            _notifyReward(cvxCrv, _rewards);\n            queuedCvxCrvRewards = 0;\n            return;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(rdata.periodFinish.sub(rewardsDuration.to32()));\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rdata.rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            _notifyReward(cvxCrv, _rewards);\n            queuedCvxCrvRewards = 0;\n        } else {\n            queuedCvxCrvRewards = _rewards;\n        }\n    }\n\n    function notifyRewardAmount(address _rewardsToken, uint256 _reward) external {\n        require(_rewardsToken != cvxCrv, \"Use queueNewRewards\");\n        require(rewardDistributors[_rewardsToken][msg.sender], \"Must be rewardsDistributor\");\n        require(_reward > 0, \"No reward\");\n\n        _notifyReward(_rewardsToken, _reward);\n\n        // handle the transfer of reward tokens via `transferFrom` to reduce the number\n        // of transactions required and ensure correctness of the _reward amount\n        IERC20(_rewardsToken).safeTransferFrom(msg.sender, address(this), _reward);\n    }\n\n    function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {\n        RewardData storage rdata = rewardData[_rewardsToken];\n\n        if (block.timestamp >= rdata.periodFinish) {\n            rdata.rewardRate = _reward.div(rewardsDuration).to96();\n        } else {\n            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);\n            uint256 leftover = remaining.mul(rdata.rewardRate);\n            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();\n        }\n\n        rdata.lastUpdateTime = block.timestamp.to32();\n        rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();\n\n        emit RewardAdded(_rewardsToken, _reward);\n    }\n}\ncontract CrvDepositorWrapper is ICrvDepositorWrapper, BalInvestor {\n    address public immutable crvDeposit;\n\n    constructor(\n        address _crvDeposit,\n        IVault _balancerVault,\n        address _bal,\n        address _weth,\n        bytes32 _balETHPoolId\n    ) BalInvestor(_balancerVault, _bal, _weth, _balETHPoolId) {\n        crvDeposit = _crvDeposit;\n    }\n\n    function setApprovals() external {\n        _setApprovals();\n        require(IERC20(BALANCER_POOL_TOKEN).approve(crvDeposit, type(uint256).max), \"!approval\");\n    }\n\n    /**\n     * @dev Gets minimum output based on BPT oracle price\n     * @param _amount Units of BAL to deposit\n     * @param _outputBps Multiplier where 100% == 10000, 99.5% == 9950 and 98% == 9800\n     * @return minOut Units of BPT to expect as output\n     */\n    function getMinOut(uint256 _amount, uint256 _outputBps) external view returns (uint256) {\n        return _getMinOut(_amount, _outputBps);\n    }\n\n    function deposit(\n        uint256 _amount,\n        uint256 _minOut,\n        bool _lock,\n        address _stakeAddress\n    ) external {\n        _investBalToPool(_amount, _minOut);\n        uint256 bptBalance = IERC20(BALANCER_POOL_TOKEN).balanceOf(address(this));\n        ICrvDepositor(crvDeposit).depositFor(msg.sender, bptBalance, _lock, _stakeAddress);\n    }\n}\ncontract AuraToken is ERC20 {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using AuraMath for uint256;\n\n    address public operator;\n    address public immutable vecrvProxy;\n\n    uint256 public constant EMISSIONS_MAX_SUPPLY = 5e25; // 50m\n    uint256 public constant totalCliffs = 500;\n    uint256 public immutable reductionPerCliff;\n\n    address public minter;\n    uint256 private minterMinted = type(uint256).max;\n\n    /* ========== EVENTS ========== */\n\n    event Initialised();\n    event OperatorChanged(address indexed previousOperator, address indexed newOperator);\n\n    /**\n     * @param _proxy        CVX VoterProxy\n     * @param _nameArg      Token name\n     * @param _symbolArg    Token symbol\n     */\n    constructor(\n        address _proxy,\n        string memory _nameArg,\n        string memory _symbolArg\n    ) ERC20(_nameArg, _symbolArg) {\n        operator = msg.sender;\n        vecrvProxy = _proxy;\n        reductionPerCliff = EMISSIONS_MAX_SUPPLY.div(totalCliffs);\n    }\n\n    /**\n     * @dev Initialise and mints initial supply of tokens.\n     * @param _to        Target address to mint.\n     * @param _amount    Amount of tokens to mint.\n     * @param _minter    The minter address.\n     */\n    function init(\n        address _to,\n        uint256 _amount,\n        address _minter\n    ) external {\n        require(msg.sender == operator, \"Only operator\");\n        require(totalSupply() == 0, \"Only once\");\n        require(_amount > 0, \"Must mint something\");\n        require(_minter != address(0), \"Invalid minter\");\n\n        _mint(_to, _amount);\n        updateOperator();\n        minter = _minter;\n        minterMinted = 0;\n\n        emit Initialised();\n    }\n\n    /**\n     * @dev This can be called if the operator of the voterProxy somehow changes.\n     */\n    function updateOperator() public {\n        address newOperator = IStaker(vecrvProxy).operator();\n        emit OperatorChanged(operator, newOperator);\n        operator = newOperator;\n    }\n\n    /**\n     * @dev Mints AURA to a given user based on the BAL supply schedule.\n     */\n    function mint(address _to, uint256 _amount) external {\n        require(totalSupply() != 0, \"Not initialised\");\n\n        if (msg.sender != operator) {\n            // dont error just return. if a shutdown happens, rewards on old system\n            // can still be claimed, just wont mint cvx\n            return;\n        }\n\n        // e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;\n        uint256 emissionsMinted = totalSupply() - EMISSIONS_MAX_SUPPLY - minterMinted;\n        // e.g. reductionPerCliff = 5e25 / 500 = 1e23\n        // e.g. cliff = 1e25 / 1e23 = 100\n        uint256 cliff = emissionsMinted.div(reductionPerCliff);\n\n        // e.g. 100 < 500\n        if (cliff < totalCliffs) {\n            // e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;\n            // e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;\n            // e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;\n            uint256 reduction = totalCliffs.sub(cliff).mul(5).div(2).add(700);\n            // e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;\n            // e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;\n            // e.g. (new) amount = 1e19 * 950 / 500  =  19e17;\n            uint256 amount = _amount.mul(reduction).div(totalCliffs);\n            // e.g. amtTillMax = 5e25 - 1e25 = 4e25\n            uint256 amtTillMax = EMISSIONS_MAX_SUPPLY.sub(emissionsMinted);\n            if (amount > amtTillMax) {\n                amount = amtTillMax;\n            }\n            _mint(_to, amount);\n        }\n    }\n\n    /**\n     * @dev Allows minter to mint to a specific address\n     */\n    function minterMint(address _to, uint256 _amount) external {\n        require(msg.sender == minter, \"Only minter\");\n        minterMinted += _amount;\n        _mint(_to, _amount);\n    }\n}\ncontract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {\n    using SafeERC20 for IERC20;\n\n    IAuraLocker public immutable auraLocker;\n\n    // token -> epoch -> amount\n    mapping(address => mapping(uint256 => uint256)) public rewardData;\n    // token -> epochList\n    mapping(address => uint256[]) public rewardEpochs;\n    // token -> account -> last claimed epoch index\n    mapping(address => mapping(address => uint256)) public userClaims;\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);\n    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);\n    event RewardForfeited(address indexed user, address indexed token, uint256 index);\n\n    /**\n     * @dev Simple constructoor\n     * @param _auraLocker Aura Locker address\n     */\n    constructor(address _auraLocker) {\n        auraLocker = IAuraLocker(_auraLocker);\n    }\n\n    /* ========== ADD REWARDS ========== */\n\n    /**\n     * @notice Add a reward to the current epoch. can be called multiple times for the same reward token\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward token\u03c0\n     */\n    function addReward(address _token, uint256 _amount) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        _addReward(_token, _amount, latestEpoch);\n    }\n\n    /**\n     * @notice Add reward token to a specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens to add\n     * @param _epoch    Which epoch to add to (must be less than the previous epoch)\n     */\n    function addRewardToEpoch(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        require(_epoch <= latestEpoch, \"Cannot assign to the future\");\n\n        if (_epoch == latestEpoch) {\n            _addReward(_token, _amount, latestEpoch);\n        } else {\n            uint256 len = rewardEpochs[_token].length;\n            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, \"Cannot backdate to this epoch\");\n\n            _addReward(_token, _amount, _epoch);\n        }\n    }\n\n    /**\n     * @notice  Transfer reward tokens from sender to contract for vlCVX holders\n     * @dev     Add reward token for specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens\n     * @param _epoch    Epoch to add tokens to\n     */\n    function _addReward(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) internal nonReentrant {\n        // Pull before reward accrual\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        //convert to reward per token\n        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);\n        uint256 rPerT = (_amount * 1e20) / supply;\n        rewardData[_token][_epoch] += rPerT;\n\n        //add epoch to list\n        uint256 len = rewardEpochs[_token].length;\n        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {\n            rewardEpochs[_token].push(_epoch);\n        }\n\n        //event\n        emit RewardAdded(_token, _epoch, _amount);\n    }\n\n    /* ========== GET REWARDS ========== */\n\n    /**\n     * @notice Claim rewards for a specific token since the first epoch.\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function getReward(address _account, address _token) public {\n        _getReward(_account, _token, 0);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account      Address of vlCVX holder\n     * @param _token        Reward token address\n     * @param _startIndex   Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        _getReward(_account, _token, _startIndex);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        //get claimable tokens\n        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);\n\n        if (claimableTokens > 0) {\n            //set claim checkpoint\n            userClaims[_token][_account] = index;\n\n            //send\n            IERC20(_token).safeTransfer(_account, claimableTokens);\n\n            //event\n            emit RewardPaid(_account, _token, claimableTokens, index);\n        }\n    }\n\n    /**\n     * @notice  Allow a user to set their claimed index forward without claiming rewards\n     *          Because claims cycle through all periods that a specific reward was given\n     *          there becomes a situation where, for example, a new user could lock\n     *          2 years from now and try to claim a token that was given out every week prior.\n     *          This would result in a 2mil gas checkpoint.(about 20k gas * 52 weeks * 2 years)\n     * @param _token  Reward token to forfeit\n     * @param _index  Epoch index to forfeit from\n     */\n    function forfeitRewards(address _token, uint256 _index) external {\n        require(_index > 0 && _index < rewardEpochs[_token].length - 1, \"!past\");\n        require(_index >= userClaims[_token][msg.sender], \"already claimed\");\n\n        //set claim checkpoint. next claim starts from index+1\n        userClaims[_token][msg.sender] = _index + 1;\n\n        emit RewardForfeited(msg.sender, _token, _index);\n    }\n\n    /* ========== VIEW REWARDS ========== */\n\n    /**\n     * @notice Get claimable rewards (rewardToken) for vlCVX holder\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function claimableRewards(address _account, address _token) external view returns (uint256) {\n        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);\n        return rewards;\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function claimableRewardsAtEpoch(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) external view returns (uint256) {\n        return _claimableRewards(_account, _token, _epoch);\n    }\n\n    /**\n     * @notice  Get all claimable rewards by looping through each epoch starting with the latest\n     *          saved epoch the user last claimed from\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _allClaimableRewards(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) internal view returns (uint256, uint256) {\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        // e.g. tokenEpochs = 31, 21\n        uint256 tokenEpochs = rewardEpochs[_token].length;\n\n        // e.g. epochIndex = 0\n        uint256 epochIndex = userClaims[_token][_account];\n        // e.g. epochIndex = 27 > 0 ? 27 : 0 = 27\n        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;\n\n        if (epochIndex >= tokenEpochs) {\n            return (0, tokenEpochs);\n        }\n\n        uint256 claimableTokens = 0;\n\n        for (uint256 i = epochIndex; i < tokenEpochs; i++) {\n            //only claimable after rewards are \"locked in\"\n            if (rewardEpochs[_token][i] < latestEpoch) {\n                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);\n                //return index user claims should be set to\n                epochIndex = i + 1;\n            }\n        }\n        return (claimableTokens, epochIndex);\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function _claimableRewards(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) internal view returns (uint256) {\n        //get balance and calc share\n        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);\n        return (balance * rewardData[_token][_epoch]) / 1e20;\n    }\n\n    /**\n     * @notice Simply gets the current epoch count for a given reward token\n     * @param _token    Reward token address\n     * @return _epochs  Number of epochs\n     */\n    function rewardEpochsCount(address _token) external view returns (uint256) {\n        return rewardEpochs[_token].length;\n    }\n}\ncontract AuraVestedEscrow is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable rewardToken;\n\n    address public admin;\n    IAuraLocker public auraLocker;\n\n    uint256 public immutable startTime;\n    uint256 public immutable endTime;\n    uint256 public immutable totalTime;\n\n    bool public initialised = false;\n\n    mapping(address => uint256) public totalLocked;\n    mapping(address => uint256) public totalClaimed;\n\n    event Funded(address indexed recipient, uint256 reward);\n    event Cancelled(address indexed recipient);\n    event Claim(address indexed user, uint256 amount, bool locked);\n\n    /**\n     * @param rewardToken_    Reward token (AURA)\n     * @param admin_          Admin to cancel rewards\n     * @param auraLocker_     Contract where rewardToken can be staked\n     * @param starttime_      Timestamp when claim starts\n     * @param endtime_        When vesting ends\n     */\n    constructor(\n        address rewardToken_,\n        address admin_,\n        address auraLocker_,\n        uint256 starttime_,\n        uint256 endtime_\n    ) {\n        require(starttime_ >= block.timestamp, \"start must be future\");\n        require(endtime_ > starttime_, \"end must be greater\");\n\n        rewardToken = IERC20(rewardToken_);\n        admin = admin_;\n        auraLocker = IAuraLocker(auraLocker_);\n\n        startTime = starttime_;\n        endTime = endtime_;\n        totalTime = endTime - startTime;\n        require(totalTime >= 16 weeks, \"!short\");\n    }\n\n    /***************************************\n                    SETUP\n    ****************************************/\n\n    /**\n     * @notice Change contract admin\n     * @param _admin New admin address\n     */\n    function setAdmin(address _admin) external {\n        require(msg.sender == admin, \"!auth\");\n        admin = _admin;\n    }\n\n    /**\n     * @notice Change locker contract address\n     * @param _auraLocker Aura Locker address\n     */\n    function setLocker(address _auraLocker) external {\n        require(msg.sender == admin, \"!auth\");\n        auraLocker = IAuraLocker(_auraLocker);\n    }\n\n    /**\n     * @notice Fund recipients with rewardTokens\n     * @param _recipient  Array of recipients to vest rewardTokens for\n     * @param _amount     Arrary of amount of rewardTokens to vest\n     */\n    function fund(address[] calldata _recipient, uint256[] calldata _amount) external nonReentrant {\n        require(!initialised, \"initialised already\");\n\n        uint256 totalAmount = 0;\n        for (uint256 i = 0; i < _recipient.length; i++) {\n            uint256 amount = _amount[i];\n\n            totalLocked[_recipient[i]] += amount;\n            totalAmount += amount;\n\n            emit Funded(_recipient[i], amount);\n        }\n        rewardToken.safeTransferFrom(msg.sender, address(this), totalAmount);\n        initialised = true;\n    }\n\n    /**\n     * @notice Cancel recipients vesting rewardTokens\n     * @param _recipient Recipient address\n     */\n    function cancel(address _recipient) external nonReentrant {\n        require(msg.sender == admin, \"!auth\");\n        require(totalLocked[_recipient] > 0, \"!funding\");\n\n        _claim(_recipient, false);\n\n        uint256 delta = remaining(_recipient);\n        rewardToken.safeTransfer(admin, delta);\n\n        totalLocked[_recipient] = 0;\n\n        emit Cancelled(_recipient);\n    }\n\n    /***************************************\n                    VIEWS\n    ****************************************/\n\n    /**\n     * @notice Available amount to claim\n     * @param _recipient Recipient to lookup\n     */\n    function available(address _recipient) public view returns (uint256) {\n        uint256 vested = _totalVestedOf(_recipient, block.timestamp);\n        return vested - totalClaimed[_recipient];\n    }\n\n    /**\n     * @notice Total remaining vested amount\n     * @param _recipient Recipient to lookup\n     */\n    function remaining(address _recipient) public view returns (uint256) {\n        uint256 vested = _totalVestedOf(_recipient, block.timestamp);\n        return totalLocked[_recipient] - vested;\n    }\n\n    /**\n     * @notice Get total amount vested for this timestamp\n     * @param _recipient  Recipient to lookup\n     * @param _time       Timestamp to check vesting amount for\n     */\n    function _totalVestedOf(address _recipient, uint256 _time) internal view returns (uint256 total) {\n        if (_time < startTime) {\n            return 0;\n        }\n        uint256 locked = totalLocked[_recipient];\n        uint256 elapsed = _time - startTime;\n        total = AuraMath.min((locked * elapsed) / totalTime, locked);\n    }\n\n    /***************************************\n                    CLAIM\n    ****************************************/\n\n    function claim(bool _lock) external nonReentrant {\n        _claim(msg.sender, _lock);\n    }\n\n    /**\n     * @dev Claim reward token (Aura) and lock it.\n     * @param _recipient  Address to receive rewards.\n     * @param _lock       Lock rewards immediately.\n     */\n    function _claim(address _recipient, bool _lock) internal {\n        uint256 claimable = available(_recipient);\n\n        totalClaimed[_recipient] += claimable;\n\n        if (_lock) {\n            require(address(auraLocker) != address(0), \"!auraLocker\");\n            rewardToken.safeApprove(address(auraLocker), claimable);\n            auraLocker.lock(_recipient, claimable);\n        } else {\n            rewardToken.safeTransfer(_recipient, claimable);\n        }\n\n        emit Claim(_recipient, claimable, _lock);\n    }\n}\ncontract AuraClaimZap {\n    using SafeERC20 for IERC20;\n    using AuraMath for uint256;\n\n    address public immutable crv;\n    address public immutable cvx;\n    address public immutable cvxCrv;\n    address public immutable crvDepositWrapper;\n    address public immutable cvxCrvRewards;\n    address public immutable locker;\n    address public immutable owner;\n\n    enum Options {\n        ClaimCvxCrv, //1\n        ClaimLockedCvx, //2\n        ClaimLockedCvxStake, //4\n        LockCrvDeposit, //8\n        UseAllWalletFunds, //16\n        LockCvx //32\n    }\n\n    /**\n     * @param _crv                CRV token (0xD533a949740bb3306d119CC777fa900bA034cd52);\n     * @param _cvx                CVX token (0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n     * @param _cvxCrv             cvxCRV token (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);\n     * @param _crvDepositWrapper  crvDepositWrapper (0x8014595F2AB54cD7c604B00E9fb932176fDc86Ae);\n     * @param _cvxCrvRewards      cvxCrvRewards (0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);\n     * @param _locker             vlCVX (0xD18140b4B819b895A3dba5442F959fA44994AF50);\n     */\n    constructor(\n        address _crv,\n        address _cvx,\n        address _cvxCrv,\n        address _crvDepositWrapper,\n        address _cvxCrvRewards,\n        address _locker\n    ) {\n        crv = _crv;\n        cvx = _cvx;\n        cvxCrv = _cvxCrv;\n        crvDepositWrapper = _crvDepositWrapper;\n        cvxCrvRewards = _cvxCrvRewards;\n        locker = _locker;\n        owner = msg.sender;\n    }\n\n    function getName() external pure returns (string memory) {\n        return \"ClaimZap V2.0\";\n    }\n\n    /**\n     * @notice Approve spending of:\n     *          crv     -> crvDepositor\n     *          cvxCrv  -> cvxCrvRewards\n     *          cvx     -> Locker\n     */\n    function setApprovals() external {\n        require(msg.sender == owner, \"!auth\");\n\n        IERC20(crv).safeApprove(crvDepositWrapper, 0);\n        IERC20(crv).safeApprove(crvDepositWrapper, type(uint256).max);\n\n        IERC20(cvxCrv).safeApprove(cvxCrvRewards, 0);\n        IERC20(cvxCrv).safeApprove(cvxCrvRewards, type(uint256).max);\n\n        IERC20(cvx).safeApprove(locker, 0);\n        IERC20(cvx).safeApprove(locker, type(uint256).max);\n    }\n\n    /**\n     * @notice Use bitmask to check if option flag is set\n     */\n    function _checkOption(uint256 _mask, uint256 _flag) internal pure returns (bool) {\n        return (_mask & (1 << _flag)) != 0;\n    }\n\n    /**\n     * @notice Claim all the rewards\n     * @param rewardContracts       Array of addresses for LP token rewards\n     * @param extraRewardContracts  Array of addresses for extra rewards\n     * @param tokenRewardContracts  Array of addresses for token rewards e.g vlCvxExtraRewardDistribution\n     * @param tokenRewardTokens     Array of token reward addresses to use with tokenRewardContracts\n     * @param depositCrvMaxAmount   The max amount of CRV to deposit if converting to crvCvx\n     * @param minAmountOut          The min amount out for crv:cvxCrv swaps if swapping. Set this to zero if you\n     *                              want to use CrvDepositor instead of balancer swap\n     * @param depositCvxMaxAmount   The max amount of CVX to deposit if locking CVX\n     * @param options               Claim options\n     */\n    function claimRewards(\n        address[] calldata rewardContracts,\n        address[] calldata extraRewardContracts,\n        address[] calldata tokenRewardContracts,\n        address[] calldata tokenRewardTokens,\n        uint256 depositCrvMaxAmount,\n        uint256 minAmountOut,\n        uint256 depositCvxMaxAmount,\n        uint256 options\n    ) external {\n        require(tokenRewardContracts.length == tokenRewardTokens.length, \"!parity\");\n\n        uint256 crvBalance = IERC20(crv).balanceOf(msg.sender);\n        uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender);\n\n        //claim from main curve LP pools\n        for (uint256 i = 0; i < rewardContracts.length; i++) {\n            IBasicRewards(rewardContracts[i]).getReward(msg.sender, true);\n        }\n        //claim from extra rewards\n        for (uint256 i = 0; i < extraRewardContracts.length; i++) {\n            IBasicRewards(extraRewardContracts[i]).getReward(msg.sender);\n        }\n        //claim from multi reward token contract\n        for (uint256 i = 0; i < tokenRewardContracts.length; i++) {\n            IBasicRewards(tokenRewardContracts[i]).getReward(msg.sender, tokenRewardTokens[i]);\n        }\n\n        // claim others/deposit/lock/stake\n        _claimExtras(depositCrvMaxAmount, minAmountOut, depositCvxMaxAmount, crvBalance, cvxBalance, options);\n    }\n\n    /**\n     * @notice  Claim additional rewards from:\n     *          - cvxCrvRewards\n     *          - cvxLocker\n     * @param depositCrvMaxAmount see claimRewards\n     * @param minAmountOut        see claimRewards\n     * @param depositCvxMaxAmount see claimRewards\n     * @param removeCrvBalance    crvBalance to ignore and not redeposit (starting Crv balance)\n     * @param removeCvxBalance    cvxBalance to ignore and not redeposit (starting Cvx balance)\n     * @param options             see claimRewards\n     */\n    // prettier-ignore\n    function _claimExtras( // solhint-disable-line \n        uint256 depositCrvMaxAmount,\n        uint256 minAmountOut,\n        uint256 depositCvxMaxAmount,\n        uint256 removeCrvBalance,\n        uint256 removeCvxBalance,\n        uint256 options\n    ) internal {\n        //claim from cvxCrv rewards\n        if (_checkOption(options, uint256(Options.ClaimCvxCrv))) {\n            IBasicRewards(cvxCrvRewards).getReward(msg.sender, true);\n        }\n\n        //claim from locker\n        if (_checkOption(options, uint256(Options.ClaimLockedCvx))) {\n            IAuraLocker(locker).getReward(msg.sender, _checkOption(options, uint256(Options.ClaimLockedCvxStake)));\n        }\n\n        //reset remove balances if we want to also stake/lock funds already in our wallet\n        if (_checkOption(options, uint256(Options.UseAllWalletFunds))) {\n            removeCrvBalance = 0;\n            removeCvxBalance = 0;\n        }\n\n        //lock upto given amount of crv and stake\n        if (depositCrvMaxAmount > 0) {\n            uint256 crvBalance = IERC20(crv).balanceOf(msg.sender).sub(removeCrvBalance);\n            crvBalance = AuraMath.min(crvBalance, depositCrvMaxAmount);\n\n            if (crvBalance > 0) {\n                //pull crv\n                IERC20(crv).safeTransferFrom(msg.sender, address(this), crvBalance);\n                //deposit\n                ICrvDepositorWrapper(crvDepositWrapper).deposit(\n                    crvBalance,\n                    minAmountOut,\n                    _checkOption(options, uint256(Options.LockCrvDeposit)),\n                    address(0)\n                );\n\n                uint256 cvxCrvBalance = IERC20(cvxCrv).balanceOf(address(this));\n                //stake for msg.sender\n                IBasicRewards(cvxCrvRewards).stakeFor(msg.sender, cvxCrvBalance);\n            }\n        }\n\n        //stake up to given amount of cvx\n        if (depositCvxMaxAmount > 0) {\n            uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);\n            cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);\n            if (cvxBalance > 0) {\n                //pull cvx\n                IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);\n                if (_checkOption(options, uint256(Options.LockCvx))) {\n                    IAuraLocker(locker).lock(msg.sender, cvxBalance);\n                }\n            }\n        }\n    }\n}\ncontract AuraStakingProxy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    //tokens\n    address public immutable crv;\n    address public immutable cvx;\n    address public immutable cvxCrv;\n\n    address public keeper;\n    address public crvDepositorWrapper;\n    uint256 public outputBps;\n    uint256 public constant denominator = 10000;\n\n    address public rewards;\n\n    address public owner;\n    address public pendingOwner;\n    uint256 public callIncentive = 25;\n\n    event RewardsDistributed(address indexed token, uint256 amount);\n    event CallIncentiveChanged(uint256 incentive);\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /**\n     * @param _rewards       vlCVX\n     * @param _crv           CRV token\n     * @param _cvx           CVX token\n     * @param _cvxCrv        cvxCRV token\n     * @param _crvDepositorWrapper    Wrapper that converts CRV to CRVBPT and deposits\n     * @param _outputBps     Configurable output bps where 100% == 10000\n     */\n    constructor(\n        address _rewards,\n        address _crv,\n        address _cvx,\n        address _cvxCrv,\n        address _crvDepositorWrapper,\n        uint256 _outputBps\n    ) {\n        rewards = _rewards;\n        owner = msg.sender;\n        crv = _crv;\n        cvx = _cvx;\n        cvxCrv = _cvxCrv;\n        crvDepositorWrapper = _crvDepositorWrapper;\n        outputBps = _outputBps;\n    }\n\n    /**\n     * @notice Set CrvDepositorWrapper\n     * @param   _crvDepositorWrapper CrvDepositorWrapper address\n     * @param   _outputBps Min output base points\n     */\n    function setCrvDepositorWrapper(address _crvDepositorWrapper, uint256 _outputBps) external {\n        require(msg.sender == owner, \"!auth\");\n        require(_outputBps > 9000 && _outputBps < 10000, \"Invalid output bps\");\n\n        crvDepositorWrapper = _crvDepositorWrapper;\n        outputBps = _outputBps;\n    }\n\n    /**\n     * @notice Set keeper\n     */\n    function setKeeper(address _keeper) external {\n        require(msg.sender == owner, \"!auth\");\n        keeper = _keeper;\n    }\n\n    /**\n     * @notice Set pending owner\n     */\n    function setPendingOwner(address _po) external {\n        require(msg.sender == owner, \"!auth\");\n        pendingOwner = _po;\n    }\n\n    /**\n     * @notice Apply pending owner\n     */\n    function applyPendingOwner() external {\n        require(msg.sender == owner, \"!auth\");\n        require(pendingOwner != address(0), \"invalid owner\");\n\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /**\n     * @notice Set call incentive\n     * @param _incentive Incentive base points\n     */\n    function setCallIncentive(uint256 _incentive) external {\n        require(msg.sender == owner, \"!auth\");\n        require(_incentive <= 100, \"too high\");\n        callIncentive = _incentive;\n        emit CallIncentiveChanged(_incentive);\n    }\n\n    /**\n     * @notice Set reward address\n     */\n    function setRewards(address _rewards) external {\n        require(msg.sender == owner, \"!auth\");\n        rewards = _rewards;\n    }\n\n    /**\n     * @notice  Approve crvDepositorWrapper to transfer contract CRV\n     *          and rewards to transfer cvxCrv\n     */\n    function setApprovals() external {\n        IERC20(crv).safeApprove(crvDepositorWrapper, 0);\n        IERC20(crv).safeApprove(crvDepositorWrapper, type(uint256).max);\n\n        IERC20(cvxCrv).safeApprove(rewards, 0);\n        IERC20(cvxCrv).safeApprove(rewards, type(uint256).max);\n    }\n\n    /**\n     * @notice Transfer stuck ERC20 tokens to `_to`\n     */\n    function rescueToken(address _token, address _to) external {\n        require(msg.sender == owner, \"!auth\");\n        require(_token != crv && _token != cvx && _token != cvxCrv, \"not allowed\");\n\n        uint256 bal = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(_to, bal);\n    }\n\n    /**\n     * @dev Collects cvxCRV rewards from cvxRewardPool, converts any CRV deposited directly from\n     *      the booster, and then applies the rewards to the cvxLocker, rewarding the caller in the process.\n     */\n    function distribute() external {\n        // If keeper enabled, require\n        if (keeper != address(0)) {\n            require(msg.sender == keeper, \"!auth\");\n        }\n\n        //convert crv to cvxCrv\n        uint256 crvBal = IERC20(crv).balanceOf(address(this));\n        if (crvBal > 0) {\n            uint256 minOut = ICrvDepositorWrapper(crvDepositorWrapper).getMinOut(crvBal, outputBps);\n            ICrvDepositorWrapper(crvDepositorWrapper).deposit(crvBal, minOut, true, address(0));\n        }\n\n        //distribute cvxcrv\n        uint256 cvxCrvBal = IERC20(cvxCrv).balanceOf(address(this));\n\n        if (cvxCrvBal > 0) {\n            uint256 incentiveAmount = cvxCrvBal.mul(callIncentive).div(denominator);\n            cvxCrvBal = cvxCrvBal.sub(incentiveAmount);\n\n            //send incentives\n            IERC20(cvxCrv).safeTransfer(msg.sender, incentiveAmount);\n\n            //update rewards\n            IAuraLocker(rewards).queueNewRewards(cvxCrvBal);\n\n            emit RewardsDistributed(cvxCrv, cvxCrvBal);\n        }\n    }\n\n    /**\n     * @notice Allow generic token distribution in case a new reward is ever added\n     */\n    function distributeOther(IERC20 _token) external {\n        require(address(_token) != crv && address(_token) != cvxCrv, \"not allowed\");\n\n        uint256 bal = _token.balanceOf(address(this));\n\n        if (bal > 0) {\n            uint256 incentiveAmount = bal.mul(callIncentive).div(denominator);\n            bal = bal.sub(incentiveAmount);\n\n            //send incentives\n            _token.safeTransfer(msg.sender, incentiveAmount);\n\n            //approve\n            _token.safeApprove(rewards, 0);\n            _token.safeApprove(rewards, type(uint256).max);\n\n            //update rewards\n            IAuraLocker(rewards).notifyRewardAmount(address(_token), bal);\n\n            emit RewardsDistributed(address(_token), bal);\n        }\n    }\n}\n",
    "bin": []
}