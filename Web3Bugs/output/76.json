{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/76",
    "external_functions": [
        [
            "SherBuy",
            "IERC20",
            "ISherlock",
            "ISherClaim"
        ],
        [
            "SherClaim"
        ],
        [
            "Sherlock",
            "IERC721Receiver",
            "ISherlockProtocolManager",
            "IERC20",
            "IStrategyManager",
            "Pausable",
            "ISherlockClaimManager",
            "ISherDistributionManager"
        ],
        [
            "AaveV2Strategy",
            "IAToken",
            "IERC20",
            "ILendingPoolAddressesProvider",
            "ILendingPool",
            "IAaveIncentivesController",
            "ISherlock"
        ],
        [
            "Manager",
            "IERC20"
        ],
        [
            "SherDistributionManager",
            "IERC20",
            "ISherlock"
        ],
        [
            "SherlockClaimManager",
            "IERC20",
            "ISherlock",
            "ISherlockProtocolManager",
            "SkinnyOptimisticOracleInterface",
            "ISherlockClaimManagerCallbackReceiver"
        ],
        [
            "SherlockProtocolManager",
            "IERC20",
            "ISherlock"
        ]
    ],
    "new_contract": "contract SherBuy {\n  using SafeERC20 for IERC20;\n\n  error InvalidSender();\n  error InvalidAmount();\n  error ZeroArgument();\n  error InvalidState();\n  error SoldOut();\n\n  /// @notice Emitted when SHER purchase is executed\n  /// @param buyer Account that bought SHER tokens\n  /// @param amount How much SHER tokens are bought\n  /// @param staked How much USDC is staked\n  /// @param paid How much USDC is paid\n  event Purchase(address indexed buyer, uint256 amount, uint256 staked, uint256 paid);\n\n  // The staking period used for the staking USDC\n  uint256 public constant PERIOD = 26 weeks;\n  // Allows purchases in steps of 0.01 SHER\n  uint256 internal constant SHER_STEPS = 10**16;\n  // Allows stakeRate and buyRate with steps of 0.01 USDC\n  uint256 internal constant RATE_STEPS = 10**4;\n  // SHER has 18 decimals\n  uint256 internal constant SHER_DECIMALS = 10**18;\n\n  // SHER token address (18 decimals)\n  IERC20 public immutable sher;\n  // USDC token address (6 decimals)\n  IERC20 public immutable usdc;\n\n  // 10**6 means for every 1 SHER token you want to buy, you will stake 1 USDC (10**7 means 1 SHER for 10 USDC)\n  uint256 public immutable stakeRate;\n  // 10**6 means for every 1 SHER token you want to buy, you will pay 1 USDC (10**7 means 1 SHER for 10 USDC)\n  uint256 public immutable buyRate;\n  // The `Sherlock.sol` contract that is a ERC721\n  ISherlock public immutable sherlockPosition;\n  // Address receiving the USDC payments\n  address public immutable receiver;\n  // Contract to claim SHER at\n  ISherClaim public immutable sherClaim;\n\n  /// @notice Construct BuySher contract\n  /// @param _sher ERC20 contract for SHER token\n  /// @param _usdc ERC20 contract for USDC token\n  /// @param _stakeRate Rate at which SHER tokens translate to the amount of USDC needed to be staked\n  /// @param _buyRate Rate at which SHER tokens translate to the amount of USDC needed to be paid\n  /// @param _sherlockPosition ERC721 contract of Sherlock positions\n  /// @param _receiver Address that receives USDC from purchases\n  /// @param _sherClaim Contract that keeps the SHER timelocked\n  constructor(\n    IERC20 _sher,\n    IERC20 _usdc,\n    uint256 _stakeRate,\n    uint256 _buyRate,\n    ISherlock _sherlockPosition,\n    address _receiver,\n    ISherClaim _sherClaim\n  ) {\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_usdc) == address(0)) revert ZeroArgument();\n    if (_stakeRate == 0) revert ZeroArgument();\n    if (_stakeRate % RATE_STEPS != 0) revert InvalidState();\n    if (_buyRate == 0) revert ZeroArgument();\n    if (_buyRate % RATE_STEPS != 0) revert InvalidState();\n    if (address(_sherlockPosition) == address(0)) revert ZeroArgument();\n    if (_receiver == address(0)) revert ZeroArgument();\n    if (address(_sherClaim) == address(0)) revert ZeroArgument();\n\n    // Verify is PERIOD is active\n    // Theoretically this period can be disabled during the lifetime of this contract, which will cause issues\n    if (_sherlockPosition.stakingPeriods(PERIOD) == false) revert InvalidState();\n\n    sher = _sher;\n    usdc = _usdc;\n    stakeRate = _stakeRate;\n    buyRate = _buyRate;\n    sherlockPosition = _sherlockPosition;\n    receiver = _receiver;\n    sherClaim = _sherClaim;\n\n    // Do max approve in constructor as this contract will not hold any USDC\n    usdc.approve(address(sherlockPosition), type(uint256).max);\n  }\n\n  /// @notice Check if the liquidity event is active\n  /// @dev SHER tokens can run out while event is active\n  /// @return True if the liquidity event is active\n  function active() public view returns (bool) {\n    // The claim contract will become active once the liquidity event is inactive\n    return block.timestamp < sherClaim.claimableAt();\n  }\n\n  /// @notice View the capital requirements needed to buy up until `_sherAmountWant`\n  /// @dev Will adjust to remaining SHER if `_sherAmountWant` exceeds that\n  /// @return sherAmount Will adjust to remining SHER if `_sherAmountWant` exceeds that\n  /// @return stake How much USDC needs to be staked for `PERIOD` of time to buy `sherAmount` SHER\n  /// @return price How much USDC needs to be paid to buy `sherAmount` SHER\n  function viewCapitalRequirements(uint256 _sherAmountWant)\n    public\n    view\n    returns (\n      uint256 sherAmount,\n      uint256 stake,\n      uint256 price\n    )\n  {\n    // Only allow if liquidity event is active\n    if (active() == false) revert InvalidState();\n    // Zero isn't allowed\n    if (_sherAmountWant == 0) revert ZeroArgument();\n\n    // View how much SHER is still available to be sold\n    uint256 available = sher.balanceOf(address(this));\n    // If remaining SHER is 0 it's sold out\n    if (available == 0) revert SoldOut();\n\n    // Use remaining SHER if it's less then `_sherAmountWant`, otherwise go for `_sherAmountWant`\n    // Remaining SHER will only be assigned on the last sale of this contract, `SoldOut()` error will be thrown after\n    // sherAmount is not able to be zero as both 'available' and '_sherAmountWant' will be bigger than 0\n    sherAmount = available < _sherAmountWant ? available : _sherAmountWant;\n    // Only allows SHER amounts with certain precision steps\n    // To ensure there is no rounding error at loss for the contract in stake / price calculation\n    // Theoretically, if `available` is used, the function can fail if '% SHER_STEPS != 0' will be true\n    // This can be caused by a griefer sending a small amount of SHER to the contract\n    // Realistically, no SHER tokens will be on the market when this function is active\n    // So it can only be caused if the admin sends too small amounts (documented at top of file with @dev)\n    if (sherAmount % SHER_STEPS != 0) revert InvalidAmount();\n\n    // Calculate how much USDC needs to be staked to buy `sherAmount`\n    stake = (sherAmount * stakeRate) / SHER_DECIMALS;\n    // Calculate how much USDC needs to be paid to buy `sherAmount`\n    price = (sherAmount * buyRate) / SHER_DECIMALS;\n  }\n\n  /// @notice Buy up until `_sherAmountWant`\n  /// @param _sherAmountWant The maximum amount of SHER the user wants to buy\n  /// @dev Bought SHER tokens are moved to a timelock contract (SherClaim)\n  /// @dev Will revert if liquidity event is inactive because of the viewCapitalRequirements call\n  function execute(uint256 _sherAmountWant) external {\n    // Calculate the capital requirements\n    // Check how much SHER can actually be bought\n    (uint256 sherAmount, uint256 stake, uint256 price) = viewCapitalRequirements(_sherAmountWant);\n\n    // Transfer usdc from user to this, for staking (max is approved in constructor)\n    usdc.safeTransferFrom(msg.sender, address(this), stake);\n    // Transfer usdc from user to receiver, for payment of the SHER\n    usdc.safeTransferFrom(msg.sender, receiver, price);\n\n    // Stake usdc and send NFT to user\n    sherlockPosition.initialStake(stake, PERIOD, msg.sender);\n    // Approve in function as this contract will hold SHER tokens\n    sher.approve(address(sherClaim), sherAmount);\n    // Add bought SHER tokens to timelock for user\n    sherClaim.add(msg.sender, sherAmount);\n\n    // Emit event about the purchase\n    emit Purchase(msg.sender, sherAmount, stake, price);\n  }\n\n  /// @notice Rescue remaining ERC20 tokens when liquidity event is inactive\n  /// @param _tokens Array of ERC20 tokens to rescue\n  /// @dev Can only be called by `receiver`\n  function sweepTokens(IERC20[] memory _tokens) external {\n    if (msg.sender != receiver) revert InvalidSender();\n    if (active()) revert InvalidState();\n\n    // Loops through the extra tokens (ERC20) provided and sends all of them to the sender address\n    for (uint256 i; i < _tokens.length; i++) {\n      IERC20 token = _tokens[i];\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n  }\n}\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n\n  // Anyone who gets auto-restaked is restaked for this period (3 months)\n  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;\n\n  // The percentage of someone's stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%\n\n  // USDC address\n  IERC20 public immutable token;\n\n  // SHER token address\n  IERC20 public immutable sher;\n\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 => bool) public override stakingPeriods;\n\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 => uint256) internal lockupEnd_;\n\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 => uint256) internal sherRewards_;\n\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 => uint256) internal stakeShares;\n\n  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.\n  mapping(address => uint256) internal addressShares;\n\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n\n  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 _token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i < _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n\n  //\n  // View functions\n  //\n\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of `_tokenID`\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return lockupEnd_[_tokenID];\n  }\n\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of `_tokenID`\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return sherRewards_[_tokenID];\n  }\n\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Returns the tokens (USDC) owed to an address\n  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking all positions\n  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {\n    if (_staker == address(0)) revert ZeroArgument();\n    uint256 _totalStakeShares = totalStakeShares;\n    if (_totalStakeShares == 0) return 0;\n    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;\n  }\n\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n\n  //\n  // Gov functions\n  //\n\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for `_period` of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for `_period` of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n\n  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligble for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligble for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy News address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit `_amount` into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw `_amount` from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    yieldStrategy.withdraw(_amount);\n  }\n\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in a `paused` state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn't needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &&\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in an `unpaused` state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn't needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &&\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n\n  //\n  // Access control functions\n  //\n\n  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`\n  /// @dev this enables the `tokenBalanceOfAddress` to exist\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override {\n    uint256 _stakeShares = stakeShares[_tokenID];\n\n    if (_from != address(0)) addressShares[_from] -= _stakeShares;\n    if (_to != address(0)) addressShares[_to] += _stakeShares;\n  }\n\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of `_amount` to `_receiver`\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n\n  //\n  // Non-access control functions\n  //\n\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends\n  /// @dev `_period` needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd_[_id] = block.timestamp + _period;\n\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards_[_id] = _sher;\n  }\n\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();\n  }\n\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards_[_id];\n    if (sherReward == 0) return;\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards_[_id];\n  }\n\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount > mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n\n    emit Restaked(_id);\n  }\n\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends\n  /// @dev `_period` needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {\n    if (_amount == 0) revert ZeroArgument();\n    // Makes sure the period is a whitelisted period\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    if (address(_receiver) == address(0)) revert ZeroArgument();\n    // Adds 1 to the ID of the last NFT created for the new NFT ID\n    _id = ++nftCounter;\n\n    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 stakeShares_;\n    uint256 totalStakeShares_ = totalStakeShares;\n    // _amount of tokens divided by the \"before\" total amount of tokens, multiplied by the \"before\" amount of stake shares\n    if (totalStakeShares_ != 0)\n      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);\n      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked\n    else stakeShares_ = _amount;\n\n    // Assigns this NFT ID the calc'd amount of stake shares above\n    stakeShares[_id] = stakeShares_;\n    // Adds the newly created stake shares to the total amount of stake shares\n    totalStakeShares += stakeShares_;\n\n    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake\n    _sher = _stake(_amount, _period, _id, _receiver);\n\n    // This is an ERC-721 function that creates an NFT and sends it to the receiver\n    _safeMint(_receiver, _id);\n  }\n\n  // This is how a staker unstakes and cashes out on their position\n  /// @notice Redeem NFT `_id` and receive `_amount` of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of `_id` will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup `_period` has ended\n  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // This is the ERC-721 function to destroy an NFT (with owner's approval)\n    _burn(_id);\n\n    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC owed to these shares\n    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);\n\n    // Sends the SHER tokens associated with this NFT ID to the NFT owner\n    _sendSherRewardsToOwner(_id, msg.sender);\n\n    // Removes the unlock deadline associated with this NFT\n    delete lockupEnd_[_id];\n  }\n\n  // This is how a staker restakes an expired position\n  /// @notice Owner restakes position with ID: `_id` for `_period` seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends\n  /// @dev Only the owner of `_id` will be able to restake their position using this call\n  /// @dev `_period` needs to be whitelisted\n  /// @dev Can only be called after lockup `_period` has ended\n  function ownerRestake(uint256 _id, uint256 _period)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher)\n  {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // Checks to make sure the staking period is a whitelisted one\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position\n    _sher = _restake(_id, _period, msg.sender);\n  }\n\n  // Calcs the reward (in stake shares) an arb would get for restaking a position\n  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb\n  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {\n    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)\n    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;\n\n    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position\n    if (initialArbTime > block.timestamp) return (0, false);\n\n    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp\n    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;\n\n    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%\n    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;\n\n    // Scaled by 10**18\n    // Represents the max amount of stake shares that an arb could get from restaking this position\n    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];\n\n    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function\n    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled\n    return (\n      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,\n      true\n    );\n  }\n\n  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position\n  /// @return profit How much profit an arb would make in USDC\n  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)\n  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    // `profit` variable is used to store the amount of shares\n    (profit, able) = _calcSharesForArbRestake(_id);\n    // Calculates the tokens (USDC) represented by that amount of stake shares\n    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`\n    profit = _redeemSharesCalc(profit);\n  }\n\n  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)\n  function arbRestake(uint256 _id)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher, uint256 _arbReward)\n  {\n    address nftOwner = ownerOf(_id);\n\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);\n    // Revert if not able to be arbed\n    if (!able) revert InvalidConditions();\n\n    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC paid to the arbitrager\n    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);\n\n    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)\n    // Sends previously earned SHER rewards to the NFT owner address\n    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);\n\n    emit ArbRestaked(_id, _arbReward);\n  }\n}\ncontract AaveV2Strategy is IStrategyManager, Manager {\n  using SafeERC20 for IERC20;\n\n  // Need to call a provider because Aave has the ability to change the lending pool address\n  ILendingPoolAddressesProvider public constant LP_ADDRESS_PROVIDER =\n    ILendingPoolAddressesProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5);\n\n  // Aave contract that controls stkAAVE rewards\n  IAaveIncentivesController public immutable aaveIncentivesController;\n\n  // This is the token being deposited (USDC)\n  IERC20 public immutable override want;\n  // This is the receipt token Aave gives in exchange for a token deposit (aUSDC)\n  IAToken public immutable aWant;\n\n  // Address to receive stkAAVE rewards\n  address public immutable aaveLmReceiver;\n\n  // Constructor takes the aUSDC address and the rewards receiver address (a Sherlock address) as args\n  constructor(IAToken _aWant, address _aaveLmReceiver) {\n    if (address(_aWant) == address(0)) revert ZeroArgument();\n    if (_aaveLmReceiver == address(0)) revert ZeroArgument();\n\n    aWant = _aWant;\n    // This gets the underlying token associated with aUSDC (USDC)\n    want = IERC20(_aWant.UNDERLYING_ASSET_ADDRESS());\n    // Gets the specific rewards controller for this token type\n    aaveIncentivesController = _aWant.getIncentivesController();\n\n    aaveLmReceiver = _aaveLmReceiver;\n  }\n\n  // Returns the current Aave lending pool address that should be used\n  function getLp() internal view returns (ILendingPool) {\n    return ILendingPool(LP_ADDRESS_PROVIDER.getLendingPool());\n  }\n\n  /// @notice Checks the aUSDC balance in this contract\n  function balanceOf() public view override returns (uint256) {\n    return aWant.balanceOf(address(this));\n  }\n\n  /// @notice Deposits all USDC held in this contract into Aave's lending pool\n  function deposit() external override whenNotPaused {\n    ILendingPool lp = getLp();\n    // Checking the USDC balance of this contract\n    uint256 amount = want.balanceOf(address(this));\n    if (amount == 0) revert InvalidConditions();\n\n    // If allowance for this contract is too low, approve the max allowance\n    if (want.allowance(address(this), address(lp)) < amount) {\n      want.safeApprove(address(lp), type(uint256).max);\n    }\n\n    // Deposits the full balance of USDC held in this contract into Aave's lending pool\n    lp.deposit(address(want), amount, address(this), 0);\n  }\n\n  /// @notice Withdraws all USDC from Aave's lending pool back into the Sherlock core contract\n  /// @dev Only callable by the Sherlock core contract\n  /// @return The final amount withdrawn\n  function withdrawAll() external override onlySherlockCore returns (uint256) {\n    ILendingPool lp = getLp();\n    if (balanceOf() == 0) {\n      return 0;\n    }\n    // Withdraws all USDC from Aave's lending pool and sends it to the Sherlock core contract (msg.sender)\n    return lp.withdraw(address(want), type(uint256).max, msg.sender);\n  }\n\n  /// @notice Withdraws a specific amount of USDC from Aave's lending pool back into the Sherlock core contract\n  /// @param _amount Amount of USDC to withdraw\n  function withdraw(uint256 _amount) external override onlySherlockCore {\n    // Why do we only check if _amount is equal to the max value?\n    if (_amount == type(uint256).max) revert InvalidArgument();\n\n    ILendingPool lp = getLp();\n    // Withdraws _amount of USDC and sends it to the Sherlock core contract\n    // If the amount withdrawn is not equal to _amount, it reverts\n    if (lp.withdraw(address(want), _amount, msg.sender) != _amount) revert InvalidConditions();\n  }\n\n  // Claims the stkAAVE rewards and sends them to the receiver address\n  function claimRewards() external whenNotPaused {\n    // Creates an array with one slot\n    address[] memory assets = new address[](1);\n    // Sets the slot equal to the address of aUSDC\n    assets[0] = address(aWant);\n\n    // Claims all the rewards on aUSDC and sends them to the aaveLmReceiver (an address controlled by governance)\n    // Tokens are NOT meant to be (directly) distributed to stakers.\n    aaveIncentivesController.claimRewards(assets, type(uint256).max, aaveLmReceiver);\n  }\n\n  /// @notice Function used to check if this is the current active yield strategy\n  /// @return Boolean indicating it's active\n  /// @dev If inactive the owner can pull all ERC20s and ETH\n  /// @dev Will be checked by calling the sherlock contract\n  function isActive() public view returns (bool) {\n    return address(sherlockCore.yieldStrategy()) == address(this);\n  }\n\n  // Only contract owner can call this\n  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)\n  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {\n    if (_receiver == address(0)) revert ZeroArgument();\n    // This contract must NOT be the current assigned yield strategy contract\n    if (isActive()) revert InvalidConditions();\n    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH\n    _sweep(_receiver, _extraTokens);\n  }\n}\ncontract SherDistributionManager is ISherDistributionManager, Manager {\n  using SafeERC20 for IERC20;\n\n  uint256 internal constant DECIMALS = 10**6;\n\n  // The TVL at which max SHER rewards STOP i.e. 100M USDC\n  uint256 internal immutable maxRewardsEndTVL;\n\n  // The TVL at which SHER rewards stop entirely i.e. 600M USDC\n  uint256 internal immutable zeroRewardsStartTVL;\n\n  // The SHER tokens paid per USDC staked per second at the max rate\n  uint256 internal immutable maxRewardsRate;\n\n  // SHER token contract address\n  IERC20 public immutable sher;\n\n  /// @dev With `_maxRewardsRate` being 10**18, 1 USDC == 1 SHER per second (on flat part of curve)\n  constructor(\n    uint256 _maxRewardsEndTVL,\n    uint256 _zeroRewardsStartTVL,\n    uint256 _maxRewardsRate,\n    IERC20 _sher\n  ) {\n    if (_maxRewardsEndTVL >= _zeroRewardsStartTVL) revert InvalidArgument();\n    if (_maxRewardsRate == 0) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n\n    maxRewardsEndTVL = _maxRewardsEndTVL;\n    zeroRewardsStartTVL = _zeroRewardsStartTVL;\n    maxRewardsRate = _maxRewardsRate;\n    sher = _sher;\n\n    emit Initialized(_maxRewardsEndTVL, _zeroRewardsStartTVL, _maxRewardsRate);\n  }\n\n  // This function is called (by core Sherlock contracrt) as soon as a staker stakes\n  // Calculates the SHER tokens owed to the stake, then transfers the SHER to the Sherlock core contract\n  // Staker won't actually receive these SHER tokens until the lockup has expired though\n  /// @notice Caller will receive `_sher` SHER tokens based on `_amount` and `_period`\n  /// @param _amount Amount of tokens (in USDC) staked\n  /// @param _period Period of time for stake, in seconds\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens sent to Sherlock core contract\n  /// @dev Calling contract will depend on before + after balance diff and return value\n  /// @dev INCLUDES stake in calculation, function expects the `_amount` to be deposited already\n  /// @dev If tvl=50 and amount=50, this means it is calculating SHER rewards for the first 50 tokens going in\n  /// @dev Doesn't include whenNotPaused modifier as it's onlySherlockCore where pause is captured\n  /// @dev `_id` and `_receiver` are unused in this implementation\n  function pullReward(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) external override onlySherlockCore returns (uint256 _sher) {\n    // Uses calcReward() to get the SHER tokens owed to this stake\n    // Subtracts the amount from the total token balance to get the pre-stake USDC TVL\n    _sher = calcReward(sherlockCore.totalTokenBalanceStakers() - _amount, _amount, _period);\n    // Sends the SHER tokens to the core Sherlock contract where they are held until the unlock period for the stake expires\n    if (_sher != 0) sher.safeTransfer(msg.sender, _sher);\n  }\n\n  /// @notice Calculates how many `_sher` SHER tokens are owed to a stake position based on `_amount` and `_period`\n  /// @param _tvl TVL to use for reward calculation (pre-stake TVL)\n  /// @param _amount Amount of tokens (USDC) staked\n  /// @param _period Stake period (in seconds)\n  /// @return _sher Amount of SHER tokens owed to this stake position\n  /// @dev EXCLUDES `_amount` of stake, this will be added on top of TVL (_tvl is excluding _amount)\n  /// @dev If tvl=0 and amount=50, it would calculate for the first 50 tokens going in (different from pullReward())\n  function calcReward(\n    uint256 _tvl,\n    uint256 _amount,\n    uint256 _period\n  ) public view override returns (uint256 _sher) {\n    if (_amount == 0) return 0;\n\n    // Figures out how much of this stake should receive max rewards\n    // _tvl is the pre-stake TVL (call it $80M) and maxRewardsEndTVL could be $100M\n    // If maxRewardsEndTVL is bigger than the pre-stake TVL, then some or all of the stake could receive max rewards\n    // In this case, the amount of the stake to receive max rewards is maxRewardsEndTVL - _tvl\n    // Otherwise, the pre-stake TVL could be bigger than the maxRewardsEndTVL, in which case 0 max rewards are available\n    uint256 maxRewardsAvailable = maxRewardsEndTVL > _tvl ? maxRewardsEndTVL - _tvl : 0;\n\n    // Same logic as above for the TVL at which all SHER rewards end\n    // If the pre-stake TVL is lower than the zeroRewardsStartTVL, then SHER rewards are still available to all or part of the stake\n    // The starting point of the slopeRewards is calculated using max(maxRewardsEndTVL, tvl).\n    // The starting point is either the beginning of the slope --> maxRewardsEndTVL\n    // Or it's the current amount of TVL in case the point on the curve is already on the slope.\n    uint256 slopeRewardsAvailable = zeroRewardsStartTVL > _tvl\n      ? zeroRewardsStartTVL - Math.max(maxRewardsEndTVL, _tvl)\n      : 0;\n\n    // If there are some max rewards available...\n    if (maxRewardsAvailable != 0) {\n      // And if the entire stake is still within the maxRewardsAvailable amount\n      if (_amount <= maxRewardsAvailable) {\n        // Then the entire stake amount should accrue max SHER rewards\n        return (_amount * maxRewardsRate * _period) / DECIMALS;\n      } else {\n        // Otherwise, the stake takes all the maxRewardsAvailable left and the calc continues\n        // We add the maxRewardsAvailable amount to the TVL (now _tvl should be equal to maxRewardsEndTVL)\n        _tvl += maxRewardsAvailable;\n        // We subtract the amount of the stake that received max rewards\n        _amount -= maxRewardsAvailable;\n\n        // We accrue the max rewards available at the max rewards rate for the stake period to the SHER balance\n        // This could be: $20M of maxRewardsAvailable which gets paid .01 SHER per second (max rate) for 3 months worth of seconds\n        // Calculation continues after this\n        _sher = (maxRewardsAvailable * maxRewardsRate * _period) / DECIMALS;\n      }\n    }\n\n    // If there are SHER rewards still available (we didn't surpass zeroRewardsStartTVL)...\n    if (slopeRewardsAvailable != 0) {\n      // If the amount left is greater than the slope rewards available, we take all the remaining slope rewards\n      if (_amount > slopeRewardsAvailable) _amount = slopeRewardsAvailable;\n\n      // We take the average position on the slope that the stake amount occupies\n      // This excludes any stake amount <= maxRewardsEndTVL or >= zeroRewardsStartTVL_\n      // e.g. if tvl = 100m (and maxRewardsEndTVL is $100M), 50m is deposited, point at 125m is taken\n      uint256 position = _tvl + (_amount / 2);\n\n      // Calc SHER rewards based on position on the curve\n      // (zeroRewardsStartTVL - position) divided by (zeroRewardsStartTVL - maxRewardsEndTVL) gives the % of max rewards the amount should get\n      // Multiply this percentage by maxRewardsRate to get the rate at which this position should accrue SHER\n      // Multiply by the _amount to get the full SHER amount earned per second\n      // Multiply by the _period to get the total SHER amount owed to this position\n      _sher +=\n        (((zeroRewardsStartTVL - position) * _amount * maxRewardsRate * _period) /\n          (zeroRewardsStartTVL - maxRewardsEndTVL)) /\n        DECIMALS;\n    }\n  }\n\n  /// @notice Function used to check if this is the current active distribution manager\n  /// @return Boolean indicating it's active\n  /// @dev If inactive the owner can pull all ERC20s and ETH\n  /// @dev Will be checked by calling the sherlock contract\n  function isActive() public view override returns (bool) {\n    return address(sherlockCore.sherDistributionManager()) == address(this);\n  }\n\n  // Only contract owner can call this\n  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)\n  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {\n    if (_receiver == address(0)) revert ZeroArgument();\n    // This contract must NOT be the current assigned distribution manager contract\n    if (isActive()) revert InvalidConditions();\n    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH\n    _sweep(_receiver, _extraTokens);\n  }\n}\ncontract SherlockProtocolManager is ISherlockProtocolManager, Manager {\n  using SafeERC20 for IERC20;\n\n  // Represents the token that protocols pay with (currently USDC)\n  IERC20 public immutable token;\n\n  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed\n  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc\n\n  // A removed protocol is still able to make a claim for this amount of time after its removal\n  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;\n\n  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance\n  uint256 public constant MIN_SECONDS_LEFT = 7 days;\n\n  // Convenient for percentage calculations\n  uint256 internal constant HUNDRED_PERCENT = 10**18;\n\n  // The minimum active \"seconds of coverage left\" a protocol must have before arbitragers can remove the protocol from coverage\n  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying\n  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;\n\n  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)\n  mapping(bytes32 => address) internal protocolAgent_;\n\n  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)\n  mapping(bytes32 => uint256) internal nonStakersPercentage;\n\n  // The premium per second paid by each protocol is stored in this mapping\n  mapping(bytes32 => uint256) internal premiums_;\n\n  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.\n  // This \"active balance\" is really just an accounting concept, doesn't mean tokens have been transferred or not\n  mapping(bytes32 => uint256) internal activeBalances;\n\n  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol\n  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;\n\n  // The amount that can be claimed by nonstakers for each protocol\n  // We need this value so we can track how much payment is coming from each protocol\n  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;\n\n  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)\n  uint256 internal lastAccountedGlobal;\n\n  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)\n  uint256 internal allPremiumsPerSecToStakers;\n\n  // This is the amount that was claimable by stakers the last time the accounting was run\n  // The claimable amount presumably changes every second so this value is marked \"last\" because it is usually out-of-date\n  uint256 internal lastClaimablePremiumsForStakers;\n\n  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage\n  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)\n  uint256 public override minActiveBalance;\n\n  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)\n  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;\n\n  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)\n  mapping(bytes32 => address) internal removedProtocolAgent;\n\n  // Current amount of coverage (i.e. 20M USDC) for a protocol\n  mapping(bytes32 => uint256) internal currentCoverage;\n\n  // Previous amount of coverage for a protocol\n  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount\n  mapping(bytes32 => uint256) internal previousCoverage;\n\n  // Setting the token to USDC\n  constructor(IERC20 _token) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    token = _token;\n  }\n\n  // Modifier used to ensure a protocol exists (has been instantiated and not removed)\n  modifier protocolExists(bytes32 _protocol) {\n    _verifyProtocolExists(_protocol);\n    _;\n  }\n\n  /// @notice View current protocolAgent of `_protocol`\n  /// @param _protocol Protocol identifier\n  /// @return Address able to submit claims\n  function protocolAgent(bytes32 _protocol) external view override returns (address) {\n    address agent = protocolAgent_[_protocol];\n    if (agent != address(0)) return agent;\n\n    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned\n    // Note: Old protocol agent will never be address(0)\n    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {\n      return removedProtocolAgent[_protocol];\n    }\n\n    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned\n    revert ProtocolNotExists(_protocol);\n  }\n\n  // Checks if the protocol exists, then returns the current premium per second being charged\n  /// @notice View current premium of protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of premium `_protocol` pays per second\n  function premium(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return premiums_[_protocol];\n  }\n\n  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)\n  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)\n  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {\n    _protocolAgent = protocolAgent_[_protocol];\n    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);\n  }\n\n  //\n  // View methods\n  //\n\n  // Calcs the debt accrued by the protocol since it last had an accounting update\n  // This is the amount that needs to be removed from a protocol's active balance\n  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {\n    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];\n  }\n\n  /// @notice View the amount nonstakers can claim from this protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of tokens claimable by nonstakers\n  /// @dev this reads from a storage variable + (now-lastsettled) * premiums\n  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]\n  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed\n  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {\n    // Calcs the debt of a protocol since the last accounting update\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    // Gets the active balance of the protocol\n    uint256 balance = activeBalances[_protocol];\n    // The debt should never be higher than the balance (only happens if the arbitrages fail)\n    if (debt > balance) debt = balance;\n\n    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount\n    return\n      nonStakersClaimableByProtocol[_protocol] +\n      (nonStakersPercentage[_protocol] * debt) /\n      HUNDRED_PERCENT;\n  }\n\n  /// @notice View current amount of all premiums that are owed to stakers\n  /// @return Premiums claimable\n  /// @dev Will increase every block\n  /// @dev base + (now - last_settled) * ps\n  function claimablePremiums() public view override returns (uint256) {\n    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)\n    return\n      lastClaimablePremiumsForStakers +\n      (block.timestamp - lastAccountedGlobal) *\n      allPremiumsPerSecToStakers;\n  }\n\n  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance\n  /// @param _protocol Protocol identifier\n  /// @return Seconds of coverage left\n  function secondsOfCoverageLeft(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return _secondsOfCoverageLeft(_protocol);\n  }\n\n  // Helper function to return seconds of coverage left for a protocol\n  // Gets the current active balance of the protocol and divides by the premium per second for the protocol\n  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {\n    uint256 premium = premiums_[_protocol];\n    if (premium == 0) return 0;\n    return _activeBalance(_protocol) / premium;\n  }\n\n  /// @notice View current active balance of covered protocol\n  /// @param _protocol Protocol identifier\n  /// @return Active balance\n  /// @dev Accrued debt is subtracted from the stored active balance\n  function activeBalance(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return _activeBalance(_protocol);\n  }\n\n  // Helper function to calc the active balance of a protocol at current time\n  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    uint256 balance = activeBalances[_protocol];\n    // The debt should never be higher than the balance (only happens if the arbitrages fail)\n    if (debt > balance) return 0;\n    return balance - debt;\n  }\n\n  //\n  // State methods\n  //\n\n  /// @notice Helps set the premium per second for an individual protocol\n  /// @param _protocol Protocol identifier\n  /// @param _premium New premium per second\n  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function\n  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)\n    internal\n    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)\n  {\n    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers\n    // Also updates the last accounted timestamp for this protocol\n    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings\n    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol\n    nonStakerPercentage = _settleProtocolDebt(_protocol);\n    // Stores the old premium before it gets updated\n    oldPremiumPerSecond = premiums_[_protocol];\n\n    if (oldPremiumPerSecond != _premium) {\n      // Sets the protocol's premium per second to the new value\n      premiums_[_protocol] = _premium;\n      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);\n    }\n    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing\n    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes\n    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point\n    // Where arbs would no longer be incentivized to remove the protocol\n    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems\n    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {\n      revert InsufficientBalance(_protocol);\n    }\n  }\n\n  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second\n  /// @param _protocol Protocol identifier\n  /// @param _premium New premium per second\n  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {\n    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings\n    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(\n      _protocol,\n      _premium\n    );\n    // Settling the total amount of premiums owed to stakers before a new premium per second gets set\n    _settleTotalDebt();\n    // This calculates the new global premium per second that gets paid to stakers\n    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function\n    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(\n      oldPremiumPerSecond,\n      _premium,\n      nonStakerPercentage,\n      nonStakerPercentage,\n      allPremiumsPerSecToStakers\n    );\n  }\n\n  // Internal function to set a new protocolAgent for a specific protocol\n  // _oldAgent is only included as part of emitting an event\n  function _setProtocolAgent(\n    bytes32 _protocol,\n    address _oldAgent,\n    address _protocolAgent\n  ) internal {\n    protocolAgent_[_protocol] = _protocolAgent;\n    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);\n  }\n\n  // Subtracts the accrued debt from a protocol's active balance\n  // Credits the amount that can be claimed by nonstakers for this protocol\n  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings\n  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs\n  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {\n    // This calcs the accrued debt of the protocol since it was last updated\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    // This pulls the percentage that is sent to nonstakers\n    _nonStakerPercentage = nonStakersPercentage[_protocol];\n    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly\n    if (debt != 0) {\n      // Pulls the stored active balance of the protocol\n      uint256 balance = activeBalances[_protocol];\n      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance\n      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point\n      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage\n      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up\n      if (debt > balance) {\n        // This error amount represents the magnitude of the mistake\n        uint256 error = debt - balance;\n        // Gets the latest value of claimable premiums for stakers\n        _settleTotalDebt();\n        // @note to production, set premium first to zero before solving accounting issue.\n        // otherwise the accounting error keeps increasing\n        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;\n\n        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%\n        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /\n          HUNDRED_PERCENT;\n\n        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short\n        uint256 insufficientTokens;\n\n        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally\n        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error\n        // This first line can be true if claimPremiumsForStakers() has been called and\n        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still\n        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {\n          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;\n          lastClaimablePremiumsForStakers = 0;\n        } else {\n          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums\n          // By the amount that was added in error (error) and insufficientTokens = 0\n          lastClaimablePremiumsForStakers =\n            lastClaimablePremiumsForStakers_ -\n            claimablePremiumError;\n        }\n\n        // If two events are thrown, the values need to be summed up for the actual state.\n        // This means an error of this type will continue until it is handled\n        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);\n        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case\n        debt = balance;\n      }\n      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance\n      activeBalances[_protocol] = balance - debt;\n      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol\n      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;\n    }\n    // Updates the last accounted timestamp for this protocol\n    lastAccountedEachProtocol[_protocol] = block.timestamp;\n  }\n\n  // Multiplies the total premium per second * number of seconds since the last global accounting update\n  // And adds it to the total claimable amount for stakers\n  function _settleTotalDebt() internal {\n    lastClaimablePremiumsForStakers +=\n      (block.timestamp - lastAccountedGlobal) *\n      allPremiumsPerSecToStakers;\n    lastAccountedGlobal = block.timestamp;\n  }\n\n  // Calculates the global premium per second for stakers\n  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers\n  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones\n  function _calcGlobalPremiumPerSecForStakers(\n    uint256 _premiumOld,\n    uint256 _premiumNew,\n    uint256 _nonStakerPercentageOld,\n    uint256 _nonStakerPercentageNew,\n    uint256 _inMemAllPremiumsPerSecToStakers\n  ) internal pure returns (uint256) {\n    return\n      _inMemAllPremiumsPerSecToStakers +\n      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /\n      HUNDRED_PERCENT -\n      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /\n      HUNDRED_PERCENT;\n  }\n\n  // Helper function to remove and clean up a protocol from Sherlock\n  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made\n  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {\n    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol\n    _setSingleAndGlobalProtocolPremium(_protocol, 0);\n\n    // Grabs the protocol's active balance\n    uint256 balance = activeBalances[_protocol];\n\n    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent\n    if (balance != 0) {\n      delete activeBalances[_protocol];\n      token.safeTransfer(_agent, balance);\n\n      emit ProtocolBalanceWithdrawn(_protocol, balance);\n    }\n\n    // Sets the protocol agent to zero address (as part of clean up)\n    _setProtocolAgent(_protocol, _agent, address(0));\n\n    // Cleans up other mappings for this protocol\n    delete nonStakersPercentage[_protocol];\n    delete lastAccountedEachProtocol[_protocol];\n    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above\n\n    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol\n    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;\n\n    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed\n    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked\n    removedProtocolAgent[_protocol] = _agent;\n\n    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));\n    emit ProtocolRemoved(_protocol);\n  }\n\n  /// @notice Sets the minimum active balance before an arb can remove a protocol\n  /// @param _minActiveBalance Minimum balance needed (in USDC)\n  /// @dev Only gov\n  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {\n    // New value cannot be the same as current value\n    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();\n    // Can't set a value that is too high to be reasonable\n    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();\n\n    emit MinBalance(minActiveBalance, _minActiveBalance);\n    minActiveBalance = _minActiveBalance;\n  }\n\n  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol\n  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens\n  /// @param _receiver Address to receive tokens\n  /// @dev Only callable by nonstakers role\n  function nonStakersClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver\n  ) external override whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_amount == uint256(0)) revert ZeroArgument();\n    if (_receiver == address(0)) revert ZeroArgument();\n    // Only the nonstakers role (multisig or contract) can pull the funds\n    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();\n\n    // Call can't be executed on protocol that is removed\n    if (protocolAgent_[_protocol] != address(0)) {\n      // Updates the amount that nonstakers can claim from this protocol\n      _settleProtocolDebt(_protocol);\n    }\n\n    // Sets balance to the amount that is claimable by nonstakers for this specific protocol\n    uint256 balance = nonStakersClaimableByProtocol[_protocol];\n    // If the amount requested is more than what's owed to nonstakers, revert\n    if (_amount > balance) revert InsufficientBalance(_protocol);\n\n    // Sets the claimable amount to whatever is left over after this amount is pulled\n    nonStakersClaimableByProtocol[_protocol] = balance - _amount;\n    // Transfers the amount requested to the `_receiver` address\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)\n  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address\n  /// @dev Callable by everyone\n  /// @dev Funds will be transferred to Sherlock core contract\n  function claimPremiumsForStakers() external override whenNotPaused {\n    // Gets address of core Sherlock contract\n    address sherlock = address(sherlockCore);\n    // Revert if core Sherlock contract not initialized yet\n    if (sherlock == address(0)) revert InvalidConditions();\n\n    // claimablePremiums is different from _settleTotalDebt() because it does not change state\n    // Retrieves current amount of all premiums that are owed to stakers\n    uint256 amount = claimablePremiums();\n\n    // Transfers all the premiums owed to stakers to the Sherlock core contract\n    if (amount != 0) {\n      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out\n      lastClaimablePremiumsForStakers = 0;\n      lastAccountedGlobal = block.timestamp;\n      token.safeTransfer(sherlock, amount);\n    }\n  }\n\n  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts\n  /// @param _protocol Protocol identifier\n  /// @return current and previous are the current and previous coverage amounts for this protocol\n  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)\n  function coverageAmounts(bytes32 _protocol)\n    external\n    view\n    override\n    returns (uint256 current, uint256 previous)\n  {\n    // Checks to see if the protocol has an active protocolAgent (protocol not removed)\n    // OR checks to see if the removed protocol is still within the claim window\n    // If so, gives the current and previous coverage, otherwise throws an error\n    if (\n      protocolAgent_[_protocol] != address(0) ||\n      block.timestamp <= removedProtocolClaimDeadline[_protocol]\n    ) {\n      return (currentCoverage[_protocol], previousCoverage[_protocol]);\n    }\n\n    revert ProtocolNotExists(_protocol);\n  }\n\n  /// @notice Add a new protocol to Sherlock\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim\n  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point\n  /// @dev `_nonStakers` is scaled by 10**18\n  /// @dev Only callable by governance\n  function protocolAdd(\n    bytes32 _protocol,\n    address _protocolAgent,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) external override onlyOwner {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_protocolAgent == address(0)) revert ZeroArgument();\n    // Checks to make sure the protocol doesn't exist already\n    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();\n\n    // Updates the protocol agent and passes in the old agent which is 0 address in this case\n    _setProtocolAgent(_protocol, address(0), _protocolAgent);\n\n    // Delete mappings that are potentially non default values\n    // From previous time protocol was added/removed\n    delete removedProtocolClaimDeadline[_protocol];\n    delete removedProtocolAgent[_protocol];\n    delete currentCoverage[_protocol];\n    delete previousCoverage[_protocol];\n\n    emit ProtocolAdded(_protocol);\n\n    // Most of the logic for actually adding a protocol in this function\n    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);\n  }\n\n  /// @notice Update info regarding a protocol\n  /// @param _protocol Protocol identifier\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Only callable by governance\n  /// @dev `_nonStakers` can be 0\n  function protocolUpdate(\n    bytes32 _protocol,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) public override onlyOwner {\n    if (_coverage == bytes32(0)) revert ZeroArgument();\n    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();\n    if (_coverageAmount == uint256(0)) revert ZeroArgument();\n\n    // Checks to make sure the protocol has been assigned a protocol agent\n    _verifyProtocolExists(_protocol);\n\n    // Subtracts the accrued debt from a protocol's active balance (if any)\n    // Updates the amount that can be claimed by nonstakers\n    _settleProtocolDebt(_protocol);\n\n    // Updates the global claimable amount for stakers\n    _settleTotalDebt();\n\n    // Gets the premium per second for this protocol\n    uint256 premium = premiums_[_protocol];\n\n    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)\n    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(\n      premium,\n      premium,\n      nonStakersPercentage[_protocol],\n      _nonStakers,\n      allPremiumsPerSecToStakers\n    );\n\n    // Updates the stored value of percentage of premiums that go to nonstakers\n    nonStakersPercentage[_protocol] = _nonStakers;\n\n    // Updates previous coverage and current coverage amounts\n    previousCoverage[_protocol] = currentCoverage[_protocol];\n    currentCoverage[_protocol] = _coverageAmount;\n\n    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);\n  }\n\n  /// @notice Remove a protocol from coverage\n  /// @param _protocol Protocol identifier\n  /// @dev Before removing a protocol the premium must be 0\n  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)\n  /// @dev Pays off debt + sends remaining balance to protocol agent\n  /// @dev This call should be subject to a timelock\n  /// @dev Only callable by governance\n  function protocolRemove(bytes32 _protocol) external override onlyOwner {\n    // checks to make sure the protocol actually has a protocol agent\n    address agent = _verifyProtocolExists(_protocol);\n\n    // Removes a protocol from Sherlock and cleans up its data\n    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made\n    _forceRemoveProtocol(_protocol, agent);\n  }\n\n  /// @notice Remove a protocol with insufficient active balance\n  /// @param _protocol Protocol identifier\n  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function\n  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {\n    address agent = _verifyProtocolExists(_protocol);\n\n    // Gets the latest value of the active balance at this protocol\n    _settleProtocolDebt(_protocol);\n    // Sets latest value of active balance to remainingBalance variable\n    uint256 remainingBalance = activeBalances[_protocol];\n\n    // This means the protocol still has adequate active balance and thus cannot be removed\n    if (remainingBalance >= minActiveBalance) revert InvalidConditions();\n\n    // Sets the protocol's active balance to 0\n    delete activeBalances[_protocol];\n    // Removes the protocol from coverage\n    _forceRemoveProtocol(_protocol, agent);\n\n    if (remainingBalance != 0) {\n      // sends the remaining balance to msg.sender\n      token.safeTransfer(msg.sender, remainingBalance);\n    }\n    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);\n  }\n\n  /// @notice Calculate if arb is possible and what the reward would be\n  /// @param _protocol Protocol identifier\n  /// @return arbAmount Amount reward for arbing\n  /// @return able Indicator if arb call is even possible\n  /// @dev Doesn't subtract the current protocol debt from the active balance\n  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)\n    internal\n    view\n    returns (uint256 arbAmount, bool able)\n  {\n    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);\n\n    // If arb is not possible return false\n    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);\n\n    // This percentage scales over time\n    // Reaches 100% on 0 seconds of coverage left\n    uint256 percentageScaled = HUNDRED_PERCENT -\n      (secondsLeft * HUNDRED_PERCENT) /\n      MIN_SECONDS_OF_COVERAGE;\n\n    able = true;\n    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;\n  }\n\n  /// @notice Removes a protocol with insufficent seconds of coverage left\n  /// @param _protocol Protocol identifier\n  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second\n  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {\n    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings\n    address agent = _verifyProtocolExists(_protocol);\n\n    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()\n    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()\n    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large\n    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance\n    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)\n    _settleProtocolDebt(_protocol);\n    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);\n    if (able == false) revert InvalidConditions();\n\n    if (arbAmount != 0) {\n      // subtracts the amount that will be paid to the arb from the active balance\n      activeBalances[_protocol] -= arbAmount;\n    }\n\n    // Removes the protocol from coverage\n    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above\n    _forceRemoveProtocol(_protocol, agent);\n\n    // Done after removing protocol to mitigate reentrency pattern\n    // (In case token allows callback)\n    if (arbAmount != 0) {\n      token.safeTransfer(msg.sender, arbAmount);\n    }\n    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);\n  }\n\n  /// @notice Set premium of `_protocol` to `_premium`\n  /// @param _protocol Protocol identifier\n  /// @param _premium Amount of premium `_protocol` pays per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {\n    // Checks to see if protocol has a protocol agent\n    _verifyProtocolExists(_protocol);\n\n    // Updates individual protocol's premium and allPremiumsPerSecToStakers\n    _setSingleAndGlobalProtocolPremium(_protocol, _premium);\n  }\n\n  /// @notice Set premium of multiple protocols\n  /// @param _protocol Array of protocol identifiers\n  /// @param _premium Array of premium amounts protocols pay per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)\n    external\n    override\n    onlyOwner\n  {\n    // Checks to make sure there are an equal amount of entries in each array\n    if (_protocol.length != _premium.length) revert UnequalArrayLength();\n    if (_protocol.length == 0) revert InvalidArgument();\n\n    // Updates the global claimable amount for stakers\n    _settleTotalDebt();\n\n    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;\n\n    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned\n    for (uint256 i; i < _protocol.length; i++) {\n      _verifyProtocolExists(_protocol[i]);\n\n      // Sets the protocol premium for that specific protocol\n      // Function returns the old premium and nonStakerPercentage for that specific protocol\n      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(\n        _protocol[i],\n        _premium[i]\n      );\n\n      // Calculates the new global premium which adds up all premiums paid by all protocols\n      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(\n        oldPremiumPerSecond,\n        _premium[i],\n        nonStakerPercentage,\n        nonStakerPercentage,\n        allPremiumsPerSecToStakers_\n      );\n    }\n\n    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value\n    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;\n  }\n\n  // This is how protocols pay for coverage by increasing their active balance\n  /// @notice Deposits `_amount` of token to the active balance of `_protocol`\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to deposit\n  /// @dev Approval should be made before calling\n  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)\n    external\n    override\n    whenNotPaused\n  {\n    if (_amount == uint256(0)) revert ZeroArgument();\n    _verifyProtocolExists(_protocol);\n\n    // Transfers _amount to this contract\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n    // Increases the active balance of the protocol by _amount\n    activeBalances[_protocol] += _amount;\n\n    emit ProtocolBalanceDeposited(_protocol, _amount);\n  }\n\n  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)\n  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)\n  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to withdraw\n  /// @dev Only protocol agent is able to withdraw\n  /// @dev Balance can be withdrawn up until 7 days worth of active balance\n  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)\n    external\n    override\n    whenNotPaused\n  {\n    if (_amount == uint256(0)) revert ZeroArgument();\n    // Only the protocol agent can call this function\n    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();\n\n    // Updates the active balance of the protocol\n    _settleProtocolDebt(_protocol);\n\n    // Sets currentBalance to the active balance of the protocol\n    uint256 currentBalance = activeBalances[_protocol];\n    // Reverts if trying to withdraw more than the active balance\n    if (_amount > currentBalance) revert InsufficientBalance(_protocol);\n\n    // Removes the _amount to be withdrawn from the active balance\n    activeBalances[_protocol] = currentBalance - _amount;\n    // Reverts if a protocol has less than 7 days worth of active balance left\n    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);\n\n    // Transfers the amount to the msg.sender (protocol agent)\n    token.safeTransfer(msg.sender, _amount);\n    emit ProtocolBalanceWithdrawn(_protocol, _amount);\n  }\n\n  /// @notice Transfer protocol agent role\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol\n  /// @dev Only the active protocolAgent is able to transfer the role\n  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)\n    external\n    override\n    whenNotPaused\n  {\n    if (_protocolAgent == address(0)) revert ZeroArgument();\n    // Can't set the new protocol agent to the caller address\n    if (msg.sender == _protocolAgent) revert InvalidArgument();\n    // Because the caller must be the current protocol agent\n    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();\n\n    // Sets the protocol agent to the new address\n    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);\n  }\n\n  /// @notice Function used to check if this is the current active protocol manager\n  /// @return Boolean indicating it's active\n  /// @dev If inactive the owner can pull all ERC20s and ETH\n  /// @dev Will be checked by calling the sherlock contract\n  function isActive() public view returns (bool) {\n    return address(sherlockCore.sherlockProtocolManager()) == address(this);\n  }\n\n  // Only contract owner can call this\n  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)\n  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {\n    if (_receiver == address(0)) revert ZeroArgument();\n    // This contract must NOT be the current assigned protocol manager contract\n    if (isActive()) revert InvalidConditions();\n    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH\n    _sweep(_receiver, _extraTokens);\n  }\n}\nabstract contract SkinnyOptimisticOracleInterface {\n  event RequestPrice(\n    address indexed requester,\n    bytes32 indexed identifier,\n    uint32 timestamp,\n    bytes ancillaryData,\n    Request request\n  );\n  event ProposePrice(\n    address indexed requester,\n    bytes32 indexed identifier,\n    uint32 timestamp,\n    bytes ancillaryData,\n    Request request\n  );\n  event DisputePrice(\n    address indexed requester,\n    bytes32 indexed identifier,\n    uint32 timestamp,\n    bytes ancillaryData,\n    Request request\n  );\n  event Settle(\n    address indexed requester,\n    bytes32 indexed identifier,\n    uint32 timestamp,\n    bytes ancillaryData,\n    Request request\n  );\n  // Struct representing a price request. Note that this differs from the OptimisticOracleInterface's Request struct\n  // in that refundOnDispute is removed.\n  struct Request {\n    address proposer; // Address of the proposer.\n    address disputer; // Address of the disputer.\n    IERC20 currency; // ERC20 token used to pay rewards and fees.\n    bool settled; // True if the request is settled.\n    int256 proposedPrice; // Price that the proposer submitted.\n    int256 resolvedPrice; // Price resolved once the request is settled.\n    uint256 expirationTime; // Time at which the request auto-settles without a dispute.\n    uint256 reward; // Amount of the currency to pay to the proposer on settlement.\n    uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\n    uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\n    uint256 customLiveness; // Custom liveness value set by the requester.\n  }\n\n  // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\n  // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\n  // to accept a price request made with ancillary data length over a certain size.\n  uint256 public constant ancillaryBytesLimit = 8192;\n\n  /**\n   * @notice Requests a new price.\n   * @param identifier price identifier being requested.\n   * @param timestamp timestamp of the price being requested.\n   * @param ancillaryData ancillary data representing additional args being passed with the price request.\n   * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n   * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n   *               which could make sense if the contract requests and proposes the value in the same call or\n   *               provides its own reward system.\n   * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\n   * @param customLiveness custom proposal liveness to set for request.\n   * @return totalBond default bond + final fee that the proposer and disputer will be required to pay.\n   */\n  function requestPrice(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    IERC20 currency,\n    uint256 reward,\n    uint256 bond,\n    uint256 customLiveness\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\n   * from this proposal. However, any bonds are pulled from the caller.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters whose hash must match the request that the caller wants to\n   * propose a price for.\n   * @param proposer address to set as the proposer.\n   * @param proposedPrice price being proposed.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the proposer once settled if the proposal is correct.\n   */\n  function proposePriceFor(\n    address requester,\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request,\n    address proposer,\n    int256 proposedPrice\n  ) public virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Proposes a price value where caller is the proposer.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters whose hash must match the request that the caller wants to\n   * propose a price for.\n   * @param proposedPrice price being proposed.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the proposer once settled if the proposal is correct.\n   */\n  function proposePrice(\n    address requester,\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request,\n    int256 proposedPrice\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Combines logic of requestPrice and proposePrice while taking advantage of gas savings from not having to\n   * overwrite Request params that a normal requestPrice() => proposePrice() flow would entail. Note: The proposer\n   * will receive any rewards that come from this proposal. However, any bonds are pulled from the caller.\n   * @dev The caller is the requester, but the proposer can be customized.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n   * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n   *               which could make sense if the contract requests and proposes the value in the same call or\n   *               provides its own reward system.\n   * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\n   * @param customLiveness custom proposal liveness to set for request.\n   * @param proposer address to set as the proposer.\n   * @param proposedPrice price being proposed.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the proposer once settled if the proposal is correct.\n   */\n  function requestAndProposePriceFor(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    IERC20 currency,\n    uint256 reward,\n    uint256 bond,\n    uint256 customLiveness,\n    address proposer,\n    int256 proposedPrice\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\n   * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters whose hash must match the request that the caller wants to\n   * dispute.\n   * @param disputer address to set as the disputer.\n   * @param requester sender of the initial price request.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the disputer once settled if the dispute was valid (the proposal was incorrect).\n   */\n  function disputePriceFor(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request,\n    address disputer,\n    address requester\n  ) public virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Disputes a price request with an active proposal where caller is the disputer.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters whose hash must match the request that the caller wants to\n   * dispute.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the disputer once settled if the dispute was valid (the proposal was incorrect).\n   */\n  function disputePrice(\n    address requester,\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters whose hash must match the request that the caller wants to\n   * settle.\n   * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\n   * the returned bonds as well as additional rewards.\n   * @return resolvedPrice the price that the request settled to.\n   */\n  function settle(\n    address requester,\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request\n  ) external virtual returns (uint256 payout, int256 resolvedPrice);\n\n  /**\n   * @notice Computes the current state of a price request. See the State enum for more details.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters.\n   * @return the State.\n   */\n  function getState(\n    address requester,\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request\n  ) external virtual returns (OptimisticOracleInterface.State);\n\n  /**\n   * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters. The hash of these parameters must match with the request hash that is\n   * associated with the price request unique ID {requester, identifier, timestamp, ancillaryData}, or this method\n   * will revert.\n   * @return boolean indicating true if price exists and false if not.\n   */\n  function hasPrice(\n    address requester,\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request\n  ) public virtual returns (bool);\n\n  /**\n   * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param requester sender of the initial price request.\n   * @return the stamped ancillary bytes.\n   */\n  function stampAncillaryData(bytes memory ancillaryData, address requester)\n    public\n    pure\n    virtual\n    returns (bytes memory);\n}\nabstract contract Manager is IManager, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  address private constant DEPLOYER = 0xAdBb28C2FEe078440B7088bbcd68DCfA63e55625;\n  ISherlock internal sherlockCore;\n\n  modifier onlySherlockCore() {\n    if (msg.sender != address(sherlockCore)) revert InvalidSender();\n    _;\n  }\n\n  /// @notice Set sherlock core address\n  /// @param _sherlock Current core contract\n  /// @dev Only deployer is able to set core address on all chains except Hardhat network\n  /// @dev One time function, will revert once `sherlock` != address(0)\n  /// @dev This contract will be deployed first, passed on as argument in core constuctor\n  /// @dev emits `SherlockCoreSet`\n  function setSherlockCoreAddress(ISherlock _sherlock) external override {\n    if (address(_sherlock) == address(0)) revert ZeroArgument();\n    // 31337 is of the Hardhat network blockchain\n    if (block.chainid != 31337 && msg.sender != DEPLOYER) revert InvalidSender();\n\n    if (address(sherlockCore) != address(0)) revert InvalidConditions();\n    sherlockCore = _sherlock;\n\n    emit SherlockCoreSet(_sherlock);\n  }\n\n  // Internal function to send tokens remaining in a contract to the receiver address\n  function _sweep(address _receiver, IERC20[] memory _extraTokens) internal {\n    // Loops through the extra tokens (ERC20) provided and sends all of them to the receiver address\n    for (uint256 i; i < _extraTokens.length; i++) {\n      IERC20 token = _extraTokens[i];\n      token.safeTransfer(_receiver, token.balanceOf(address(this)));\n    }\n    // Sends any remaining ETH to the receiver address (as long as receiver address is payable)\n    (bool success, ) = _receiver.call{ value: address(this).balance }('');\n    if (success == false) revert InvalidConditions();\n  }\n\n  function pause() external onlySherlockCore {\n    _pause();\n  }\n\n  function unpause() external onlySherlockCore {\n    _unpause();\n  }\n}\ncontract SherlockClaimManager is ISherlockClaimManager, ReentrancyGuard, Manager {\n  using SafeERC20 for IERC20;\n\n  // The bond required for a protocol agent to escalate a claim to UMA Optimistic Oracle (OO)\n  /// @dev at time of writing will result in a 20k cost of escalating\n  /// @dev the actual amount is based on the value returned here https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/Store.sol#L131\n  uint256 internal constant BOND = 9_600 * 10**6; // 20k bond\n\n  // The amount of time the protocol agent has to escalate a claim\n  uint256 public constant ESCALATE_TIME = 4 weeks;\n\n  // The UMA Halt Operator (UMAHO) is the multisig (controlled by UMA) who gives final approval to pay out a claim\n  // After the OO has voted to pay out\n  // This variable represents the amount of time during which UMAHO can block a claim that was approved by the OO\n  // After this time period, the claim (which was approved by the OO) is inferred to be approved by UMAHO as well\n  uint256 public constant UMAHO_TIME = 24 hours;\n\n  // The amount of time the Sherlock Protocol Claims Committee (SPCC) gets to decide on a claim\n  // If no action is taken by SPCC during this time, then the protocol agent can escalate the decision to the UMA OO\n  uint256 public constant SPCC_TIME = 7 days;\n\n  // A pre-defined amount of time for the proposed price ($0) to be disputed within the OO\n  // Note This value is not important as we immediately dispute the proposed price\n  // 7200 represents 2 hours\n  uint256 internal constant LIVENESS = 7200;\n\n  // This is how UMA will know that Sherlock is requesting a decision from the OO\n  // This is \"SHERLOCK_CLAIM\" in hex value\n  bytes32 public constant override UMA_IDENTIFIER =\n    bytes32(0x534845524c4f434b5f434c41494d000000000000000000000000000000000000);\n\n  uint256 public constant MAX_CALLBACKS = 4;\n\n  // The Optimistic Oracle contract that we interact with\n  SkinnyOptimisticOracleInterface public constant UMA =\n    SkinnyOptimisticOracleInterface(0xeE3Afe347D5C74317041E2618C49534dAf887c24);\n\n  // USDC\n  IERC20 public constant TOKEN = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n\n  // The address of the multisig controlled by UMA that can emergency halt a claim that was approved by the OO\n  address public override umaHaltOperator;\n  // The address of the multisig controlled by Sherlock advisors who make the first judgment on a claim\n  address public immutable override sherlockProtocolClaimsCommittee;\n\n  // Takes a protocol's internal ID as a key and whether or not the protocol has a claim active as the value\n  // Note Each protocol can only have one claim active at a time (this prevents spam)\n  mapping(bytes32 => bool) public protocolClaimActive;\n\n  // A protocol's public claim ID is simply incremented by 1 from the last claim ID made by any protocol (1, 2, 3, etc.)\n  // A protocol's internal ID is the keccak256() of a protocol's ancillary data field\n  // A protocol's ancillary data field will contain info like the hash of the protocol's coverage agreement (each will be unique)\n  // The public ID (1, 2, 3, etc.) is easy to track while the internal ID is used for interacting with UMA\n  mapping(uint256 => bytes32) internal publicToInternalID;\n\n  // Opposite of the last field, allows us to move between a protocol's public ID and internal ID\n  mapping(bytes32 => uint256) internal internalToPublicID;\n\n  // Protocol's internal ID is the key, active claim is the value\n  // Claim object is initialized in startClaim() below\n  // See ISherlockClaimManager.sol for Claim struct\n  mapping(bytes32 => Claim) internal claims_;\n\n  // The last claim ID we used for a claim (ID is incremented by 1 each time)\n  uint256 internal lastClaimID;\n\n  // A request object used in the UMA OO\n  SkinnyOptimisticOracleInterface.Request private umaRequest;\n\n  // An array of contracts that implement the callback provided in this contract\n  ISherlockClaimManagerCallbackReceiver[] public claimCallbacks;\n\n  // Used for callbacks on UMA functions\n  // This modifier is used for a function being called by the OO contract, requires this contract as caller\n  // Requires the OO contract to pass in the Sherlock identifier\n  modifier onlyUMA(bytes32 identifier) {\n    if (identifier != UMA_IDENTIFIER) revert InvalidArgument();\n    if (msg.sender != address(UMA)) revert InvalidSender();\n    _;\n  }\n\n  // Only the Sherlock Claims Committee multisig can call a function with this modifier\n  modifier onlySPCC() {\n    if (msg.sender != sherlockProtocolClaimsCommittee) revert InvalidSender();\n    _;\n  }\n\n  // Only the UMA Halt Operator multisig can call a function with this modifier\n  modifier onlyUMAHO() {\n    if (msg.sender != umaHaltOperator) revert InvalidSender();\n    _;\n  }\n\n  // We pass in the contract addresses (both will be multisigs) in the constructor\n  constructor(address _umaho, address _spcc) {\n    if (_umaho == address(0)) revert ZeroArgument();\n    if (_spcc == address(0)) revert ZeroArgument();\n\n    umaHaltOperator = _umaho;\n    sherlockProtocolClaimsCommittee = _spcc;\n  }\n\n  // Checks to see if a claim can be escalated to the UMA OO\n  // Claim must be either\n  // 1) Denied by SPCC and within 4 weeks after denial\n  // 2) Beyond the designated time window for SPCC to respond\n  function _isEscalateState(State _oldState, uint256 updated) internal view returns (bool) {\n    if (_oldState == State.SpccDenied && block.timestamp <= updated + ESCALATE_TIME) return true;\n\n    uint256 spccDeadline = updated + SPCC_TIME;\n    if (\n      _oldState == State.SpccPending &&\n      spccDeadline < block.timestamp &&\n      block.timestamp <= spccDeadline + ESCALATE_TIME\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  // Checks to see if a claim can be paid out\n  // Will be paid out if:\n  // 1) SPCC approved it\n  // 2) UMA OO approved it and there is no UMAHO anymore\n  // 3) UMA OO approved it and the designated window for the UMAHO to block it has passed\n  function _isPayoutState(State _oldState, uint256 updated) internal view returns (bool) {\n    if (_oldState == State.SpccApproved) return true;\n\n    // If there is no UMA Halt Operator, then it can be paid out on UmaApproved state\n    if (umaHaltOperator == address(0)) {\n      if (_oldState == State.UmaApproved) return true;\n    } else {\n      // If there IS a nonzero UMAHO address, must wait for UMAHO halt period to pass\n      if (_oldState == State.UmaApproved && updated + UMAHO_TIME < block.timestamp) return true;\n    }\n    return false;\n  }\n\n  function _isCleanupState(State _oldState) internal pure returns (bool) {\n    if (_oldState == State.SpccDenied) return true;\n    if (_oldState == State.SpccPending) return true;\n    return false;\n  }\n\n  // Deletes the data associated with a claim (after claim has reached its final state)\n  // _claimIdentifier is the internal claim ID\n  function _cleanUpClaim(bytes32 _claimIdentifier) internal {\n    // Protocol no longer has an active claim associated with it\n    delete protocolClaimActive[claims_[_claimIdentifier].protocol];\n    // Claim object is deleted\n    delete claims_[_claimIdentifier];\n\n    uint256 publicID = internalToPublicID[_claimIdentifier];\n    // Deletes the public and internal ID key mappings\n    delete publicToInternalID[publicID];\n    delete internalToPublicID[_claimIdentifier];\n  }\n\n  // Each claim has a state that represents what part of the claims process it is in\n  // _claimIdentifier is the internal claim ID\n  // _state represents the state to which a protocol's state field will be changed\n  // See ISherlockClaimManager.sol for the State enum\n  function _setState(bytes32 _claimIdentifier, State _state) internal returns (State _oldState) {\n    // retrieves the Claim object\n    Claim storage claim = claims_[_claimIdentifier];\n    // retrieves the current state (which we preemptively set to the old state)\n    _oldState = claim.state;\n\n    emit ClaimStatusChanged(internalToPublicID[_claimIdentifier], _oldState, _state);\n\n    // If the new state is NonExistent, then we clean up this claim (delete the claim effectively)\n    // Else we update the state to the new state and record the last updated timestamp\n    if (_state == State.NonExistent) {\n      _cleanUpClaim(_claimIdentifier);\n    } else {\n      claims_[_claimIdentifier].state = _state;\n      claims_[_claimIdentifier].updated = block.timestamp;\n    }\n  }\n\n  // Allows us to remove the UMA Halt Operator multisig address if we decide we no longer need UMAHO's services\n  /// @notice gov is able to renounce the role\n  function renounceUmaHaltOperator() external override onlyOwner {\n    if (umaHaltOperator == address(0)) revert InvalidConditions();\n\n    delete umaHaltOperator;\n    emit UMAHORenounced();\n  }\n\n  // Returns the Claim struct for a given claim ID (function takes public ID but converts to internal ID)\n  function claim(uint256 _claimID) external view override returns (Claim memory claim_) {\n    bytes32 id_ = publicToInternalID[_claimID];\n    if (id_ == bytes32(0)) revert InvalidArgument();\n\n    claim_ = claims_[id_];\n    if (claim_.state == State.NonExistent) revert InvalidArgument();\n  }\n\n  // This function allows a new contract to be added that will implement PreCorePayoutCallback()\n  // The intention of this callback is to allow other contracts to trigger payouts, etc. when Sherlock triggers one\n  // This would be helpful for a reinsurer who should pay out when Sherlock pays out\n  // Data is passed to the \"reinsurer\" so it can know if it should pay out and how much\n  /// @dev only add trusted and gas verified callbacks.\n  function addCallback(ISherlockClaimManagerCallbackReceiver _callback)\n    external\n    onlyOwner\n    nonReentrant\n  {\n    if (address(_callback) == address(0)) revert ZeroArgument();\n    // Checks to see if the max amount of callback contracts has been reached\n    if (claimCallbacks.length == MAX_CALLBACKS) revert InvalidState();\n    // Checks to see if this callback contract already exists\n    for (uint256 i; i < claimCallbacks.length; i++) {\n      if (claimCallbacks[i] == _callback) revert InvalidArgument();\n    }\n\n    claimCallbacks.push(_callback);\n    emit CallbackAdded(_callback);\n  }\n\n  // This removes a contract from the claimCallbacks array\n  function removeCallback(ISherlockClaimManagerCallbackReceiver _callback, uint256 _index)\n    external\n    onlyOwner\n    nonReentrant\n  {\n    if (address(_callback) == address(0)) revert ZeroArgument();\n    // If the index and the callback contract don't line up, revert\n    if (claimCallbacks[_index] != _callback) revert InvalidArgument();\n\n    // Move last index to index of _callback\n    // Creates a copy of the last index value and pastes it over the _index value\n    claimCallbacks[_index] = claimCallbacks[claimCallbacks.length - 1];\n    // Remove last index (because it is now a duplicate)\n    claimCallbacks.pop();\n    emit CallbackRemoved(_callback);\n  }\n\n  /// @notice Cleanup claim if escalation is not pursued\n  /// @param _protocol protocol ID\n  /// @param _claimID public claim ID\n  /// @dev Retrieves current protocol agent for cleanup\n  /// @dev State is either SpccPending or SpccDenied\n  function cleanUp(bytes32 _protocol, uint256 _claimID) external whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_claimID == uint256(0)) revert ZeroArgument();\n\n    // Gets the instance of the protocol manager contract\n    ISherlockProtocolManager protocolManager = sherlockCore.sherlockProtocolManager();\n    // Gets the protocol agent associated with the protocol ID passed in\n    address agent = protocolManager.protocolAgent(_protocol);\n    // Caller of this function must be the protocol agent address associated with the protocol ID passed in\n    if (msg.sender != agent) revert InvalidSender();\n\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    // If there is no active claim\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    Claim storage claim = claims_[claimIdentifier];\n    // verify if claim belongs to protocol agent\n    if (claim.protocol != _protocol) revert InvalidArgument();\n\n    State _oldState = _setState(claimIdentifier, State.Cleaned);\n    if (_isCleanupState(_oldState) == false) revert InvalidState();\n    if (_setState(claimIdentifier, State.NonExistent) != State.Cleaned) revert InvalidState();\n  }\n\n  /// @notice Initiate a claim for a specific protocol as the protocol agent\n  /// @param _protocol protocol ID (different from the internal or public claim ID fields)\n  /// @param _amount amount of USDC which is being claimed by the protocol\n  /// @param _receiver address to receive the amount of USDC being claimed\n  /// @param _timestamp timestamp at which the exploit first occurred\n  /// @param ancillaryData other data associated with the claim, such as the coverage agreement\n  /// @dev The protocol agent that starts a claim will be the protocol agent during the claims lifecycle\n  /// @dev Even if the protocol agent role is tranferred during the lifecycle\n  /// @dev This is done because a protocols coverage can end after an exploit, either wilfully or forcefully.\n  /// @dev The protocol agent is still active for 7 days after coverage ends, so a claim can still be submitted.\n  /// @dev But in case the claim is approved after the 7 day period, `payoutClaim()` can not be called as the protocol agent is 0\n  function startClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver,\n    uint32 _timestamp,\n    bytes memory ancillaryData\n  ) external override nonReentrant whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_amount == uint256(0)) revert ZeroArgument();\n    if (_receiver == address(0)) revert ZeroArgument();\n    if (_timestamp == uint32(0)) revert ZeroArgument();\n    if (_timestamp >= block.timestamp) revert InvalidArgument();\n    if (ancillaryData.length == 0) revert ZeroArgument();\n    if (address(sherlockCore) == address(0)) revert InvalidConditions();\n    // Protocol must not already have another claim active\n    if (protocolClaimActive[_protocol]) revert ClaimActive();\n\n    // Creates the internal ID for this claim\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n    // State for this newly created claim must be equal to the default state (NonExistent)\n    if (claims_[claimIdentifier].state != State.NonExistent) revert InvalidArgument();\n\n    // Gets the instance of the protocol manager contract\n    ISherlockProtocolManager protocolManager = sherlockCore.sherlockProtocolManager();\n    // Gets the protocol agent associated with the protocol ID passed in\n    address agent = protocolManager.protocolAgent(_protocol);\n    // Caller of this function must be the protocol agent address associated with the protocol ID passed in\n    if (msg.sender != agent) revert InvalidSender();\n\n    // Gets the current and previous coverage amount for this protocol\n    (uint256 current, uint256 previous) = protocolManager.coverageAmounts(_protocol);\n    // The max amount a protocol can claim is the higher of the current and previous coverage amounts\n    uint256 maxClaim = current > previous ? current : previous;\n    // True if a protocol is claiming based on its previous coverage amount (only used in event emission)\n    bool prevCoverage = _amount > current;\n    // Requires the amount claimed is less than or equal to the higher of the current and previous coverage amounts\n    if (_amount > maxClaim) revert InvalidArgument();\n\n    // Increments the last claim ID by 1 to get the public claim ID\n    // Note initial claimID will be 1\n    uint256 claimID = ++lastClaimID;\n    // Protocol now has an active claim\n    protocolClaimActive[_protocol] = true;\n    // Sets the mappings for public and internal claim IDs\n    publicToInternalID[claimID] = claimIdentifier;\n    internalToPublicID[claimIdentifier] = claimID;\n\n    // Initializes a Claim object and adds it to claims_ mapping\n    // Created and updated fields are set to current time\n    // State is updated to SpccPending (waiting on SPCC decision now)\n    claims_[claimIdentifier] = Claim(\n      block.timestamp,\n      block.timestamp,\n      msg.sender,\n      _protocol,\n      _amount,\n      _receiver,\n      _timestamp,\n      State.SpccPending,\n      ancillaryData\n    );\n\n    emit ClaimCreated(claimID, _protocol, _amount, _receiver, prevCoverage);\n    emit ClaimStatusChanged(claimID, State.NonExistent, State.SpccPending);\n  }\n\n  // Only SPCC can call this\n  // SPCC approves the claim and it can now be paid out\n  // Requires that the last state of the claim was SpccPending\n  function spccApprove(uint256 _claimID) external override whenNotPaused onlySPCC nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    if (_setState(claimIdentifier, State.SpccApproved) != State.SpccPending) revert InvalidState();\n  }\n\n  // Only SPCC can call this\n  // SPCC denies the claim and now the protocol agent can escalate to UMA OO if they desire\n  function spccRefuse(uint256 _claimID) external override whenNotPaused onlySPCC nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    if (_setState(claimIdentifier, State.SpccDenied) != State.SpccPending) revert InvalidState();\n  }\n\n  // If SPCC denied (or didn't respond to) the claim, a protocol agent can now escalate it to UMA's OO\n  /// @notice Callable by protocol agent\n  /// @param _claimID Public claim ID\n  /// @param _amount Bond amount sent by protocol agent\n  /// @dev Use hardcoded USDC address\n  /// @dev Use hardcoded bond amount\n  /// @dev Use hardcoded liveness 7200 (2 hours)\n  /// @dev Requires the caller to be the account that initially started the claim\n  // Amount sent needs to be at least equal to the BOND amount required\n  function escalate(uint256 _claimID, uint256 _amount)\n    external\n    override\n    nonReentrant\n    whenNotPaused\n  {\n    if (_amount < BOND) revert InvalidArgument();\n\n    // Gets the internal ID of the claim\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    // Retrieves the claim struct\n    Claim storage claim = claims_[claimIdentifier];\n    // Requires the caller to be the account that initially started the claim\n    if (msg.sender != claim.initiator) revert InvalidSender();\n\n    // Timestamp when claim was last updated\n    uint256 updated = claim.updated;\n    // Sets the state to UmaPriceProposed\n    State _oldState = _setState(claimIdentifier, State.UmaPriceProposed);\n\n    // Can this claim be updated (based on its current state)? If no, revert\n    if (_isEscalateState(_oldState, updated) == false) revert InvalidState();\n\n    // Transfers the bond amount from the protocol agent to this address\n    TOKEN.safeTransferFrom(msg.sender, address(this), _amount);\n    // Approves the OO contract to spend the bond amount\n    TOKEN.safeApprove(address(UMA), _amount);\n\n    // Sherlock protocol proposes a claim amount of $0 to the UMA OO to begin with\n    // This line https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol#L585\n    // Will result in disputeSuccess=true if the DVM resolved price != 0\n    // Note: The resolved price needs to exactly match the claim amount\n    // Otherwise the `umaApproved` in our settled callback will be false\n    UMA.requestAndProposePriceFor(\n      UMA_IDENTIFIER, // Sherlock ID so UMA knows the request came from Sherlock\n      claim.timestamp, // Timestamp to identify the request\n      claim.ancillaryData, // Ancillary data such as the coverage agreement\n      TOKEN, // USDC\n      0, // Reward is 0, Sherlock handles rewards on its own\n      BOND, // Cost of making a request to the UMA OO (as decided by Sherlock)\n      LIVENESS, // Proposal liveness\n      address(sherlockCore), // Sherlock core address\n      0 // price\n    );\n\n    // If the state is not equal to ReadyToProposeUmaDispute, revert\n    // Then set the new state to UmaDisputeProposed\n    // Note State gets set to ReadyToProposeUmaDispute in the callback function from requestAndProposePriceFor()\n    if (_setState(claimIdentifier, State.UmaDisputeProposed) != State.ReadyToProposeUmaDispute) {\n      revert InvalidState();\n    }\n\n    // The protocol agent is now disputing Sherlock's proposed claim amount of $0\n    UMA.disputePriceFor(\n      UMA_IDENTIFIER, // Sherlock ID so UMA knows the request came from Sherlock\n      claim.timestamp, // Timestamp to identify the request\n      claim.ancillaryData, // Ancillary data such as the coverage agreement\n      umaRequest, // Refers to the original request made by Sherlock in requestAndProposePriceFor()\n      msg.sender, // Protocol agent, known as the disputer (the one who is disputing Sherlock's $0 proposed claim amount)\n      address(this) // This contract's address is the requester (Sherlock made the original request and proposed $0 claim amount)\n    );\n\n    // State gets updated to UmaPending in the disputePriceFor() callback (priceDisputed())\n    if (claim.state != State.UmaPending) revert InvalidState();\n\n    // Deletes the original request made by Sherlock\n    delete umaRequest;\n    // Approves the OO to spend $0\n    // This is just out of caution, don't want UMA to be approved for any amount of tokens they shouldn't be\n    TOKEN.safeApprove(address(UMA), 0);\n    // Checks for remaining balance in the contract\n    uint256 remaining = TOKEN.balanceOf(address(this));\n    // Sends remaining balance to the protocol agent\n    // A protocol agent should be able to send the exact amount to avoid the extra gas from this function\n    if (remaining != 0) TOKEN.safeTransfer(msg.sender, remaining);\n  }\n\n  // Checks to make sure a payout is valid, then calls the core Sherlock payout function\n  /// @notice Execute claim, storage will be removed after\n  /// @param _claimID Public ID of the claim\n  /// @dev Needs to be SpccApproved or UmaApproved && >UMAHO_TIME\n  /// @dev Funds will be pulled from core\n  // We are ok with spending the extra time to wait for the UMAHO time to expire before paying out\n  // We could have UMAHO multisig send a tx to confirm the payout (payout would happen sooner),\n  // But doesn't seem worth it to save half a day or so\n  function payoutClaim(uint256 _claimID) external override nonReentrant whenNotPaused {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    Claim storage claim = claims_[claimIdentifier];\n    // Only the claim initiator can call this, and payout gets sent to receiver address\n    if (msg.sender != claim.initiator) revert InvalidSender();\n\n    bytes32 protocol = claim.protocol;\n    // Address to receive the payout\n    // Note We could make the receiver a param in this function, but we want it to be known asap\n    // Can find and correct problems if the receiver is specified when the claim is initiated\n    address receiver = claim.receiver;\n    // Amount (in USDC) to be paid out\n    uint256 amount = claim.amount;\n    // Time when claim was last updated\n    uint256 updated = claim.updated;\n\n    // Sets new state to NonExistent as the claim is over once it is paid out\n    State _oldState = _setState(claimIdentifier, State.NonExistent);\n    // Checks to make sure this claim can be paid out\n    if (_isPayoutState(_oldState, updated) == false) revert InvalidState();\n\n    // Calls the PreCorePayoutCallback function on any contracts in claimCallbacks\n    for (uint256 i; i < claimCallbacks.length; i++) {\n      claimCallbacks[i].PreCorePayoutCallback(protocol, _claimID, amount);\n    }\n\n    emit ClaimPayout(_claimID, receiver, amount);\n\n    // We could potentially transfer more than `amount` in case balance > amount\n    // We are leaving this as is for simplicity's sake\n    // We don't expect to have tokens in this contract unless a reinsurer is providing them for a payout\n    // In which case they should provide the exact amount, and balance == amount is true\n    uint256 balance = TOKEN.balanceOf(address(this));\n    if (balance != 0) TOKEN.safeTransfer(receiver, balance);\n    if (balance < amount) sherlockCore.payoutClaim(receiver, amount - balance);\n  }\n\n  /// @notice UMAHO is able to execute a halt if the state is UmaApproved and state was updated less than UMAHO_TIME ago\n  // Once the UMAHO_TIME is up, UMAHO can still halt the claim, but only if the claim hasn't been paid out yet\n  function executeHalt(uint256 _claimID) external override whenNotPaused onlyUMAHO nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    // Sets state of claim to nonexistent, reverts if the old state was anything but UmaApproved\n    if (_setState(claimIdentifier, State.Halted) != State.UmaApproved) revert InvalidState();\n    if (_setState(claimIdentifier, State.NonExistent) != State.Halted) revert InvalidState();\n\n    emit ClaimHalted(_claimID);\n  }\n\n  //\n  // UMA callbacks\n  //\n\n  // Once requestAndProposePriceFor() is executed in UMA's contracts, this function gets called\n  // We change the claim's state from UmaPriceProposed to ReadyToProposeUmaDispute\n  // Then we call the next function in the process, disputePriceFor()\n  // @note reentrancy is allowed for this call\n  function priceProposed(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override whenNotPaused onlyUMA(identifier) {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n    if (claim.updated != block.timestamp) revert InvalidConditions();\n\n    // Sets state to ReadyToProposeUmaDispute\n    if (_setState(claimIdentifier, State.ReadyToProposeUmaDispute) != State.UmaPriceProposed) {\n      revert InvalidState();\n    }\n    // Sets global umaRequest variable to the request coming from this price proposal\n    umaRequest = request;\n  }\n\n  // Once disputePriceFor() is executed in UMA's contracts, this function gets called\n  // We change the claim's state from UmaDisputeProposed to UmaPending\n  // Then we call the next function in the process, priceSettled()\n  // @note reentrancy is allowed for this call\n  function priceDisputed(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override whenNotPaused onlyUMA(identifier) {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n    if (claim.updated != block.timestamp) revert InvalidConditions();\n\n    // Sets state to UmaPending\n    if (_setState(claimIdentifier, State.UmaPending) != State.UmaDisputeProposed) {\n      revert InvalidState();\n    }\n  }\n\n  // Once priceSettled() is executed in UMA's contracts, this function gets called\n  // UMA OO gives back a resolved price (either 0 or claim.amount) and\n  // Claim's state is changed to either UmaApproved or UmaDenied\n  // If UmaDenied, the claim is dead and state is immediately changed to NonExistent and cleaned up\n  /// @dev still want to capture settled price in a paused state. Otherwise claim is stuck.\n  function priceSettled(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override onlyUMA(identifier) nonReentrant {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n\n    // Retrives the resolved price for this claim (either 0 if Sherlock wins, or the amount of the claim as proposed by the protocol agent)\n    uint256 resolvedPrice = uint256(request.resolvedPrice);\n    // UMA approved the claim if the resolved price is equal to the claim amount set by the protocol agent\n    bool umaApproved = resolvedPrice == claim.amount;\n\n    // If UMA approves the claim, set state to UmaApproved\n    // If UMA denies, set state to UmaDenied, then to NonExistent (deletes the claim data)\n    if (umaApproved) {\n      if (_setState(claimIdentifier, State.UmaApproved) != State.UmaPending) revert InvalidState();\n    } else {\n      if (_setState(claimIdentifier, State.UmaDenied) != State.UmaPending) revert InvalidState();\n      if (_setState(claimIdentifier, State.NonExistent) != State.UmaDenied) revert InvalidState();\n    }\n  }\n}\ncontract SherClaim is ISherClaim {\n  using SafeERC20 for IERC20;\n\n  // The state switch needs to be executed between BOTTOM and CEILING after deployment\n  uint256 internal constant CLAIM_PERIOD_SANITY_BOTTOM = 7 days;\n  uint256 internal constant CLAIM_PERIOD_SANITY_CEILING = 14 days;\n\n  // Timestamp when SHER can be claimed\n  uint256 public immutable override claimableAt;\n  // SHER token address (18 decimals)\n  IERC20 public immutable sher;\n\n  // Mapping how much each user is able to claim\n  mapping(address => uint256) public userClaims;\n\n  /// @notice Construct claim contract\n  /// @param _sher ERC20 contract for SHER token\n  /// @param _claimableAt Timestamp when SHER tokens will be claimable\n  /// @dev _claimableAt is between BOTTOM and CEILING after deployment\n  constructor(IERC20 _sher, uint256 _claimableAt) {\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    // Verify if _claimableAt has a valid value\n    if (_claimableAt < block.timestamp + CLAIM_PERIOD_SANITY_BOTTOM) revert InvalidState();\n    if (_claimableAt > block.timestamp + CLAIM_PERIOD_SANITY_CEILING) revert InvalidState();\n\n    sher = _sher;\n    claimableAt = _claimableAt;\n  }\n\n  /// @notice Check if SHER tokens can be claimed\n  /// @return True if the claim period is active\n  function active() public view returns (bool) {\n    return block.timestamp >= claimableAt;\n  }\n\n  /// @notice Add `_amount` SHER to the timelock for `_user`\n  /// @param _user The account that is able to claim the SHER\n  /// @param _amount The amount of SHER that is added to the timelock\n  function add(address _user, uint256 _amount) external override {\n    if (_user == address(0)) revert ZeroArgument();\n    if (_amount == 0) revert ZeroArgument();\n    // Only allow new SHER to be added pre claim period\n    if (active()) revert InvalidState();\n\n    // Transfer SHER from caller to this contract\n    sher.safeTransferFrom(msg.sender, address(this), _amount);\n    // Account how much SHER the `_user` is able to claim\n    userClaims[_user] += _amount;\n\n    // Emit event about the new SHER tokens\n    emit Add(msg.sender, _user, _amount);\n  }\n\n  /// @notice Allow caller to claim SHER tokens\n  /// @dev Every account is able to call this once\n  /// @dev Will revert in case the amount is 0\n  /// @dev SHER tokens will be sent to caller\n  function claim() external {\n    // Only allow claim calls if claim period is active\n    if (active() == false) revert InvalidState();\n\n    // How much SHER the user will receive\n    uint256 amount = userClaims[msg.sender];\n    // Dont proceed if it's 0 SHER\n    if (amount == 0) revert InvalidAmount();\n    // If it is not 0, make sure it's 0 next time the user calls this function\n    delete userClaims[msg.sender];\n\n    // Transfer SHER to user\n    sher.safeTransfer(msg.sender, amount);\n\n    // Emit event about the SHER claim\n    emit Claim(msg.sender, amount);\n  }\n}\n",
    "bin": []
}