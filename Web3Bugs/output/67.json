{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/67/sandclock",
    "external_functions": [
        [
            "SandclockFactory"
        ],
        [
            "Vault",
            "IStrategy",
            "IERC20",
            "Claimers",
            "IERC721Receiver",
            "Depositors",
            "IIntegration"
        ],
        [],
        [],
        [
            "NonUSTStrategy",
            "IVault",
            "IEthAnchorRouter",
            "IExchangeRateFeeder",
            "IERC20",
            "ICurve"
        ],
        [
            "USTStrategy",
            "IVault",
            "IEthAnchorRouter",
            "IExchangeRateFeeder",
            "IERC20"
        ]
    ],
    "new_contract": "contract Depositors is ERC721 {\n    using Counters for Counters.Counter;\n\n    Counters.Counter private _tokenIds;\n    address public vault;\n\n    struct Deposit {\n        /// amount of the deposit\n        uint256 amount;\n        /// wallet of the claimer\n        uint256 claimerId;\n        /// when can the deposit be withdrawn\n        uint256 lockedUntil;\n    }\n\n    mapping(uint256 => Deposit) public deposits;\n\n    /// ID of the next NFT to mint\n    uint256 nextId;\n\n    modifier onlyVault() {\n        require(msg.sender == vault, \"Claimers: not authorized\");\n        _;\n    }\n\n    constructor(\n        address _vault,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        vault = _vault;\n    }\n\n    // should only be callable by the vault\n    // TODO: emit the groupId\n    function mint(\n        address _owner,\n        uint256 _amount,\n        uint256 _claimerId,\n        uint256 _lockedUntil\n    ) external onlyVault returns (uint256) {\n        uint256 localTokenId = _tokenIds.current();\n        _tokenIds.increment();\n\n        _safeMint(_owner, localTokenId);\n\n        deposits[localTokenId] = Deposit(_amount, _claimerId, _lockedUntil);\n\n        return localTokenId;\n    }\n\n    // called when a deposit's principal is withdrawn\n    function burn(uint256 _id) external onlyVault {\n        _burn(_id);\n    }\n\n    function exists(uint256 _tokenId) external view returns (bool) {\n        return _exists(_tokenId);\n    }\n}\ncontract USTStrategy is BaseStrategy {\n    constructor(\n        address _vault,\n        address _treasury,\n        address _ethAnchorRouter,\n        address _exchangeRateFeeder,\n        IERC20 _ustToken,\n        IERC20 _aUstToken,\n        uint16 _perfFeePct,\n        address _owner\n    )\n        BaseStrategy(\n            _vault,\n            _treasury,\n            _ethAnchorRouter,\n            _exchangeRateFeeder,\n            _ustToken,\n            _aUstToken,\n            _perfFeePct,\n            _owner\n        )\n    {\n        require(underlying == _ustToken, \"invalid underlying\");\n    }\n}\ncontract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {\n    using Counters for Counters.Counter;\n    using SafeERC20 for IERC20;\n    using PercentMath for uint256;\n    using Address for address;\n    using ERC165Query for address;\n\n    //\n    // Constants\n    //\n\n    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds\n    uint256 public constant SHARES_MULTIPLIER = 10**18;\n\n    //\n    // State\n    //\n\n    /// Underlying ERC20 token accepted by the vault\n    /// See {IVault}\n    IERC20 public override(IVault) underlying;\n\n    /// See {IVault}\n    IStrategy public strategy;\n\n    /// See {IVault}\n    uint256 public investPerc;\n\n    /// See {IVault}\n    uint256 public immutable override(IVault) minLockPeriod;\n\n    /// See {IVaultSponsoring}\n    uint256 public override(IVaultSponsoring) totalSponsored;\n\n    /// Depositors, represented as an NFT per deposit\n    Depositors public depositors;\n\n    /// Yield allocation\n    Claimers public claimers;\n\n    /// Unique IDs to correlate donations that belong to the same foundation\n    Counters.Counter private _depositGroupIds;\n\n    /**\n     * @param _underlying Underlying ERC20 token to use.\n     */\n    constructor(\n        IERC20 _underlying,\n        uint256 _minLockPeriod,\n        uint256 _investPerc,\n        address _owner\n    ) Trust(_owner) {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n        require(\n            address(_underlying) != address(0x0),\n            \"VaultContext: underlying cannot be 0x0\"\n        );\n        investPerc = _investPerc;\n        underlying = _underlying;\n        minLockPeriod = _minLockPeriod;\n\n        depositors = new Depositors(address(this), \"depositors\", \"p\");\n        claimers = new Claimers(address(this));\n    }\n\n    //\n    // IVault\n    //\n\n    /// See {IVault}\n    function setStrategy(address _strategy)\n        external\n        override(IVault)\n        requiresTrust\n    {\n        require(_strategy != address(0), \"Vault: strategy 0x\");\n        require(\n            IStrategy(_strategy).vault() == address(this),\n            \"Vault: invalid vault\"\n        );\n        require(\n            address(strategy) == address(0) || strategy.investedAssets() == 0,\n            \"Vault: strategy has invested funds\"\n        );\n\n        strategy = IStrategy(_strategy);\n    }\n\n    /// See {IVault}\n    function totalUnderlying() public view override(IVault) returns (uint256) {\n        if (address(strategy) != address(0)) {\n            return\n                underlying.balanceOf(address(this)) + strategy.investedAssets();\n        } else {\n            return underlying.balanceOf(address(this));\n        }\n    }\n\n    /// See {IVault}\n    function totalShares() public view override(IVault) returns (uint256) {\n        return claimers.totalShares();\n    }\n\n    /// See {IVault}\n    function yieldFor(address _to)\n        public\n        view\n        override(IVault)\n        returns (uint256)\n    {\n        uint256 tokenId = claimers.addressToTokenID(_to);\n        uint256 claimerPrincipal = claimers.principalOf(tokenId);\n        uint256 claimerShares = claimers.sharesOf(tokenId);\n        uint256 currentClaimerPrincipal = _computeAmount(\n            claimerShares,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n\n        if (currentClaimerPrincipal <= claimerPrincipal) {\n            return 0;\n        }\n\n        return currentClaimerPrincipal - claimerPrincipal;\n    }\n\n    /// See {IVault}\n    function deposit(DepositParams calldata _params) external {\n        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);\n        _transferAndCheckUnderlying(_msgSender(), _params.amount);\n    }\n\n    /// See {IVault}\n    function claimYield(address _to) external override(IVault) {\n        uint256 yield = yieldFor(_msgSender());\n\n        if (yield == 0) return;\n\n        uint256 shares = _computeShares(\n            yield,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n        uint256 sharesAmount = _computeAmount(\n            shares,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n\n        claimers.claimYield(_msgSender(), _to, sharesAmount, shares);\n\n        underlying.safeTransfer(_to, sharesAmount);\n    }\n\n    /// See {IVault}\n    function withdraw(address _to, uint256[] memory _ids)\n        external\n        override(IVault)\n    {\n        _withdraw(_to, _ids, false);\n    }\n\n    /// See {IVault}\n    function forceWithdraw(address _to, uint256[] memory _ids) external {\n        _withdraw(_to, _ids, true);\n    }\n\n    /// See {IVault}\n    function setInvestPerc(uint16 _investPerc) external requiresTrust {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n\n        emit InvestPercentageUpdated(_investPerc);\n\n        investPerc = _investPerc;\n    }\n\n    /// See {IVault}\n    function investableAmount() public view returns (uint256) {\n        uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);\n\n        uint256 alreadyInvested = strategy.investedAssets();\n\n        if (alreadyInvested >= maxInvestableAssets) {\n            return 0;\n        } else {\n            return maxInvestableAssets - alreadyInvested;\n        }\n    }\n\n    /// See {IVault}\n    function updateInvested() external requiresTrust {\n        require(address(strategy) != address(0), \"Vault: strategy is not set\");\n\n        uint256 _investable = investableAmount();\n\n        if (_investable > 0) {\n            underlying.safeTransfer(address(strategy), _investable);\n\n            emit Invested(_investable);\n        }\n\n        strategy.doHardWork();\n    }\n\n    //\n    // IVaultSponsoring\n\n    /// See {IVaultSponsoring}\n    function sponsor(uint256 _amount, uint256 _lockedUntil)\n        external\n        override(IVaultSponsoring)\n    {\n        if (_lockedUntil == 0)\n            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;\n        else\n            require(\n                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            _amount,\n            0,\n            _lockedUntil\n        );\n\n        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);\n\n        totalSponsored += _amount;\n        _transferAndCheckUnderlying(_msgSender(), _amount);\n    }\n\n    /// See {IVaultSponsoring}\n    function unsponsor(address _to, uint256[] memory _ids) external {\n        _unsponsor(_to, _ids, false);\n    }\n\n    /// See {IVaultSponsoring}\n    function forceUnsponsor(address _to, uint256[] memory _ids) external {\n        _unsponsor(_to, _ids, true);\n    }\n\n    //\n    // Public API\n    //\n\n    /**\n     * Computes the total amount of principal + yield currently controlled by the\n     * vault and the strategy. The principal + yield is the total amount\n     * of underlying that can be claimed or withdrawn, excluding the sponsored amount.\n     *\n     * @return Total amount of principal and yield help by the vault (not including sponsored amount).\n     */\n    function totalUnderlyingMinusSponsored() public view returns (uint256) {\n        // TODO no invested amount yet\n        return totalUnderlying() - totalSponsored;\n    }\n\n    //\n    // ERC165\n    //\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IVault).interfaceId ||\n            interfaceId == type(IVaultSponsoring).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    //\n    // Internal API\n    //\n\n    /**\n     * Withdraws the principal from the deposits with the ids provided in @param _ids and sends it to @param _to.\n     *\n     * @notice the NFTs of the deposits will be burned.\n     *\n     * @param _to Address that will receive the funds.\n     * @param _ids Array with the ids of the deposits.\n     * @param _force Boolean to specify if the action should be perfomed when there's loss.\n     */\n    function _withdraw(\n        address _to,\n        uint256[] memory _ids,\n        bool _force\n    ) internal {\n        uint256 localTotalShares = totalShares();\n        uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();\n        uint256 amount;\n\n        for (uint8 i = 0; i < _ids.length; i++) {\n            amount += _withdrawDeposit(\n                _ids[i],\n                localTotalShares,\n                localTotalPrincipal,\n                _to,\n                _force\n            );\n        }\n\n        underlying.safeTransfer(_to, amount);\n    }\n\n    /**\n     * Withdraws the sponsored amount for the deposits with the ids provided\n     * in @param _ids and sends it to @param _to.\n     *\n     * @notice the NFTs of the deposits will be burned.\n     *\n     * @param _to Address that will receive the funds.\n     * @param _ids Array with the ids of the deposits.\n     * @param _force Boolean to specify if the action should be perfomed when there's loss.\n     */\n    function _unsponsor(\n        address _to,\n        uint256[] memory _ids,\n        bool _force\n    ) internal {\n        uint256 sponsorAmount;\n\n        for (uint8 i = 0; i < _ids.length; i++) {\n            uint256 tokenId = _ids[i];\n\n            require(\n                depositors.ownerOf(tokenId) == _msgSender(),\n                \"Vault: you are not the owner of a sponsor\"\n            );\n\n            (\n                uint256 depositAmount,\n                uint256 claimerId,\n                uint256 lockedUntil\n            ) = depositors.deposits(tokenId);\n            require(lockedUntil <= block.timestamp, \"Vault: amount is locked\");\n\n            require(claimerId == 0, \"Vault: token id is not a sponsor\");\n\n            depositors.burn(tokenId);\n\n            emit Unsponsored(tokenId);\n\n            sponsorAmount += depositAmount;\n        }\n\n        uint256 sponsorToTransfer = sponsorAmount;\n\n        if (_force && sponsorAmount > totalUnderlying()) {\n            sponsorToTransfer = totalUnderlying();\n        } else if (!_force) {\n            require(\n                sponsorToTransfer <= totalUnderlying(),\n                \"Vault: not enough funds to unsponsor\"\n            );\n        }\n\n        totalSponsored -= sponsorAmount;\n\n        underlying.safeTransfer(_to, sponsorToTransfer);\n    }\n\n    /**\n     * Creates a deposit with the given amount of underlying and claim\n     * structure. The deposit is locked until the timestamp specified in @param _lockedUntil.\n     * @notice This function assumes underlying will be transfered elsewhere in\n     * the transaction.\n     *\n     * @notice Underlying must be transfered *after* this function, in order to\n     * correctly calculate shares.\n     *\n     * @notice claims must add up to 100%.\n     *\n     * @param _amount Amount of underlying to consider @param claims claim\n     * @param _lockedUntil When the depositor can unsponsor the amount.\n     * @param claims Claim params\n     * params.\n     */\n    function _createDeposit(\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams[] calldata claims\n    ) internal {\n        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;\n        else\n            require(\n                _lockedUntil >= block.timestamp + minLockPeriod,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 localTotalShares = totalShares();\n        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();\n        uint256 pct = 0;\n\n        for (uint256 i = 0; i < claims.length; ++i) {\n            ClaimParams memory data = claims[i];\n            _createClaim(\n                _depositGroupIds.current(),\n                _amount,\n                _lockedUntil,\n                data,\n                localTotalShares,\n                localTotalUnderlying\n            );\n            pct += data.pct;\n        }\n\n        _depositGroupIds.increment();\n\n        require(pct.is100Perc(), \"Vault: claims don't add up to 100%\");\n    }\n\n    function _createClaim(\n        uint256 _depositGroupId,\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams memory _claim,\n        uint256 _localTotalShares,\n        uint256 _localTotalPrincipal\n    ) internal {\n        uint256 amount = _amount.percOf(_claim.pct);\n\n        uint256 newShares = _computeShares(\n            amount,\n            _localTotalShares,\n            _localTotalPrincipal\n        );\n\n        uint256 claimerId = claimers.mint(\n            _claim.beneficiary,\n            amount,\n            newShares\n        );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            amount,\n            claimerId,\n            _lockedUntil\n        );\n\n        if (_isIntegration(_claim.beneficiary)) {\n            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(\n                tokenId,\n                newShares,\n                _claim.data\n            );\n\n            require(\n                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector\n            );\n        }\n\n        emit DepositMinted(\n            tokenId,\n            _depositGroupId,\n            amount,\n            newShares,\n            _msgSender(),\n            _claim.beneficiary,\n            claimerId,\n            _lockedUntil\n        );\n    }\n\n    /**\n     * Burns a deposit NFT and reduces the principal and shares of the claimer.\n     * If there were any yield to be claimed, the claimer will also keep shares to withdraw later on.\n     *\n     * @notice This function doesn't transfer any funds, it only updates the state.\n     *\n     * @notice Only the owner of the deposit may call this function.\n     *\n     * @param _tokenId The deposit ID to withdraw from.\n     * @param _totalShares The total shares to consider for the withdraw.\n     * @param _totalUnderlyingMinusSponsored The total underlying to consider for the withdraw.\n     *\n     * @return the amount to withdraw.\n     */\n    function _withdrawDeposit(\n        uint256 _tokenId,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored,\n        address _to,\n        bool _force\n    ) internal returns (uint256) {\n        require(\n            depositors.ownerOf(_tokenId) == _msgSender(),\n            \"Vault: you are not the owner of a deposit\"\n        );\n\n        (\n            uint256 depositAmount,\n            uint256 claimerId,\n            uint256 lockedUntil\n        ) = depositors.deposits(_tokenId);\n        require(lockedUntil <= block.timestamp, \"Vault: deposit is locked\");\n\n        require(claimerId != 0, \"Vault: token id is not a withdraw\");\n\n        uint256 claimerShares = claimers.sharesOf(claimerId);\n\n        uint256 depositShares = _computeShares(\n            depositAmount,\n            _totalShares,\n            _totalUnderlyingMinusSponsored\n        );\n\n        if (_force && depositShares > claimerShares) {\n            depositShares = claimerShares;\n        } else if (!_force) {\n            require(\n                claimerShares >= depositShares,\n                \"Vault: cannot withdraw more than the available amount\"\n            );\n        }\n\n        claimers.onWithdraw(claimerId, depositAmount, depositShares);\n        depositors.burn(_tokenId);\n\n        address claimer = claimers.ownerOf(claimerId);\n\n        if (_isIntegration(claimer)) {\n            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);\n\n            require(ret == IIntegration(claimer).onDepositBurned.selector);\n        }\n\n        emit DepositBurned(_tokenId, depositShares, _to);\n\n        return\n            _computeAmount(\n                depositShares,\n                _totalShares,\n                _totalUnderlyingMinusSponsored\n            );\n    }\n\n    function _transferAndCheckUnderlying(address _from, uint256 _amount)\n        internal\n    {\n        uint256 balanceBefore = totalUnderlying();\n        underlying.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = totalUnderlying();\n\n        require(\n            balanceAfter == balanceBefore + _amount,\n            \"Vault: amount received does not match params\"\n        );\n    }\n\n    function _blockTimestamp() public view returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    /**\n     * Computes amount of shares that will be received for a given deposit amount\n     *\n     * @param _amount Amount of deposit to consider.\n     * @param _totalShares Amount of existing shares to consider.\n     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.\n     * @return Amount of shares the deposit will receive.\n     */\n    function _computeShares(\n        uint256 _amount,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_amount == 0) return 0;\n        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;\n\n        require(\n            _totalUnderlyingMinusSponsored > 0,\n            \"Vault: cannot compute shares when there's no principal\"\n        );\n\n        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;\n    }\n\n    /**\n     * Computes the amount of underlying from a given number of shares\n     *\n     * @param _shares Number of shares.\n     * @param _totalShares Amount of existing shares to consider.\n     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.\n     * @return Amount that corresponds to the number of shares.\n     */\n    function _computeAmount(\n        uint256 _shares,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {\n            return 0;\n        } else {\n            // TODO exclude sponsored assets\n            return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);\n        }\n    }\n\n    /**\n     * Checks if the given address is a contract implementing IIntegration\n     *\n     * @param addr Address to check\n     * @return true if contract is an IIntegraiont\n     */\n    function _isIntegration(address addr) internal view returns (bool) {\n        return\n            addr.doesContractImplementInterface(type(IIntegration).interfaceId);\n    }\n}\ncontract Claimers is ERC721, IClaimers {\n    using Counters for Counters.Counter;\n\n    Counters.Counter private _tokenIds;\n    address public vault = address(0);\n    // The total of shares\n    uint256 public totalShares;\n\n    struct Claimer {\n        uint256 totalPrincipal;\n        uint256 totalShares;\n        uint256 totalClaimed;\n    }\n\n    mapping(uint256 => Claimer) public claimers;\n    mapping(address => uint256) public addressToTokenID;\n\n    modifier onlyVault() {\n        require(msg.sender == vault, \"Claimers: not authorized\");\n        _;\n    }\n\n    // TODO Make names dynamic\n    constructor(address _vault) ERC721(\"Claimers\", \"SNDCLM\") {\n        vault = _vault;\n    }\n\n    function claimYield(\n        address _owner,\n        address _to,\n        uint256 _amount,\n        uint256 _shares\n    ) external onlyVault {\n        uint256 localTokenId = addressToTokenID[_owner];\n\n        claimers[localTokenId].totalShares -= _shares;\n        claimers[localTokenId].totalClaimed += _amount;\n        totalShares -= _shares;\n\n        emit YieldClaimed(localTokenId, _to, _amount, _shares);\n    }\n\n    function mint(\n        address _to,\n        uint256 _principal,\n        uint256 _shares\n    ) external onlyVault returns (uint256) {\n        uint256 localTokenId = addressToTokenID[_to];\n\n        if (localTokenId == 0) {\n            _tokenIds.increment();\n            localTokenId = _tokenIds.current();\n\n            _mint(_to, localTokenId);\n        }\n\n        claimers[localTokenId].totalShares += _shares;\n        claimers[localTokenId].totalPrincipal += _principal;\n\n        totalShares += _shares;\n\n        return localTokenId;\n    }\n\n    function onWithdraw(\n        uint256 _tokenId,\n        uint256 _principal,\n        uint256 _shares\n    ) external onlyVault {\n        claimers[_tokenId].totalShares -= _shares;\n        claimers[_tokenId].totalPrincipal -= _principal;\n        totalShares -= _shares;\n    }\n\n    function principalOf(uint256 _tokenId) external view returns (uint256) {\n        return claimers[_tokenId].totalPrincipal;\n    }\n\n    function sharesOf(uint256 _tokenId) external view returns (uint256) {\n        return claimers[_tokenId].totalShares;\n    }\n\n    /**\n     * Ensures the addressToTokenID mapping is up to date.\n     *\n     * @notice This function prevents transfers to addresses that already own an NFT.\n     *\n     * @param _from origin address.\n     * @param _to destination address.\n     * @param _tokenId id of the token.\n     */\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual override {\n        require(_to != address(0), \"Claimers: cannot burn this NFT\");\n\n        if (_from == address(0)) {\n            // MINT\n            addressToTokenID[_to] = _tokenId;\n        } else {\n            // TRANSFER\n            require(\n                addressToTokenID[_to] == 0,\n                \"Claimers: destination already has an NFT\"\n            );\n\n            addressToTokenID[_from] = 0;\n            addressToTokenID[_to] = _tokenId;\n        }\n    }\n}\ncontract SandclockFactory is Context, Trust {\n    //\n    // Events\n    //\n\n    event NewVault(address indexed vault, uint256 salt);\n    event NewDCA(address indexed dca, uint256 salt);\n\n    //\n    // Constructor\n    //\n\n    constructor() Trust(_msgSender()) {}\n\n    //\n    // Public API\n    //\n\n    function deployVault(bytes memory code, uint256 salt)\n        external\n        requiresTrust\n    {\n        address addr = deploy(code, salt);\n\n        emit NewVault(addr, salt);\n    }\n\n    function deployDCA(bytes memory code, uint256 salt) external requiresTrust {\n        address addr = deploy(code, salt);\n\n        emit NewDCA(addr, salt);\n    }\n\n    //\n    // Internal\n    //\n\n    function deploy(bytes memory code, uint256 salt)\n        internal\n        returns (address)\n    {\n        address addr;\n        assembly {\n            addr := create2(0, add(code, 0x20), mload(code), salt)\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n\n        return addr;\n    }\n}\nabstract contract BaseStrategy is IStrategy, Trust {\n    using SafeERC20 for IERC20;\n    using PercentMath for uint256;\n\n    event PerfFeeClaimed(uint256 amount);\n    event PerfFeePctUpdated(uint256 pct);\n\n    struct Operation {\n        address operator;\n        uint256 amount;\n    }\n\n    IERC20 public override(IStrategy) underlying;\n    // Vault address\n    address public override(IStrategy) vault;\n\n    // address of the treasury\n    address public treasury;\n\n    // address for the UST token\n    IERC20 public ustToken;\n\n    // address for the aUST token (wrapped Anchor UST, received to accrue interest for an Anchor deposit)\n    IERC20 public aUstToken;\n\n    // performance fee taken by the treasury on profits\n    uint16 public perfFeePct;\n\n    // external contract to interact with EthAnchor\n    IEthAnchorRouter public ethAnchorRouter;\n\n    // external exchange rate provider\n    IExchangeRateFeeder public exchangeRateFeeder;\n\n    // amount currently pending in deposits to EthAnchor\n    uint256 public pendingDeposits;\n\n    // amount currently pending redeemption from EthAnchor\n    uint256 public pendingRedeems;\n\n    // deposit operations history\n    Operation[] public depositOperations;\n\n    // redeem operations history\n    Operation[] public redeemOperations;\n\n    // amount of UST converted (used to calculate yield)\n    uint256 public convertedUst;\n\n    // restructs a function to be called only by the vault or governance\n    modifier restricted() {\n        require(msg.sender == vault || isTrusted[msg.sender], \"restricted\");\n\n        _;\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == vault, \"only vault\");\n\n        _;\n    }\n\n    constructor(\n        address _vault,\n        address _treasury,\n        address _ethAnchorRouter,\n        address _exchangeRateFeeder,\n        IERC20 _ustToken,\n        IERC20 _aUstToken,\n        uint16 _perfFeePct,\n        address _owner\n    ) Trust(_owner) {\n        require(_ethAnchorRouter != address(0), \"0x addr\");\n        require(_exchangeRateFeeder != address(0), \"0x addr\");\n        require(address(_ustToken) != address(0), \"0x addr\");\n        require(address(_aUstToken) != address(0), \"0x addr\");\n        require(PercentMath.validPerc(_perfFeePct), \"invalid pct\");\n\n        treasury = _treasury;\n        vault = _vault;\n        underlying = IVault(_vault).underlying();\n        ethAnchorRouter = IEthAnchorRouter(_ethAnchorRouter);\n        exchangeRateFeeder = IExchangeRateFeeder(_exchangeRateFeeder);\n        ustToken = _ustToken;\n        aUstToken = _aUstToken;\n        perfFeePct = _perfFeePct;\n\n        // pre-approve EthAnchor router to transact all UST and aUST\n        ustToken.safeApprove(_ethAnchorRouter, type(uint256).max);\n        aUstToken.safeApprove(_ethAnchorRouter, type(uint256).max);\n    }\n\n    /**\n     * Initiates a deposit of all the currently held UST into EthAnchor\n     *\n     * @notice since EthAnchor uses an asynchronous model, this function\n     * only starts the deposit process, but does not finish it.\n     */\n    function doHardWork() external virtual override(IStrategy) restricted {\n        _initDepositStable();\n    }\n\n    function _initDepositStable() internal {\n        uint256 ustBalance = _getUstBalance();\n        require(ustBalance > 0, \"balance 0\");\n        pendingDeposits += ustBalance;\n        address _operator = ethAnchorRouter.initDepositStable(ustBalance);\n        depositOperations.push(\n            Operation({operator: _operator, amount: ustBalance})\n        );\n    }\n\n    /**\n     * Calls EthAnchor with a pending deposit ID, and attempts to finish it.\n     *\n     * @notice Must be called some time after `doHardWork()`. Will only work if\n     * the EthAnchor bridge has finished processing the deposit.\n     *\n     * @param idx Id of the pending deposit operation\n     */\n    function finishDepositStable(uint256 idx) external {\n        require(depositOperations.length > idx, \"not running\");\n        Operation storage operation = depositOperations[idx];\n        ethAnchorRouter.finishDepositStable(operation.operator);\n\n        pendingDeposits -= operation.amount;\n        convertedUst += operation.amount;\n\n        operation.operator = depositOperations[depositOperations.length - 1]\n            .operator;\n        operation.amount = depositOperations[depositOperations.length - 1]\n            .amount;\n        depositOperations.pop();\n    }\n\n    /**\n     * Initiates a withdrawal of UST from EthAnchor\n     *\n     * @notice since EthAnchor uses an asynchronous model, this function\n     * only starts the redeem process, but does not finish it.\n     *\n     * @param amount Amount of aUST to redeem\n     */\n    function initRedeemStable(uint256 amount) public restricted {\n        uint256 aUstBalance = _getAUstBalance();\n        require(amount > 0, \"amount 0\");\n        require(aUstBalance >= amount, \"insufficient\");\n        pendingRedeems += amount;\n        address _operator = ethAnchorRouter.initRedeemStable(amount);\n        redeemOperations.push(Operation({operator: _operator, amount: amount}));\n    }\n\n    /**\n     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.\n     *\n     * @notice Must be called some time after `initRedeemStable()`. Will only work if\n     * the EthAnchor bridge has finished processing the deposit.\n     *\n     * @param idx Id of the pending redeem operation\n     */\n    function finishRedeemStable(uint256 idx) public virtual {\n        require(redeemOperations.length > idx, \"not running\");\n        Operation storage operation = redeemOperations[idx];\n        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n        uint256 originalUst = (convertedUst * operation.amount) / aUstBalance;\n        uint256 ustBalanceBefore = _getUstBalance();\n\n        ethAnchorRouter.finishRedeemStable(operation.operator);\n\n        uint256 redeemedAmount = _getUstBalance() - ustBalanceBefore;\n        uint256 perfFee = redeemedAmount > originalUst\n            ? (redeemedAmount - originalUst).percOf(perfFeePct)\n            : 0;\n        if (perfFee > 0) {\n            ustToken.safeTransfer(treasury, perfFee);\n            emit PerfFeeClaimed(perfFee);\n        }\n        convertedUst -= originalUst;\n        pendingRedeems -= operation.amount;\n\n        operation.operator = redeemOperations[redeemOperations.length - 1]\n            .operator;\n        operation.amount = redeemOperations[redeemOperations.length - 1].amount;\n        redeemOperations.pop();\n    }\n\n    /**\n     * Withdraws the entire amount back to the vault\n     *\n     * @notice since some of the amount may be deposited into EthAnchor, this\n     * call may not withdraw all the funds right away. It will start a redeem\n     * process on EthAnchor, but this function must be called again a second\n     * time once that is finished.\n     */\n    function withdrawAllToVault() external override(IStrategy) restricted {\n        uint256 aUstBalance = _getAUstBalance();\n        if (aUstBalance > 0) {\n            initRedeemStable(aUstBalance);\n        }\n        uint256 underlyingBalance = _getUnderlyingBalance();\n        if (underlyingBalance > 0) {\n            underlying.safeTransfer(vault, underlyingBalance);\n        }\n    }\n\n    /**\n     * Withdraws a specified amount back to the vault\n     *\n     * @notice Unlike `withdrawToVault`, this function only considers the\n     * amount currently not invested, but only what is currently held by the\n     * strategy\n     *\n     * @param amount Amount to withdraw\n     */\n    function withdrawToVault(uint256 amount)\n        external\n        override(IStrategy)\n        restricted\n    {\n        underlying.safeTransfer(vault, amount);\n    }\n\n    /**\n     * Updates the performance fee\n     *\n     * @notice Can only be called by governance\n     *\n     * @param _perfFeePct The new performance fee %\n     */\n    function setPerfFeePct(uint16 _perfFeePct) external restricted {\n        require(PercentMath.validPerc(_perfFeePct), \"invalid pct\");\n        perfFeePct = _perfFeePct;\n        emit PerfFeePctUpdated(_perfFeePct);\n    }\n\n    /**\n     * Amount, expressed in the underlying currency, currently in the strategy\n     *\n     * @notice both held and invested amounts are included here, using the\n     * latest known exchange rates to the underlying currency\n     *\n     * @return The total amount of underlying\n     */\n    function investedAssets()\n        external\n        view\n        virtual\n        override(IStrategy)\n        returns (uint256)\n    {\n        uint256 underlyingBalance = _getUnderlyingBalance() + pendingDeposits;\n        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n\n        return\n            underlyingBalance +\n            ((exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) *\n                aUstBalance) / 1e18);\n    }\n\n    // Amount of underlying tokens in the strategy\n    function _getUnderlyingBalance() internal view returns (uint256) {\n        return underlying.balanceOf(address(this));\n    }\n\n    // Amount of UST tokens in the strategy\n    function _getUstBalance() internal view returns (uint256) {\n        return ustToken.balanceOf(address(this));\n    }\n\n    // Amount of aUST tokens in the strategy\n    function _getAUstBalance() internal view returns (uint256) {\n        return aUstToken.balanceOf(address(this));\n    }\n\n    // Amount of pending deposit operations\n    function depositOperationLength() external view returns (uint256) {\n        return depositOperations.length;\n    }\n\n    // Amount of pending redeem operations\n    function redeemOperationLength() external view returns (uint256) {\n        return redeemOperations.length;\n    }\n}\ncontract NonUSTStrategy is BaseStrategy {\n    using SafeERC20 for IERC20;\n\n    // address of the Curve pool to use\n    ICurve public curvePool;\n\n    // index of the underlying token in the pool\n    int128 public underlyingI;\n\n    // index of the UST token in the pool\n    int128 public ustI;\n\n    constructor(\n        address _vault,\n        address _treasury,\n        address _ethAnchorRouter,\n        address _exchangeRateFeeder,\n        IERC20 _ustToken,\n        IERC20 _aUstToken,\n        uint16 _perfFeePct,\n        address _owner,\n        address _curvePool,\n        int128 _underlyingI,\n        int128 _ustI\n    )\n        BaseStrategy(\n            _vault,\n            _treasury,\n            _ethAnchorRouter,\n            _exchangeRateFeeder,\n            _ustToken,\n            _aUstToken,\n            _perfFeePct,\n            _owner\n        )\n    {\n        require(underlying != _ustToken, \"invalid underlying\");\n        require(_curvePool != address(0), \"0x addr\");\n        curvePool = ICurve(_curvePool);\n        underlyingI = _underlyingI;\n        ustI = _ustI;\n\n        ustToken.safeApprove(_curvePool, type(uint256).max);\n        underlying.safeApprove(_curvePool, type(uint256).max);\n    }\n\n    /**\n     * Swaps the underlying currency for UST, and initiates a deposit of all\n     * the converted UST into EthAnchor\n     *\n     * @notice since EthAnchor uses an asynchronous model, this function\n     * only starts the deposit process, but does not finish it.\n     */\n    function doHardWork() external override(BaseStrategy) restricted {\n        _swapUnderlyingToUst();\n        _initDepositStable();\n    }\n\n    /**\n     * Calls Curve to convert the existing underlying balance into UST\n     */\n    function _swapUnderlyingToUst() internal {\n        uint256 underlyingBalance = _getUnderlyingBalance();\n        if (underlyingBalance > 0) {\n            // slither-disable-next-line unused-return\n            curvePool.exchange_underlying(\n                underlyingI,\n                ustI,\n                underlyingBalance,\n                0\n            );\n        }\n    }\n\n    /**\n     * Calls Curve to convert the existing UST back into the underlying token\n     */\n    function _swapUstToUnderlying() internal {\n        uint256 ustBalance = _getUstBalance();\n        if (ustBalance > 0) {\n            // slither-disable-next-line unused-return\n            curvePool.exchange_underlying(ustI, underlyingI, ustBalance, 0);\n        }\n    }\n\n    /**\n     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.\n     * Once UST is retrieved, convert it back to underlying via Curve\n     *\n     * @notice Must be called some time after `initRedeemStable()`. Will only work if\n     * the EthAnchor bridge has finished processing the deposit.\n     *\n     * @param idx Id of the pending redeem operation\n     */\n    function finishRedeemStable(uint256 idx) public override(BaseStrategy) {\n        super.finishRedeemStable(idx);\n        _swapUstToUnderlying();\n    }\n\n    /**\n     * Amount, expressed in the underlying currency, currently in the strategy\n     *\n     * @notice both held and invested amounts are included here, using the\n     * latest known exchange rates to the underlying currency\n     *\n     * @return The total amount of underlying\n     */\n    function investedAssets()\n        external\n        view\n        override(BaseStrategy)\n        returns (uint256)\n    {\n        uint256 underlyingBalance = _getUnderlyingBalance();\n        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n\n        uint256 ustAssets = ((exchangeRateFeeder.exchangeRateOf(\n            address(aUstToken),\n            true\n        ) * aUstBalance) / 1e18) + pendingDeposits;\n        return\n            underlyingBalance +\n            curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);\n    }\n}\n",
    "bin": []
}