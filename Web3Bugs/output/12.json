{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/12",
    "external_functions": [
        [],
        [
            "Cauldron",
            "IFYToken",
            "IOracle"
        ],
        [
            "FYToken",
            "IJoin",
            "IERC20Metadata",
            "IOracle",
            "IERC3156FlashBorrower"
        ],
        [
            "Join",
            "IJoinFactory",
            "IERC20",
            "IERC3156FlashBorrower"
        ],
        [
            "JoinFactory",
            "Join",
            "IJoinFactory",
            "IERC20",
            "IERC3156FlashBorrower"
        ],
        [
            "Ladle",
            "ICauldron",
            "IJoin",
            "IPool",
            "IFYToken",
            "IERC20",
            "IERC2612",
            "DaiAbstract",
            "IWETH9"
        ],
        [
            "LadleStorage"
        ],
        [
            "IOwnable"
        ],
        [
            "Wand",
            "IJoinFactory",
            "ILadleGov",
            "ICauldronGov",
            "AccessControl",
            "IMultiOracleGov",
            "IPoolFactory",
            "FYToken",
            "IJoin",
            "IERC20Metadata",
            "IOracle",
            "IERC3156FlashBorrower",
            "IOwnable"
        ],
        [
            "Witch",
            "ICauldron",
            "ILadle"
        ],
        [],
        [],
        [],
        [
            "ChainlinkMultiOracle",
            "AggregatorV3Interface"
        ],
        [
            "CompoundMultiOracle",
            "CTokenInterface"
        ],
        [
            "UniswapV3Oracle",
            "IUniswapV3PoolImmutables"
        ],
        [],
        [],
        [
            "ERC20"
        ],
        [
            "ERC20Permit"
        ],
        [],
        [],
        [],
        [],
        [],
        [],
        [
            "Pool",
            "IPoolFactory",
            "IFYToken",
            "IERC20"
        ],
        [
            "PoolFactory",
            "Pool",
            "IPoolFactory",
            "IFYToken",
            "IERC20"
        ],
        [
            "PoolRouter",
            "IPoolFactory",
            "IERC2612",
            "DaiAbstract",
            "IWETH9"
        ],
        [],
        []
    ],
    "new_contract": "contract UniswapV3Oracle is IOracle, AccessControl {\n    using CastBytes32Bytes6 for bytes32;\n\n    event SecondsAgoSet(uint32 indexed secondsAgo);\n    event SourceSet(bytes6 indexed base, bytes6 indexed quote, address indexed source);\n\n    struct Source {\n        address source;\n        bool inverse;\n    }\n\n    struct SourceData {\n        address factory;\n        address baseToken;\n        address quoteToken;\n        uint24 fee;\n    }\n\n    uint32 public secondsAgo;\n    mapping(bytes6 => mapping(bytes6 => Source)) public sources;\n    mapping(address => SourceData) public sourcesData;\n\n    /**\n     * @notice Set or reset the number of seconds Uniswap will use for its Time Weighted Average Price computation\n     */\n    function setSecondsAgo(uint32 secondsAgo_) public auth {\n        require(secondsAgo_ != 0, \"Uniswap must look into the past.\");\n        secondsAgo = secondsAgo_;\n        emit SecondsAgoSet(secondsAgo_);\n    }\n\n    /**\n     * @notice Set or reset an oracle source and its inverse\n     */\n    function setSource(bytes6 base, bytes6 quote, address source) public auth {\n        sources[base][quote] = Source(source, false);\n        sources[quote][base] = Source(source, true);\n        sourcesData[source] = SourceData(\n            IUniswapV3PoolImmutables(source).factory(),\n            IUniswapV3PoolImmutables(source).token0(),\n            IUniswapV3PoolImmutables(source).token1(),\n            IUniswapV3PoolImmutables(source).fee()\n        );\n        emit SourceSet(base, quote, source);\n        emit SourceSet(quote, base, source);\n    }\n\n    /**\n     * @notice Set or reset a number of oracle sources\n     */\n    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) public auth {\n        require(bases.length == quotes.length && quotes.length == sources_.length, \"Mismatched inputs\");\n        for (uint256 i = 0; i < bases.length; i++) {\n            setSource(bases[i], quotes[i], sources_[i]);\n        }\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.\n     * @return value\n     */\n    function _peek(bytes6 base, bytes6 quote, uint256 amount) public virtual view returns (uint256 value, uint256 updateTime) {\n        Source memory source = sources[base][quote];\n        SourceData memory sourceData;\n        require(source.source != address(0), \"Source not found\");\n        sourceData = sourcesData[source.source];\n        if (source.inverse) {\n            value = UniswapV3OracleLibraryMock.consult(sourceData.factory, sourceData.quoteToken, sourceData.baseToken, sourceData.fee, amount, secondsAgo);\n        } else {\n            value = UniswapV3OracleLibraryMock.consult(sourceData.factory, sourceData.baseToken, sourceData.quoteToken, sourceData.fee, amount, secondsAgo);\n        }\n        updateTime = block.timestamp - secondsAgo;\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.\n     * @return value\n     */\n    function peek(bytes32 base, bytes32 quote, uint256 amount) public virtual override view returns (uint256 value, uint256 updateTime) {\n        return _peek(base.b6(), quote.b6(), amount);\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price. Same as `peek` for this oracle.\n     * @return value\n     */\n    function get(bytes32 base, bytes32 quote, uint256 amount) public virtual override view returns (uint256 value, uint256 updateTime) {\n        return _peek(base.b6(), quote.b6(), amount);\n    }\n}\ncontract PoolFactory is IPoolFactory {\n  /// Pre-hashing the bytecode allows calculatePoolAddress to be cheaper, and\n  /// makes client-side address calculation easier\n  bytes32 public constant override POOL_BYTECODE_HASH = keccak256(type(Pool).creationCode);\n\n  address private _nextBase;\n  address private _nextFYToken;\n\n  /// @dev Returns true if `account` is a contract.\n  function isContract(address account) internal view returns (bool) {\n      // This method relies on extcodesize, which returns 0 for contracts in\n      // construction, since the code is only stored at the end of the\n      // constructor execution.\n\n      uint256 size;\n      // solhint-disable-next-line no-inline-assembly\n      assembly { size := extcodesize(account) }\n      return size > 0;\n  }\n\n  /// @dev Calculate the deterministic addreess of a pool, based on the base token & fy token.\n  /// @param base Address of the base token (such as Base).\n  /// @param fyToken Address of the fixed yield token (such as fyToken).\n  /// @return The calculated pool address.\n  function calculatePoolAddress(address base, address fyToken) external view override returns (address) {\n    return _calculatePoolAddress(base, fyToken);\n  }\n\n  /// @dev Create2 calculation\n  function _calculatePoolAddress(address base, address fyToken)\n    private view returns (address calculatedAddress)\n  {\n    calculatedAddress = address(uint160(uint256(keccak256(abi.encodePacked(\n      bytes1(0xff),\n      address(this),\n      keccak256(abi.encodePacked(base, fyToken)),\n      POOL_BYTECODE_HASH\n    )))));\n  }\n\n  /// @dev Calculate the addreess of a pool, and return address(0) if not deployed.\n  /// @param base Address of the base token (such as Base).\n  /// @param fyToken Address of the fixed yield token (such as fyToken).\n  /// @return pool The deployed pool address.\n  function getPool(address base, address fyToken) external view override returns (address pool) {\n    pool = _calculatePoolAddress(base, fyToken);\n\n    if(!isContract(pool)) {\n      pool = address(0);\n    }\n  }\n\n  /// @dev Deploys a new pool.\n  /// base & fyToken are written to temporary storage slots to allow for simpler\n  /// address calculation, while still allowing the Pool contract to store the values as\n  /// immutable.\n  /// @param base Address of the base token (such as Base).\n  /// @param fyToken Address of the fixed yield token (such as fyToken).\n  /// @return pool The pool address.\n  function createPool(address base, address fyToken) external override returns (address) {\n    _nextBase = base;\n    _nextFYToken = fyToken;\n    Pool pool = new Pool{salt: keccak256(abi.encodePacked(base, fyToken))}();\n    _nextBase = address(0);\n    _nextFYToken = address(0);\n\n    pool.transferOwnership(msg.sender);\n    \n    emit PoolCreated(base, fyToken, address(pool));\n\n    return address(pool);\n  }\n\n  /// @dev Only used by the Pool constructor.\n  /// @return The base token for the currently-constructing pool.\n  function nextBase() external view override returns (address) {\n    return _nextBase;\n  }\n\n  /// @dev Only used by the Pool constructor.\n  /// @return The fytoken for the currently-constructing pool.\n  function nextFYToken() external view override returns (address) {\n    return _nextFYToken;\n  }\n}\ncontract Join is IJoin, IERC3156FlashLender, AccessControl() {\n    using TransferHelper for IERC20;\n    using WMul for uint256;\n    using CastU256U128 for uint256;\n\n    event FlashFeeFactorSet(uint256 indexed fee);\n\n    bytes32 constant internal FLASH_LOAN_RETURN = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    address public immutable override asset;\n    uint256 public storedBalance;\n    uint256 public flashFeeFactor; // Fee on flash loans, as a percentage in fixed point with 18 decimals\n\n    constructor() {\n        asset = IJoinFactory(msg.sender).nextAsset();\n    }\n\n    /// @dev Set the flash loan fee factor\n    function setFlashFeeFactor(uint256 flashFeeFactor_)\n        public\n        auth\n    {\n        flashFeeFactor = flashFeeFactor_;\n        emit FlashFeeFactorSet(flashFeeFactor_);\n    }\n\n    /// @dev Take `amount` `asset` from `user` using `transferFrom`, minus any unaccounted `asset` in this contract.\n    function join(address user, uint128 amount)\n        external override\n        auth\n        returns (uint128)\n    {\n        return _join(user, amount);\n    }\n\n    /// @dev Take `amount` `asset` from `user` using `transferFrom`, minus any unaccounted `asset` in this contract.\n    function _join(address user, uint128 amount)\n        internal\n        returns (uint128)\n    {\n        IERC20 token = IERC20(asset);\n        uint256 _storedBalance = storedBalance;\n        uint256 available = token.balanceOf(address(this)) - _storedBalance; // Fine to panic if this underflows\n        storedBalance = _storedBalance + amount;\n        unchecked { if (available < amount) token.safeTransferFrom(user, address(this), amount - available); }\n        return amount;        \n    }\n\n    /// @dev Transfer `amount` `asset` to `user`\n    function exit(address user, uint128 amount)\n        external override\n        auth\n        returns (uint128)\n    {\n        return _exit(user, amount);\n    }\n\n    /// @dev Transfer `amount` `asset` to `user`\n    function _exit(address user, uint128 amount)\n        internal\n        returns (uint128)\n    {\n        IERC20 token = IERC20(asset);\n        storedBalance -= amount;\n        token.safeTransfer(user, amount);\n        return amount;\n    }\n\n    /// @dev Retrieve any tokens other than the `asset`. Useful for airdropped tokens.\n    function retrieve(IERC20 token, address to)\n        external\n        auth\n    {\n        require(address(token) != address(asset), \"Use exit for asset\");\n        token.safeTransfer(to, token.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev From ERC-3156. The amount of currency available to be lended.\n     * @param token The loan currency. It must be a FYDai contract.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) public view override returns (uint256) {\n        return token == asset ? storedBalance : 0;\n    }\n\n    /**\n     * @dev From ERC-3156. The fee to be charged for a given loan.\n     * @param token The loan currency. It must be the asset.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) public view override returns (uint256) {\n        require(token == asset, \"Unsupported currency\");\n        return _flashFee(amount);\n    }\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function _flashFee(uint256 amount) internal view returns (uint256) {\n        return amount.wmul(flashFeeFactor);\n    }\n\n    /**\n     * @dev From ERC-3156. Loan `amount` `asset` to `receiver`, which needs to return them plus fee to this contract within the same transaction.\n     * If the principal + fee are transferred to this contract, they won't be pulled from the receiver.\n     * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n     * @param token The loan currency. Must be a fyDai contract.\n     * @param amount The amount of tokens lent.\n     * @param data A data parameter to be passed on to the `receiver` for any custom use.\n     */\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes memory data) public override returns(bool) {\n        require(token == asset, \"Unsupported currency\");\n        uint128 _amount = amount.u128();\n        uint128 _fee = _flashFee(amount).u128();\n        _exit(address(receiver), _amount);\n\n        require(receiver.onFlashLoan(msg.sender, token, _amount, _fee, data) == FLASH_LOAN_RETURN, \"Non-compliant borrower\");\n\n        _join(address(receiver), _amount + _fee);\n        return true;\n    }\n}contract AccessControl {\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes4 adminRole;\n    }\n\n    mapping (bytes4 => RoleData) private _roles;\n\n    bytes4 public constant ROOT = 0x00000000;\n    bytes4 public constant LOCK = 0xFFFFFFFF; // Used to disable further permissioning of a function\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role\n     *\n     * `ROOT` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes4 indexed role, bytes4 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call.\n     */\n    event RoleGranted(bytes4 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes4 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Give msg.sender the ROOT role and create a LOCK role with itself as the admin role and no members. \n     * Calling setRoleAdmin(msg.sig, LOCK) means no one can grant that msg.sig role anymore.\n     */\n    constructor () {\n        _grantRole(ROOT, msg.sender);   // Grant ROOT to msg.sender\n        _setRoleAdmin(LOCK, LOCK);      // Create the LOCK role by setting itself as its own admin, creating an independent role tree\n    }\n\n    /**\n     * @dev Each function in the contract has its own role, identified by their msg.sig signature.\n     * ROOT can give and remove access to each function, lock any further access being granted to\n     * a specific action, or even create other roles to delegate admin control over a function.\n     */\n    modifier auth() {\n        require (_hasRole(msg.sig, msg.sender), \"Access denied\");\n        _;\n    }\n\n    /**\n     * @dev Allow only if the caller has been granted the admin role of `role`.\n     */\n    modifier admin(bytes4 role) {\n        require (_hasRole(_getRoleAdmin(role), msg.sender), \"Only admin\");\n        _;\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes4 role, address account) external view returns (bool) {\n        return _hasRole(role, account);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes4 role) external view returns (bytes4) {\n        return _getRoleAdmin(role);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n\n     * If ``role``'s admin role is not `adminRole` emits a {RoleAdminChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function setRoleAdmin(bytes4 role, bytes4 adminRole) external virtual admin(role) {\n        _setRoleAdmin(role, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes4 role, address account) external virtual admin(role) {\n        _grantRole(role, account);\n    }\n\n    \n    /**\n     * @dev Grants all of `role` in `roles` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - For each `role` in `roles`, the caller must have ``role``'s admin role.\n     */\n    function grantRoles(bytes4[] memory roles, address account) external virtual {\n        for (uint256 i = 0; i < roles.length; i++) {\n            require (_hasRole(_getRoleAdmin(roles[i]), msg.sender), \"Only admin\");\n            _grantRole(roles[i], account);\n        }\n    }\n\n    /**\n     * @dev Sets LOCK as ``role``'s admin role. LOCK has no members, so this disables admin management of ``role``.\n\n     * Emits a {RoleAdminChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function lockRole(bytes4 role) external virtual admin(role) {\n        _setRoleAdmin(role, LOCK);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes4 role, address account) external virtual admin(role) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes all of `role` in `roles` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - For each `role` in `roles`, the caller must have ``role``'s admin role.\n     */\n    function revokeRoles(bytes4[] memory roles, address account) external virtual {\n        for (uint256 i = 0; i < roles.length; i++) {\n            require (_hasRole(_getRoleAdmin(roles[i]), msg.sender), \"Only admin\");\n            _revokeRole(roles[i], account);\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes4 role, address account) external virtual {\n        require(account == msg.sender, \"Renounce only for self\");\n\n        _revokeRole(role, account);\n    }\n\n    function _hasRole(bytes4 role, address account) internal view returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    function _getRoleAdmin(bytes4 role) internal view returns (bytes4) {\n        return _roles[role].adminRole;\n    }\n\n    function _setRoleAdmin(bytes4 role, bytes4 adminRole) internal virtual {\n        if (_getRoleAdmin(role) != adminRole) {\n            _roles[role].adminRole = adminRole;\n            emit RoleAdminChanged(role, adminRole);\n        }\n    }\n\n    function _grantRole(bytes4 role, address account) internal {\n        if (!_hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, msg.sender);\n        }\n    }\n\n    function _revokeRole(bytes4 role, address account) internal {\n        if (_hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, msg.sender);\n        }\n    }\n}contract Pool is IPool, ERC20Permit, Ownable {\n    using SafeCast256 for uint256;\n    using SafeCast128 for uint128;\n    using MinimalTransferHelper for IERC20;\n\n    event Trade(uint32 maturity, address indexed from, address indexed to, int256 bases, int256 fyTokens);\n    event Liquidity(uint32 maturity, address indexed from, address indexed to, int256 bases, int256 fyTokens, int256 poolTokens);\n    event Sync(uint112 baseCached, uint112 fyTokenCached, uint256 cumulativeBalancesRatio);\n    event ParameterSet(bytes32 parameter, int128 k);\n\n    int128 private k1 = int128(uint128(uint256((1 << 64))) / 315576000); // 1 / Seconds in 10 years, in 64.64\n    int128 private g1 = int128(uint128(uint256((950 << 64))) / 1000); // To be used when selling base to the pool. All constants are `ufixed`, to divide them they must be converted to uint256\n    int128 private k2 = int128(uint128(uint256((1 << 64))) / 315576000); // k is stored twice to be able to recover with 1 SLOAD alongside both g1 and g2\n    int128 private g2 = int128(uint128(uint256((1000 << 64))) / 950); // To be used when selling fyToken to the pool. All constants are `ufixed`, to divide them they must be converted to uint256\n    uint32 public immutable override maturity;\n\n    IERC20 public immutable override base;\n    IFYToken public immutable override fyToken;\n\n    uint112 private baseCached;              // uses single storage slot, accessible via getCache\n    uint112 private fyTokenCached;           // uses single storage slot, accessible via getCache\n    uint32  private blockTimestampLast;             // uses single storage slot, accessible via getCache\n\n    uint256 public cumulativeBalancesRatio;\n\n    constructor()\n        ERC20Permit(\n            string(abi.encodePacked(\"Yield \", SafeERC20Namer.tokenName(IPoolFactory(msg.sender).nextFYToken()), \" LP Token\")),\n            string(abi.encodePacked(SafeERC20Namer.tokenSymbol(IPoolFactory(msg.sender).nextFYToken()), \"LP\")),\n            SafeERC20Namer.tokenDecimals(IPoolFactory(msg.sender).nextBase())\n        )\n    {\n        IFYToken _fyToken = IFYToken(IPoolFactory(msg.sender).nextFYToken());\n        fyToken = _fyToken;\n        base = IERC20(IPoolFactory(msg.sender).nextBase());\n\n        uint256 _maturity = _fyToken.maturity();\n        require (_maturity <= type(uint32).max, \"Pool: Maturity too far in the future\");\n        maturity = uint32(_maturity);\n    }\n\n    /// @dev Trading can only be done before maturity\n    modifier beforeMaturity() {\n        require(\n            block.timestamp < maturity,\n            \"Pool: Too late\"\n        );\n        _;\n    }\n\n    // ---- Administration ----\n\n    /// @dev Set the k, g1 or g2 parameters\n    function setParameter(bytes32 parameter, int128 value) public onlyOwner {\n        if (parameter == \"k\") k1 = k2 = value;\n        else if (parameter == \"g1\") g1 = value;\n        else if (parameter == \"g2\") g2 = value;\n        else revert(\"Pool: Unrecognized parameter\");\n        emit ParameterSet(parameter, value);\n    }\n\n    /// @dev Get k\n    function getK() public view returns (int128) {\n        assert(k1 == k2);\n        return k1;\n    }\n\n    /// @dev Get g1\n    function getG1() public view returns (int128) {\n        return g1;\n    }\n\n    /// @dev Get g2\n    function getG2() public view returns (int128) {\n        return g2;\n    }\n\n    // ---- Balances management ----\n\n    /// @dev Updates the cache to match the actual balances.\n    function sync() external {\n        _update(getBaseBalance(), getFYTokenBalance(), baseCached, fyTokenCached);\n    }\n\n    /// @dev Returns the cached balances & last updated timestamp.\n    /// @return Cached base token balance.\n    /// @return Cached virtual FY token balance.\n    /// @return Timestamp that balances were last cached.\n    function getCache() public view returns (uint112, uint112, uint32) {\n        return (baseCached, fyTokenCached, blockTimestampLast);\n    }\n\n    /// @dev Returns the \"virtual\" fyToken balance, which is the real balance plus the pool token supply.\n    function getFYTokenBalance()\n        public view override\n        returns(uint112)\n    {\n        return (fyToken.balanceOf(address(this)) + _totalSupply).u112();\n    }\n\n    /// @dev Returns the base balance\n    function getBaseBalance()\n        public view override\n        returns(uint112)\n    {\n        return base.balanceOf(address(this)).u112();\n    }\n\n    /// @dev Retrieve any base tokens not accounted for in the cache\n    function retrieveBase(address to)\n        external override\n        returns(uint128 retrieved)\n    {\n        retrieved = getBaseBalance() - baseCached; // Cache can never be above balances\n        base.safeTransfer(to, retrieved);\n        // Now the current balances match the cache, so no need to update the TWAR\n    }\n\n    /// @dev Retrieve any fyTokens not accounted for in the cache\n    function retrieveFYToken(address to)\n        external override\n        returns(uint128 retrieved)\n    {\n        retrieved = getFYTokenBalance() - fyTokenCached; // Cache can never be above balances\n        IERC20(address(fyToken)).safeTransfer(to, retrieved);\n        // Now the balances match the cache, so no need to update the TWAR\n    }\n\n    /// @dev Update cache and, on the first call per block, ratio accumulators\n    function _update(uint128 baseBalance, uint128 fyBalance, uint112 _baseCached, uint112 _fyTokenCached) private {\n        uint32 blockTimestamp = uint32(block.timestamp);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _baseCached != 0 && _fyTokenCached != 0) {\n            uint256 scaledFYTokenCached = uint256(_fyTokenCached) * 1e27;\n            cumulativeBalancesRatio += scaledFYTokenCached / _baseCached * timeElapsed;\n        }\n        baseCached = baseBalance.u112();\n        fyTokenCached = fyBalance.u112();\n        blockTimestampLast = blockTimestamp;\n        emit Sync(baseCached, fyTokenCached, cumulativeBalancesRatio);\n    }\n\n    // ---- Liquidity ----\n\n    /// @dev Mint liquidity tokens in exchange for adding base and fyToken\n    /// The amount of liquidity tokens to mint is calculated from the amount of unaccounted for base tokens in this contract.\n    /// A proportional amount of fyTokens needs to be present in this contract, also unaccounted for.\n    /// @param to Wallet receiving the minted liquidity tokens.\n    /// @param calculateFromBase Calculate the amount of tokens to mint from the base tokens available, leaving a fyToken surplus.\n    /// @param minTokensMinted Minimum amount of liquidity tokens received.\n    /// @return The amount of liquidity tokens minted.\n    function mint(address to, bool calculateFromBase, uint256 minTokensMinted)\n        external override\n        returns (uint256, uint256, uint256)\n    {\n        return _mintInternal(to, calculateFromBase, 0, minTokensMinted);\n    }\n\n    /// @dev Mint liquidity tokens in exchange for adding only base\n    /// The amount of liquidity tokens is calculated from the amount of fyToken to buy from the pool.\n    /// The base tokens need to be present in this contract, unaccounted for.\n    /// @param to Wallet receiving the minted liquidity tokens.\n    /// @param fyTokenToBuy Amount of `fyToken` being bought in the Pool, from this we calculate how much base it will be taken in.\n    /// @param minTokensMinted Minimum amount of liquidity tokens received.\n    /// @return The amount of liquidity tokens minted.\n    function mintWithBase(address to, uint256 fyTokenToBuy, uint256 minTokensMinted)\n        external override\n        returns (uint256, uint256, uint256)\n    {\n        return _mintInternal(to, false, fyTokenToBuy, minTokensMinted);\n    }\n\n    /// @dev Mint liquidity tokens in exchange for adding only base, if fyTokenToBuy > 0.\n    /// If fyTokenToBuy == 0, mint liquidity tokens for both basea and fyToken.\n    /// @param to Wallet receiving the minted liquidity tokens.\n    /// @param calculateFromBase Calculate the amount of tokens to mint from the base tokens available, leaving a fyToken surplus.\n    /// @param fyTokenToBuy Amount of `fyToken` being bought in the Pool, from this we calculate how much base it will be taken in.\n    /// @param minTokensMinted Minimum amount of liquidity tokens received.\n    /// @return The amount of liquidity tokens minted.\n    function _mintInternal(address to, bool calculateFromBase, uint256 fyTokenToBuy, uint256 minTokensMinted)\n        internal\n        returns (uint256, uint256, uint256)\n    {\n        // Gather data\n        uint256 supply = _totalSupply;\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        uint256 _realFYTokenCached = _fyTokenCached - supply;    // The fyToken cache includes the virtual fyToken, equal to the supply\n\n        // Calculate trade\n        uint256 tokensMinted;\n        uint256 baseIn;\n        uint256 baseReturned;\n        uint256 fyTokenIn;\n\n        if (supply == 0) {\n            require (calculateFromBase && fyTokenToBuy == 0, \"Pool: Initialize only from base\");\n            baseIn = base.balanceOf(address(this)) - _baseCached;\n            tokensMinted = baseIn;   // If supply == 0 we are initializing the pool and tokensMinted == baseIn; fyTokenIn == 0\n        } else {\n            // There is an optional virtual trade before the mint\n            uint256 baseToSell;\n            if (fyTokenToBuy > 0) {     // calculateFromBase == true and fyTokenToBuy > 0 can't happen in this implementation. To implement a virtual trade and calculateFromBase the trade would need to be a BaseToBuy parameter.\n                baseToSell = _buyFYTokenPreview(\n                    fyTokenToBuy.u128(),\n                    _baseCached,\n                    _fyTokenCached\n                ); \n            }\n\n            if (calculateFromBase) {   // We use all the available base tokens, surplus is in fyTokens\n                baseIn = base.balanceOf(address(this)) - _baseCached;\n                tokensMinted = (supply * baseIn) / _baseCached;\n                fyTokenIn = (_realFYTokenCached * tokensMinted) / supply;\n                require(_realFYTokenCached + fyTokenIn <= fyToken.balanceOf(address(this)), \"Pool: Not enough fyToken in\");\n            } else {                   // We use all the available fyTokens, plus a virtual trade if it happened, surplus is in base tokens\n                fyTokenIn = fyToken.balanceOf(address(this)) - _realFYTokenCached;\n                tokensMinted = (supply * (fyTokenToBuy + fyTokenIn)) / (_realFYTokenCached - fyTokenToBuy);\n                baseIn = baseToSell + ((_baseCached + baseToSell) * tokensMinted) / supply;\n                uint256 _baseBalance = base.balanceOf(address(this));\n                require(_baseBalance - _baseCached >= baseIn, \"Pool: Not enough base token in\");\n                \n                // If we did a trade means we came in through `mintWithBase`, and want to return the base token surplus\n                if (fyTokenToBuy > 0) baseReturned = (_baseBalance - _baseCached) - baseIn;\n            }\n        }\n\n        // Slippage\n        require (tokensMinted >= minTokensMinted, \"Pool: Not enough tokens minted\");\n\n        // Update TWAR\n        _update(\n            (_baseCached + baseIn).u128(),\n            (_fyTokenCached + fyTokenIn + tokensMinted).u128(), // Account for the \"virtual\" fyToken from the new minted LP tokens\n            _baseCached,\n            _fyTokenCached\n        );\n\n        // Execute mint\n        _mint(to, tokensMinted);\n\n        // Return any unused base if we did a trade, meaning slippage was involved.\n        if (supply > 0 && fyTokenToBuy > 0) base.safeTransfer(to, baseReturned);\n\n        emit Liquidity(maturity, msg.sender, to, -(baseIn.i256()), -(fyTokenIn.i256()), tokensMinted.i256());\n        return (baseIn, fyTokenIn, tokensMinted);\n    }\n\n    /// @dev Burn liquidity tokens in exchange for base and fyToken.\n    /// The liquidity tokens need to be in this contract.\n    /// @param to Wallet receiving the base and fyToken.\n    /// @return The amount of tokens burned and returned (tokensBurned, bases, fyTokens).\n    function burn(address to, uint256 minBaseOut, uint256 minFYTokenOut)\n        external override\n        returns (uint256, uint256, uint256)\n    {\n        return _burnInternal(to, false, minBaseOut, minFYTokenOut);\n    }\n\n    /// @dev Burn liquidity tokens in exchange for base.\n    /// The liquidity provider needs to have called `pool.approve`.\n    /// @param to Wallet receiving the base and fyToken.\n    /// @return tokensBurned The amount of lp tokens burned.\n    /// @return baseOut The amount of base tokens returned.\n    function burnForBase(address to, uint256 minBaseOut)\n        external override\n        returns (uint256 tokensBurned, uint256 baseOut)\n    {\n        (tokensBurned, baseOut, ) = _burnInternal(to, true, minBaseOut, 0);\n    }\n\n\n    /// @dev Burn liquidity tokens in exchange for base.\n    /// The liquidity provider needs to have called `pool.approve`.\n    /// @param to Wallet receiving the base and fyToken.\n    /// @param tradeToBase Whether the resulting fyToken should be traded for base tokens.\n    /// @return The amount of base tokens returned.\n    function _burnInternal(address to, bool tradeToBase, uint256 minBaseOut, uint256 minFYTokenOut)\n        internal\n        returns (uint256, uint256, uint256)\n    {\n        \n        uint256 tokensBurned = _balanceOf[address(this)];\n        uint256 supply = _totalSupply;\n        uint256 fyTokenBalance = fyToken.balanceOf(address(this));          // use the real balance rather than the virtual one\n        uint256 baseBalance = base.balanceOf(address(this));\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n\n        // Calculate trade\n        uint256 tokenOut = (tokensBurned * baseBalance) / supply;\n        uint256 fyTokenOut = (tokensBurned * fyTokenBalance) / supply;\n\n        if (tradeToBase) {\n            (int128 _k, int128 _g2) = (k2, g2);\n            tokenOut += YieldMath.baseOutForFYTokenIn(                      // This is a virtual sell\n                _baseCached - tokenOut.u128(),                              // Cache, minus virtual burn\n                _fyTokenCached - fyTokenOut.u128(),                         // Cache, minus virtual burn\n                fyTokenOut.u128(),                                          // Sell the virtual fyToken obtained\n                maturity - uint32(block.timestamp),                         // This can't be called after maturity\n                _k,\n                _g2\n            );\n            fyTokenOut = 0;\n        }\n\n        // Slippage\n        require (tokenOut >= minBaseOut, \"Pool: Not enough base tokens obtained\");\n        require (fyTokenOut >= minFYTokenOut, \"Pool: Not enough fyToken obtained\");\n\n        // Update TWAR\n        _update(\n            (baseBalance - tokenOut).u128(),\n            (fyTokenBalance - fyTokenOut + supply - tokensBurned).u128(),\n            _baseCached,\n            _fyTokenCached\n        );\n\n        // Transfer assets\n        _burn(address(this), tokensBurned);\n        base.safeTransfer(to, tokenOut);\n        if (fyTokenOut > 0) IERC20(address(fyToken)).safeTransfer(to, fyTokenOut);\n\n        emit Liquidity(maturity, msg.sender, to, tokenOut.i256(), fyTokenOut.i256(), -(tokensBurned.i256()));\n        return (tokensBurned, tokenOut, 0);\n    }\n\n    // ---- Trading ----\n\n    /// @dev Sell base for fyToken.\n    /// The trader needs to have transferred the amount of base to sell to the pool before in the same transaction.\n    /// @param to Wallet receiving the fyToken being bought\n    /// @param min Minimm accepted amount of fyToken\n    /// @return Amount of fyToken that will be deposited on `to` wallet\n    function sellBase(address to, uint128 min)\n        external override\n        returns(uint128)\n    {\n        // Calculate trade\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        uint112 _baseBalance = getBaseBalance();\n        uint112 _fyTokenBalance = getFYTokenBalance();\n        uint128 baseIn = _baseBalance - _baseCached;\n        uint128 fyTokenOut = _sellBasePreview(\n            baseIn,\n            _baseCached,\n            _fyTokenBalance\n        );\n\n        // Slippage check\n        require(\n            fyTokenOut >= min,\n            \"Pool: Not enough fyToken obtained\"\n        );\n\n        // Update TWAR\n        _update(\n            _baseBalance,\n            _fyTokenBalance - fyTokenOut,\n            _baseCached,\n            _fyTokenCached\n        );\n\n        // Transfer assets\n        IERC20(address(fyToken)).safeTransfer(to, fyTokenOut);\n\n        emit Trade(maturity, msg.sender, to, -(baseIn.i128()), fyTokenOut.i128());\n        return fyTokenOut;\n    }\n\n    /// @dev Returns how much fyToken would be obtained by selling `baseIn` base\n    /// @param baseIn Amount of base hypothetically sold.\n    /// @return Amount of fyToken hypothetically bought.\n    function sellBasePreview(uint128 baseIn)\n        external view override\n        returns(uint128)\n    {\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        return _sellBasePreview(baseIn, _baseCached, _fyTokenCached);\n    }\n\n    /// @dev Returns how much fyToken would be obtained by selling `baseIn` base\n    function _sellBasePreview(\n        uint128 baseIn,\n        uint112 baseBalance,\n        uint112 fyTokenBalance\n    )\n        private view\n        beforeMaturity\n        returns(uint128)\n    {\n        (int128 _k, int128 _g1) = (k1, g1);\n        uint128 fyTokenOut = YieldMath.fyTokenOutForBaseIn(\n            baseBalance,\n            fyTokenBalance,\n            baseIn,\n            maturity - uint32(block.timestamp),             // This can't be called after maturity\n            _k,\n            _g1\n        );\n\n        require(\n            fyTokenBalance - fyTokenOut >= baseBalance + baseIn,\n            \"Pool: fyToken balance too low\"\n        );\n\n        return fyTokenOut;\n    }\n\n    /// @dev Buy base for fyToken\n    /// The trader needs to have called `fyToken.approve`\n    /// @param to Wallet receiving the base being bought\n    /// @param tokenOut Amount of base being bought that will be deposited in `to` wallet\n    /// @param max Maximum amount of fyToken that will be paid for the trade\n    /// @return Amount of fyToken that will be taken from caller\n    function buyBase(address to, uint128 tokenOut, uint128 max)\n        external override\n        returns(uint128)\n    {\n        // Calculate trade\n        uint128 fyTokenBalance = getFYTokenBalance();\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        uint128 fyTokenIn = _buyBasePreview(\n            tokenOut,\n            _baseCached,\n            _fyTokenCached\n        );\n        require(\n            fyTokenBalance - _fyTokenCached >= fyTokenIn,\n            \"Pool: Not enough fyToken in\"\n        );\n\n        // Slippage check\n        require(\n            fyTokenIn <= max,\n            \"Pool: Too much fyToken in\"\n        );\n\n        // Update TWAR\n        _update(\n            _baseCached - tokenOut,\n            _fyTokenCached + fyTokenIn,\n            _baseCached,\n            _fyTokenCached\n        );\n\n        // Transfer assets\n        base.safeTransfer(to, tokenOut);\n\n        emit Trade(maturity, msg.sender, to, tokenOut.i128(), -(fyTokenIn.i128()));\n        return fyTokenIn;\n    }\n\n    /// @dev Returns how much fyToken would be required to buy `tokenOut` base.\n    /// @param tokenOut Amount of base hypothetically desired.\n    /// @return Amount of fyToken hypothetically required.\n    function buyBasePreview(uint128 tokenOut)\n        external view override\n        returns(uint128)\n    {\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        return _buyBasePreview(tokenOut, _baseCached, _fyTokenCached);\n    }\n\n    /// @dev Returns how much fyToken would be required to buy `tokenOut` base.\n    function _buyBasePreview(\n        uint128 tokenOut,\n        uint112 baseBalance,\n        uint112 fyTokenBalance\n    )\n        private view\n        beforeMaturity\n        returns(uint128)\n    {\n        (int128 _k, int128 _g2) = (k2, g2);\n        return YieldMath.fyTokenInForBaseOut(\n            baseBalance,\n            fyTokenBalance,\n            tokenOut,\n            maturity - uint32(block.timestamp),             // This can't be called after maturity\n            _k,\n            _g2\n        );\n    }\n\n    /// @dev Sell fyToken for base\n    /// The trader needs to have transferred the amount of fyToken to sell to the pool before in the same transaction.\n    /// @param to Wallet receiving the base being bought\n    /// @param min Minimm accepted amount of base\n    /// @return Amount of base that will be deposited on `to` wallet\n    function sellFYToken(address to, uint128 min)\n        external override\n        returns(uint128)\n    {\n        // Calculate trade\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        uint112 _fyTokenBalance = getFYTokenBalance();\n        uint112 _baseBalance = getBaseBalance();\n        uint128 fyTokenIn = _fyTokenBalance - _fyTokenCached;\n        uint128 baseOut = _sellFYTokenPreview(\n            fyTokenIn,\n            _baseCached,\n            _fyTokenCached\n        );\n\n        // Slippage check\n        require(\n            baseOut >= min,\n            \"Pool: Not enough base obtained\"\n        );\n\n        // Update TWAR\n        _update(\n            _baseBalance - baseOut,\n            _fyTokenBalance,\n            _baseCached,\n            _fyTokenCached\n        );\n\n        // Transfer assets\n        base.safeTransfer(to, baseOut);\n\n        emit Trade(maturity, msg.sender, to, baseOut.i128(), -(fyTokenIn.i128()));\n        return baseOut;\n    }\n\n    /// @dev Returns how much base would be obtained by selling `fyTokenIn` fyToken.\n    /// @param fyTokenIn Amount of fyToken hypothetically sold.\n    /// @return Amount of base hypothetically bought.\n    function sellFYTokenPreview(uint128 fyTokenIn)\n        external view override\n        returns(uint128)\n    {\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        return _sellFYTokenPreview(fyTokenIn, _baseCached, _fyTokenCached);\n    }\n\n    /// @dev Returns how much base would be obtained by selling `fyTokenIn` fyToken.\n    function _sellFYTokenPreview(\n        uint128 fyTokenIn,\n        uint112 baseBalance,\n        uint112 fyTokenBalance\n    )\n        private view\n        beforeMaturity\n        returns(uint128)\n    {\n        (int128 _k, int128 _g2) = (k2, g2);\n        return YieldMath.baseOutForFYTokenIn(\n            baseBalance,\n            fyTokenBalance,\n            fyTokenIn,\n            maturity - uint32(block.timestamp),             // This can't be called after maturity\n            _k,\n            _g2\n        );\n    }\n\n    /// @dev Buy fyToken for base\n    /// The trader needs to have called `base.approve`\n    /// @param to Wallet receiving the fyToken being bought\n    /// @param fyTokenOut Amount of fyToken being bought that will be deposited in `to` wallet\n    /// @param max Maximum amount of base token that will be paid for the trade\n    /// @return Amount of base that will be taken from caller's wallet\n    function buyFYToken(address to, uint128 fyTokenOut, uint128 max)\n        external override\n        returns(uint128)\n    {\n        // Calculate trade\n        uint128 baseBalance = getBaseBalance();\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        uint128 baseIn = _buyFYTokenPreview(\n            fyTokenOut,\n            _baseCached,\n            _fyTokenCached\n        );\n        require(\n            baseBalance - _baseCached >= baseIn,\n            \"Pool: Not enough base token in\"\n        );\n\n        // Slippage check\n        require(\n            baseIn <= max,\n            \"Pool: Too much base token in\"\n        );\n\n        // Update TWAR\n        _update(\n            _baseCached + baseIn,\n            _fyTokenCached - fyTokenOut,\n            _baseCached,\n            _fyTokenCached\n        );\n\n        // Transfer assets\n        IERC20(address(fyToken)).safeTransfer(to, fyTokenOut);\n\n        emit Trade(maturity, msg.sender, to, -(baseIn.i128()), fyTokenOut.i128());\n        return baseIn;\n    }\n\n    /// @dev Returns how much base would be required to buy `fyTokenOut` fyToken.\n    /// @param fyTokenOut Amount of fyToken hypothetically desired.\n    /// @return Amount of base hypothetically required.\n    function buyFYTokenPreview(uint128 fyTokenOut)\n        external view override\n        returns(uint128)\n    {\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        return _buyFYTokenPreview(fyTokenOut, _baseCached, _fyTokenCached);\n    }\n\n    /// @dev Returns how much base would be required to buy `fyTokenOut` fyToken.\n    function _buyFYTokenPreview(\n        uint128 fyTokenOut,\n        uint128 baseBalance,\n        uint128 fyTokenBalance\n    )\n        private view\n        beforeMaturity\n        returns(uint128)\n    {\n        (int128 _k, int128 _g1) = (k1, g1);\n        uint128 baseIn = YieldMath.baseInForFYTokenOut(\n            baseBalance,\n            fyTokenBalance,\n            fyTokenOut,\n            maturity - uint32(block.timestamp),             // This can't be called after maturity\n            _k,\n            _g1\n        );\n\n        require(\n            fyTokenBalance - fyTokenOut >= baseBalance + baseIn,\n            \"Pool: fyToken balance too low\"\n        );\n\n        return baseIn;\n    }\n}\ncontract Cauldron is AccessControl() {\n    using CauldronMath for uint128;\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU128I128 for uint128;\n    using CastU256U32 for uint256;\n    using CastU256I256 for uint256;\n    using CastI128U128 for int128;\n\n    event AuctionIntervalSet(uint32 indexed auctionInterval);\n    event AssetAdded(bytes6 indexed assetId, address indexed asset);\n    event SeriesAdded(bytes6 indexed seriesId, bytes6 indexed baseId, address indexed fyToken);\n    event IlkAdded(bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event SpotOracleAdded(bytes6 indexed baseId, bytes6 indexed ilkId, address indexed oracle, uint32 ratio);\n    event RateOracleAdded(bytes6 indexed baseId, address indexed oracle);\n    event DebtLimitsSet(bytes6 indexed baseId, bytes6 indexed ilkId, uint96 max, uint24 min, uint8 dec);\n\n    event VaultBuilt(bytes12 indexed vaultId, address indexed owner, bytes6 indexed seriesId, bytes6 ilkId);\n    event VaultTweaked(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event VaultDestroyed(bytes12 indexed vaultId);\n    event VaultGiven(bytes12 indexed vaultId, address indexed receiver);\n\n    event VaultPoured(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId, int128 ink, int128 art);\n    event VaultStirred(bytes12 indexed from, bytes12 indexed to, uint128 ink, uint128 art);\n    event VaultRolled(bytes12 indexed vaultId, bytes6 indexed seriesId, uint128 art);\n    event VaultLocked(bytes12 indexed vaultId, uint256 indexed timestamp);\n\n    event SeriesMatured(bytes6 indexed seriesId, uint256 rateAtMaturity);\n\n    // ==== Configuration data ====\n    mapping (bytes6 => address)                                 public assets;          // Underlyings and collaterals available in Cauldron. 12 bytes still free.\n    mapping (bytes6 => DataTypes.Series)                        public series;          // Series available in Cauldron. We can possibly use a bytes6 (3e14 possible series).\n    mapping (bytes6 => mapping(bytes6 => bool))                 public ilks;            // [seriesId][assetId] Assets that are approved as collateral for a series\n\n    mapping (bytes6 => IOracle)                                 public rateOracles;     // Rate (borrowing rate) accruals oracle for the underlying\n    mapping (bytes6 => mapping(bytes6 => DataTypes.SpotOracle)) public spotOracles;     // [assetId][assetId] Spot price oracles\n\n    // ==== Protocol data ====\n    mapping (bytes6 => mapping(bytes6 => DataTypes.Debt))       public debt;            // [baseId][ilkId] Max and sum of debt per underlying and collateral.\n    mapping (bytes6 => uint256)                                 public ratesAtMaturity; // Borrowing rate at maturity for a mature series\n    uint32                                                      public auctionInterval;// Time that vaults in liquidation are protected from being grabbed by a different engine.\n\n    // ==== User data ====\n    mapping (bytes12 => DataTypes.Vault)                        public vaults;          // An user can own one or more Vaults, each one with a bytes12 identifier\n    mapping (bytes12 => DataTypes.Balances)                     public balances;        // Both debt and assets\n    mapping (bytes12 => uint32)                                 public auctions;        // If grater than zero, time that a vault was timestamped. Used for liquidation.\n\n    // ==== Administration ====\n\n    /// @dev Add a new Asset.\n    function addAsset(bytes6 assetId, address asset)\n        external\n        auth\n    {\n        require (assetId != bytes6(0), \"Asset id is zero\");\n        require (assets[assetId] == address(0), \"Id already used\");\n        assets[assetId] = asset;\n        emit AssetAdded(assetId, address(asset));\n    }\n\n    /// @dev Set the maximum and minimum debt for an underlying and ilk pair. Can be reset.\n    function setDebtLimits(bytes6 baseId, bytes6 ilkId, uint96 max, uint24 min, uint8 dec)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        DataTypes.Debt memory debt_ = debt[baseId][ilkId];\n        debt_.max = max;\n        debt_.min = min;\n        debt_.dec = dec;\n        debt[baseId][ilkId] = debt_;\n        emit DebtLimitsSet(baseId, ilkId, max, min, dec);\n    }\n\n    /// @dev Set a rate oracle. Can be reset.\n    function setRateOracle(bytes6 baseId, IOracle oracle)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        rateOracles[baseId] = oracle;\n        emit RateOracleAdded(baseId, address(oracle));\n    }\n\n    /// @dev Set the interval for which vaults being auctioned can't be grabbed by another liquidation engine\n    function setAuctionInterval(uint32 auctionInterval_)\n        external\n        auth\n    {\n        auctionInterval = auctionInterval_;\n        emit AuctionIntervalSet(auctionInterval_);\n    }\n\n    /// @dev Set a spot oracle and its collateralization ratio. Can be reset.\n    function setSpotOracle(bytes6 baseId, bytes6 ilkId, IOracle oracle, uint32 ratio)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        spotOracles[baseId][ilkId] = DataTypes.SpotOracle({\n            oracle: oracle,\n            ratio: ratio                                                                    // With 6 decimals. 1000000 == 100%\n        });                                                                                 // Allows to replace an existing oracle.\n        emit SpotOracleAdded(baseId, ilkId, address(oracle), ratio);\n    }\n\n    /// @dev Add a new series\n    function addSeries(bytes6 seriesId, bytes6 baseId, IFYToken fyToken)\n        external\n        auth\n    {\n        require (seriesId != bytes6(0), \"Series id is zero\");\n        address base = assets[baseId];\n        require (base != address(0), \"Base not found\");\n        require (fyToken != IFYToken(address(0)), \"Series need a fyToken\");\n        require (fyToken.underlying() == base, \"Mismatched series and base\");\n        require (rateOracles[baseId] != IOracle(address(0)), \"Rate oracle not found\");\n        require (series[seriesId].fyToken == IFYToken(address(0)), \"Id already used\");\n        series[seriesId] = DataTypes.Series({\n            fyToken: fyToken,\n            maturity: fyToken.maturity().u32(),\n            baseId: baseId\n        });\n        emit SeriesAdded(seriesId, baseId, address(fyToken));\n    }\n\n    /// @dev Add a new Ilk (approve an asset as collateral for a series).\n    function addIlks(bytes6 seriesId, bytes6[] calldata ilkIds)\n        external\n        auth\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (\n            series_.fyToken != IFYToken(address(0)),\n            \"Series not found\"\n        );\n        for (uint256 i = 0; i < ilkIds.length; i++) {\n            require (\n                spotOracles[series_.baseId][ilkIds[i]].oracle != IOracle(address(0)),\n                \"Spot oracle not found\"\n            );\n            ilks[seriesId][ilkIds[i]] = true;\n            emit IlkAdded(seriesId, ilkIds[i]);\n        }\n    }\n\n    // ==== Vault management ====\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function build(address owner, bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        require (vaultId != bytes12(0), \"Vault id is zero\");\n        require (vaults[vaultId].seriesId == bytes6(0), \"Vault already exists\");   // Series can't take bytes6(0) as their id\n        require (ilks[seriesId][ilkId] == true, \"Ilk not added to series\");\n        vault = DataTypes.Vault({\n            owner: owner,\n            seriesId: seriesId,\n            ilkId: ilkId\n        });\n        vaults[vaultId] = vault;\n\n        emit VaultBuilt(vaultId, owner, seriesId, ilkId);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function destroy(bytes12 vaultId)\n        external\n        auth\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        require (balances_.art == 0 && balances_.ink == 0, \"Only empty vaults\");\n        delete auctions[vaultId];\n        delete vaults[vaultId];\n        emit VaultDestroyed(vaultId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    function _tweak(bytes12 vaultId, DataTypes.Vault memory vault)\n        internal\n    {\n        require (ilks[vault.seriesId][vault.ilkId] == true, \"Ilk not added to series\");\n\n        vaults[vaultId] = vault;\n        emit VaultTweaked(vaultId, vault.seriesId, vault.ilkId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    /// We can change the series if there is no debt, or assets if there are no assets\n    function tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        vault = vaults[vaultId];\n        if (seriesId != vault.seriesId) {\n            require (balances_.art == 0, \"Only with no debt\");\n            vault.seriesId = seriesId;\n        }\n        if (ilkId != vault.ilkId) {\n            require (balances_.ink == 0, \"Only with no collateral\");\n            vault.ilkId = ilkId;\n        }\n        _tweak(vaultId, vault);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function _give(bytes12 vaultId, address receiver)\n        internal\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = vaults[vaultId];\n        vault.owner = receiver;\n        vaults[vaultId] = vault;\n        emit VaultGiven(vaultId, receiver);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function give(bytes12 vaultId, address receiver)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = _give(vaultId, receiver);\n    }\n\n    // ==== Asset and debt management ====\n\n    function vaultData(bytes12 vaultId, bool getSeries)\n        internal\n        view\n        returns (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_)\n    {\n        vault_ = vaults[vaultId];\n        require (vault_.seriesId != bytes6(0), \"Vault not found\");\n        if (getSeries) series_ = series[vault_.seriesId];\n        balances_ = balances[vaultId];\n    }\n\n    /// @dev Move collateral and debt between vaults.\n    function stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vaultFrom, , DataTypes.Balances memory balancesFrom) = vaultData(from, false);\n        (DataTypes.Vault memory vaultTo, , DataTypes.Balances memory balancesTo) = vaultData(to, false);\n\n        if (ink > 0) {\n            require (vaultFrom.ilkId == vaultTo.ilkId, \"Different collateral\");\n            balancesFrom.ink -= ink;\n            balancesTo.ink += ink;\n        }\n        if (art > 0) {\n            require (vaultFrom.seriesId == vaultTo.seriesId, \"Different series\");\n            balancesFrom.art -= art;\n            balancesTo.art += art;\n        }\n\n        balances[from] = balancesFrom;\n        balances[to] = balancesTo;\n\n        if (ink > 0) require(_level(vaultFrom, balancesFrom, series[vaultFrom.seriesId]) >= 0, \"Undercollateralized at origin\");\n        if (art > 0) require(_level(vaultTo, balancesTo, series[vaultTo.seriesId]) >= 0, \"Undercollateralized at destination\");\n\n        emit VaultStirred(from, to, ink, art);\n        return (balancesFrom, balancesTo);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    function _pour(\n        bytes12 vaultId,\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_,\n        int128 ink,\n        int128 art\n    )\n        internal returns (DataTypes.Balances memory)\n    {\n        // For now, the collateralization checks are done outside to allow for underwater operation. That might change.\n        if (ink != 0) {\n            balances_.ink = balances_.ink.add(ink);\n        }\n\n        // Modify vault and global debt records. If debt increases, check global limit.\n        if (art != 0) {\n            DataTypes.Debt memory debt_ = debt[series_.baseId][vault_.ilkId];\n            balances_.art = balances_.art.add(art);\n            debt_.sum = debt_.sum.add(art);\n            uint128 dust = debt_.min * uint128(10) ** debt_.dec;\n            uint128 line = debt_.max * uint128(10) ** debt_.dec;\n            require (balances_.art == 0 || balances_.art >= dust, \"Min debt not reached\");\n            if (art > 0) require (debt_.sum <= line, \"Max debt exceeded\");\n            debt[series_.baseId][vault_.ilkId] = debt_;\n        }\n        balances[vaultId] = balances_;\n\n        emit VaultPoured(vaultId, vault_.seriesId, vault_.ilkId, ink, art);\n        return balances_;\n    }\n\n    /// @dev Manipulate a vault, ensuring it is collateralized afterwards.\n    /// To be used by debt management contracts.\n    function pour(bytes12 vaultId, int128 ink, int128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, ink, art);\n\n        if (balances_.art > 0 && (ink < 0 || art > 0))                          // If there is debt and we are less safe\n            require(_level(vault_, balances_, series_) >= 0, \"Undercollateralized\");\n        return balances_;\n    }\n\n    /// @dev Give a non-timestamped vault to another user, and timestamp it.\n    /// To be used for liquidation engines.\n    function grab(bytes12 vaultId, address receiver)\n        external\n        auth\n    {\n        uint32 now_ = uint32(block.timestamp);\n        require (auctions[vaultId] + auctionInterval <= now_, \"Vault under auction\");        // Grabbing a vault protects it for a day from being grabbed by another liquidator. All grabbed vaults will be suddenly released on the 7th of February 2106, at 06:28:16 GMT. I can live with that.\n\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        require(_level(vault_, balances_, series_) < 0, \"Not undercollateralized\");\n\n        auctions[vaultId] = now_;\n        _give(vaultId, receiver);\n\n        emit VaultLocked(vaultId, now_);\n    }\n\n    /// @dev Reduce debt and collateral from a vault, ignoring collateralization checks.\n    /// To be used by liquidation engines.\n    function slurp(bytes12 vaultId, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, -(ink.i128()), -(art.i128()));\n\n        return balances_;\n    }\n\n    /// @dev Change series and debt of a vault.\n    /// The module calling this function also needs to buy underlying in the pool for the new series, and sell it in pool for the old series.\n    function roll(bytes12 vaultId, bytes6 newSeriesId, int128 art)\n        external\n        auth\n        returns (DataTypes.Vault memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory oldSeries_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        DataTypes.Series memory newSeries_ = series[newSeriesId];\n        require (oldSeries_.baseId == newSeries_.baseId, \"Mismatched bases in series\");\n        \n        // Change the vault series\n        vault_.seriesId = newSeriesId;\n        _tweak(vaultId, vault_);\n\n        // Change the vault balances\n        balances_ = _pour(vaultId, vault_, balances_, newSeries_, 0, art);\n\n        require(_level(vault_, balances_, newSeries_) >= 0, \"Undercollateralized\");\n        emit VaultRolled(vaultId, newSeriesId, balances_.art);\n\n        return (vault_, balances_);\n    }\n\n    // ==== Accounting ====\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function level(bytes12 vaultId) public returns (int256) {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        return _level(vault_, balances_, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function mature(bytes6 seriesId)\n        public\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        require (ratesAtMaturity[seriesId] == 0, \"Already matured\");\n        _mature(seriesId, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function _mature(bytes6 seriesId, DataTypes.Series memory series_)\n        internal\n    {\n        IOracle rateOracle = rateOracles[series_.baseId];\n        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n        ratesAtMaturity[seriesId] = rateAtMaturity;\n        emit SeriesMatured(seriesId, rateAtMaturity);\n    }\n    \n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    function accrual(bytes6 seriesId)\n        public\n        returns (uint256)\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        return _accrual(seriesId, series_);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual(bytes6 seriesId, DataTypes.Series memory series_)\n        private\n        returns (uint256 accrual_)\n    {\n        uint256 rateAtMaturity = ratesAtMaturity[seriesId];\n        if (rateAtMaturity == 0) {  // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.\n            _mature(seriesId, series_);\n        } else {\n            IOracle rateOracle = rateOracles[series_.baseId];\n            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n            accrual_ = rate.wdiv(rateAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function _level(\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_\n    )\n        internal\n        returns (int256)\n    {\n        DataTypes.SpotOracle memory spotOracle_ = spotOracles[series_.baseId][vault_.ilkId];\n        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   // Normalized to 18 decimals\n        (uint256 inkValue,) = spotOracle_.oracle.get(series_.baseId, vault_.ilkId, balances_.ink);    // ink * spot\n\n        if (uint32(block.timestamp) >= series_.maturity) {\n            uint256 accrual_ = _accrual(vault_.seriesId, series_);\n            return inkValue.i256() - uint256(balances_.art).wmul(accrual_).wmul(ratio).i256();\n        }\n\n        return inkValue.i256() - uint256(balances_.art).wmul(ratio).i256();\n    }\n}contract ChainlinkMultiOracle is IOracle, AccessControl {\n    using CastBytes32Bytes6 for bytes32;\n\n    event SourceSet(bytes6 indexed baseId, bytes6 indexed quoteId, address indexed source);\n\n    struct Source {\n        address source;\n        uint8 decimals;\n        bool inverse;\n    }\n\n    mapping(bytes6 => mapping(bytes6 => Source)) public sources;\n\n    /**\n     * @notice Set or reset an oracle source and its inverse\n     */\n    function setSource(bytes6 base, bytes6 quote, address source) public auth {\n        uint8 decimals = AggregatorV3Interface(source).decimals();\n        require (decimals <= 18, \"Unsupported decimals\");\n        sources[base][quote] = Source({\n            source: source,\n            decimals: decimals,\n            inverse: false\n        });\n        sources[quote][base] = Source({\n            source: source,\n            decimals: decimals,\n            inverse: true\n        });\n        emit SourceSet(base, quote, source);\n        emit SourceSet(quote, base, source);\n    }\n\n    /**\n     * @notice Set or reset a number of oracle sources and their inverses\n     */\n    function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) public auth {\n        require(\n            bases.length == quotes.length && \n            bases.length == sources_.length,\n            \"Mismatched inputs\"\n        );\n        for (uint256 i = 0; i < bases.length; i++) {\n            setSource(bases[i], quotes[i], sources_[i]);\n        }\n    }\n\n    /**\n     * @notice Retrieve the latest price of the price oracle.\n     * @return price\n     */\n    function _peek(bytes6 base, bytes6 quote) private view returns (uint price, uint updateTime) {\n        int rawPrice;\n        uint80 roundId;\n        uint80 answeredInRound;\n        Source memory source = sources[base][quote];\n        require (source.source != address(0), \"Source not found\");\n        (roundId, rawPrice,, updateTime, answeredInRound) = AggregatorV3Interface(source.source).latestRoundData();\n        require(rawPrice > 0, \"Chainlink price <= 0\");\n        require(updateTime != 0, \"Incomplete round\");\n        require(answeredInRound >= roundId, \"Stale price\");\n        if (source.inverse == true) {\n            price = 10 ** (source.decimals + 18) / uint(rawPrice);\n        } else {\n            price = uint(rawPrice) * 10 ** (18 - source.decimals);\n        }  \n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.\n     * @return value\n     */\n    function peek(bytes32 base, bytes32 quote, uint256 amount) public virtual override view returns (uint256 value, uint256 updateTime) {\n        uint256 price;\n        (price, updateTime) = _peek(base.b6(), quote.b6());\n        value = price * amount / 1e18;\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.. Same as `peek` for this oracle.\n     * @return value\n     */\n    function get(bytes32 base, bytes32 quote, uint256 amount) public virtual override view returns (uint256 value, uint256 updateTime) {\n        uint256 price;\n        (price, updateTime) = _peek(base.b6(), quote.b6());\n        value = price * amount / 1e18;\n    }\n}\ncontract FYToken is IFYToken, IERC3156FlashLender, AccessControl(), ERC20Permit {\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU256U128 for uint256;\n    using CastU256U32 for uint256;\n\n    event SeriesMatured(uint256 chiAtMaturity);\n    event Redeemed(address indexed from, address indexed to, uint256 amount, uint256 redeemed);\n    event OracleSet(address indexed oracle);\n\n    bytes32 constant CHI = \"chi\";\n\n    uint256 constant internal MAX_TIME_TO_MATURITY = 126144000; // seconds in four years\n    bytes32 constant internal FLASH_LOAN_RETURN = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    IOracle public oracle;                                      // Oracle for the savings rate.\n    IJoin public immutable join;                                // Source of redemption funds.\n    address public immutable override underlying;\n    bytes6 public immutable underlyingId;                             // Needed to access the oracle\n    uint256 public immutable override maturity;\n    uint256 public chiAtMaturity = type(uint256).max;           // Spot price (exchange rate) between the base and an interest accruing token at maturity \n\n    constructor(\n        bytes6 underlyingId_,\n        IOracle oracle_, // Underlying vs its interest-bearing version\n        IJoin join_,\n        uint256 maturity_,\n        string memory name,\n        string memory symbol\n    ) ERC20Permit(name, symbol, IERC20Metadata(address(IJoin(join_).asset())).decimals()) { // The join asset is this fyToken's underlying, from which we inherit the decimals\n        uint256 now_ = block.timestamp;\n        require(\n            maturity_ > now_ &&\n            maturity_ < now_ + MAX_TIME_TO_MATURITY &&\n            maturity_ < type(uint32).max,\n            \"Invalid maturity\"\n        );\n\n        underlyingId = underlyingId_;\n        join = join_;\n        maturity = maturity_;\n        underlying = address(IJoin(join_).asset());\n        setOracle(oracle_);\n    }\n\n    modifier afterMaturity() {\n        require(\n            uint32(block.timestamp) >= maturity,\n            \"Only after maturity\"\n        );\n        _;\n    }\n\n    modifier beforeMaturity() {\n        require(\n            uint32(block.timestamp) < maturity,\n            \"Only before maturity\"\n        );\n        _;\n    }\n\n    /// @dev Set the oracle parameter\n    function setOracle(IOracle oracle_)\n        public\n        auth    \n    {\n        oracle = oracle_;\n        emit OracleSet(address(oracle_));\n    }\n\n    /// @dev Mature the fyToken by recording the chi.\n    /// If called more than once, it will revert.\n    function mature()\n        external override\n        afterMaturity\n    {\n        require (chiAtMaturity == type(uint256).max, \"Already matured\");\n        _mature();\n    }\n\n    /// @dev Mature the fyToken by recording the chi.\n    function _mature() \n        private\n        returns (uint256 _chiAtMaturity)\n    {\n        (_chiAtMaturity,) = oracle.get(underlyingId, CHI, 1e18);\n        chiAtMaturity = _chiAtMaturity;\n        emit SeriesMatured(_chiAtMaturity);\n    }\n\n    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.\n    function accrual()\n        external\n        afterMaturity\n        returns (uint256)\n    {\n        return _accrual();\n    }\n\n    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual()\n        private\n        returns (uint256 accrual_)\n    {\n        if (chiAtMaturity == type(uint256).max) {  // After maturity, but chi not yet recorded. Let's record it, and accrual is then 1.\n            _mature();\n        } else {\n            (uint256 chi,) = oracle.get(underlyingId, CHI, 1e18);\n            accrual_ = chi.wdiv(chiAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Burn the fyToken after maturity for an amount that increases according to `chi`\n    function redeem(address to, uint256 amount)\n        external override\n        afterMaturity\n        returns (uint256 redeemed)\n    {\n        _burn(msg.sender, amount);\n        redeemed = amount.wmul(_accrual());\n        join.exit(to, redeemed.u128());\n        \n        emit Redeemed(msg.sender, to, amount, redeemed);\n        return amount;\n    }\n\n    /// @dev Mint fyTokens.\n    function mint(address to, uint256 amount)\n        external override\n        beforeMaturity\n        auth\n    {\n        _mint(to, amount);\n    }\n\n    /// @dev Burn fyTokens. The user needs to have either transferred the tokens to this contract, or have approved this contract to take them. \n    function burn(address from, uint256 amount)\n        external override\n        auth\n    {\n        _burn(from, amount);\n    }\n\n    /// @dev Burn fyTokens. \n    /// Any tokens locked in this contract will be burned first and subtracted from the amount to burn from the user's wallet.\n    /// This feature allows someone to transfer fyToken to this contract to enable a `burn`, potentially saving the cost of `approve` or `permit`.\n    function _burn(address from, uint256 amount)\n        internal override\n        returns (bool)\n    {\n        // First use any tokens locked in this contract\n        uint256 available = _balanceOf[address(this)];\n        if (available >= amount) {\n            unchecked { return super._burn(address(this), amount); }\n        } else {\n            if (available > 0 ) super._burn(address(this), available);\n            unchecked { _decreaseAllowance(from, amount - available); }\n            unchecked { return super._burn(from, amount - available); }\n        }\n    }\n\n    /**\n     * @dev From ERC-3156. The amount of currency available to be lended.\n     * @param token The loan currency. It must be a FYDai contract.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token)\n        external view override\n        beforeMaturity\n        returns (uint256)\n    {\n        return token == address(this) ? type(uint256).max - _totalSupply : 0;\n    }\n\n    /**\n     * @dev From ERC-3156. The fee to be charged for a given loan.\n     * @param token The loan currency. It must be a FYDai.\n     * param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256)\n        external view override\n        beforeMaturity\n        returns (uint256)\n    {\n        require(token == address(this), \"Unsupported currency\");\n        return 0;\n    }\n\n    /**\n     * @dev From ERC-3156. Loan `amount` fyDai to `receiver`, which needs to return them plus fee to this contract within the same transaction.\n     * Note that if the initiator and the borrower are the same address, no approval is needed for this contract to take the principal + fee from the borrower.\n     * If the borrower transfers the principal + fee to this contract, they will be burnt here instead of pulled from the borrower.\n     * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n     * @param token The loan currency. Must be a fyDai contract.\n     * @param amount The amount of tokens lent.\n     * @param data A data parameter to be passed on to the `receiver` for any custom use.\n     */\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes memory data)\n        external override\n        beforeMaturity\n        returns(bool)\n    {\n        require(token == address(this), \"Unsupported currency\");\n        _mint(address(receiver), amount);\n        require(receiver.onFlashLoan(msg.sender, token, amount, 0, data) == FLASH_LOAN_RETURN, \"Non-compliant borrower\");\n        _burn(address(receiver), amount);\n        return true;\n    }\n}\nabstract contract ERC20Permit is ERC20, IERC2612 {\n    mapping (address => uint256) public override nonces;\n\n    bytes32 public immutable PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    uint256 public immutable deploymentChainId;\n\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_, decimals_) {\n        uint256 chainId;\n        assembly {chainId := chainid()}\n        deploymentChainId = chainId;\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(chainId);\n    }\n\n    /// @dev Calculate the DOMAIN_SEPARATOR.\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(version())),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    /// @dev Return the DOMAIN_SEPARATOR.\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        uint256 chainId;\n        assembly {chainId := chainid()}\n        return chainId == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\n    }\n\n    /// @dev Setting the version as a function so that it can be overriden\n    function version() public pure virtual returns(string memory) { return \"1\"; }\n\n    /**\n     * @dev See {IERC2612-permit}.\n     *\n     * In cases where the free option is not a concern, deadline can simply be\n     * set to uint(-1), so it should be seen as an optional parameter\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external virtual override {\n        require(deadline >= block.timestamp, \"ERC20Permit: expired deadline\");\n\n        uint256 chainId;\n        assembly {chainId := chainid()}\n\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                PERMIT_TYPEHASH,\n                owner,\n                spender,\n                amount,\n                nonces[owner]++,\n                deadline\n            )\n        );\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                chainId == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId),\n                hashStruct\n            )\n        );\n\n        address signer = ecrecover(hash, v, r, s);\n        require(\n            signer != address(0) && signer == owner,\n            \"ERC20Permit: invalid signature\"\n        );\n\n        _setAllowance(owner, spender, amount);\n    }\n}\ncontract JoinFactory is IJoinFactory {\n  /// Pre-hashing the bytecode allows calculateJoinAddress to be cheaper, and\n  /// makes client-side address calculation easier\n  bytes32 public constant override JOIN_BYTECODE_HASH = keccak256(type(Join).creationCode);\n\n  address private _nextAsset;\n\n  /// @dev Returns true if `account` is a contract.\n  function isContract(address account) internal view returns (bool) {\n      // This method relies on extcodesize, which returns 0 for contracts in\n      // construction, since the code is only stored at the end of the\n      // constructor execution.\n\n      uint256 size;\n      // solhint-disable-next-line no-inline-assembly\n      assembly { size := extcodesize(account) }\n      return size > 0;\n  }\n\n  /// @dev Calculate the deterministic addreess of a join, based on the asset token.\n  /// @param asset Address of the asset token.\n  /// @return The calculated join address.\n  function calculateJoinAddress(address asset) external view override returns (address) {\n    return _calculateJoinAddress(asset);\n  }\n\n  /// @dev Create2 calculation\n  function _calculateJoinAddress(address asset)\n    private view returns (address calculatedAddress)\n  {\n    calculatedAddress = address(uint160(uint256(keccak256(abi.encodePacked(\n      bytes1(0xff),\n      address(this),\n      keccak256(abi.encodePacked(asset)),\n      JOIN_BYTECODE_HASH\n    )))));\n  }\n\n  /// @dev Calculate the address of a join, and return address(0) if not deployed.\n  /// @param asset Address of the asset token.\n  /// @return join The deployed join address.\n  function getJoin(address asset) external view override returns (address join) {\n    join = _calculateJoinAddress(asset);\n\n    if(!isContract(join)) {\n      join = address(0);\n    }\n  }\n\n  /// @dev Deploys a new join.\n  /// The asset address is written to a temporary storage slot to allow for simpler\n  /// address calculation, while still allowing the Join contract to store the values as\n  /// immutable.\n  /// @param asset Address of the asset token.\n  /// @return join The join address.\n  function createJoin(address asset) external override returns (address) {\n    _nextAsset = asset;\n    Join join = new Join{salt: keccak256(abi.encodePacked(asset))}();\n    _nextAsset = address(0);\n\n    join.grantRole(join.ROOT(), msg.sender);\n    join.renounceRole(join.ROOT(), address(this));\n    \n    emit JoinCreated(asset, address(join));\n\n    return address(join);\n  }\n\n  /// @dev Only used by the Join constructor.\n  /// @return The address token for the currently-constructing join.\n  function nextAsset() external view override returns (address) {\n    return _nextAsset;\n  }\n}contract Wand is AccessControl {\n\n    bytes4 public constant JOIN = bytes4(keccak256(\"join(address,uint128)\"));\n    bytes4 public constant EXIT = bytes4(keccak256(\"exit(address,uint128)\"));\n    bytes4 public constant MINT = bytes4(keccak256(\"mint(address,uint256)\"));\n    bytes4 public constant BURN = bytes4(keccak256(\"burn(address,uint256)\"));\n    \n    bytes6 public constant CHI = \"chi\";\n    bytes6 public constant RATE = \"rate\";\n\n    ICauldronGov public immutable cauldron;\n    ILadleGov public immutable ladle;\n    IPoolFactory public immutable poolFactory;\n    IJoinFactory public immutable joinFactory;\n\n    constructor (ICauldronGov cauldron_, ILadleGov ladle_, IPoolFactory poolFactory_, IJoinFactory joinFactory_) {\n        cauldron = cauldron_;\n        ladle = ladle_;\n        poolFactory = poolFactory_;\n        joinFactory = joinFactory_;\n    }\n\n    /// @dev Add an existing asset to the protocol, meaning:\n    ///  - Add the asset to the cauldron\n    ///  - Deploy a new Join, and integrate it with the Ladle\n    ///  - If the asset is a base, integrate its rate source\n    ///  - If the asset is a base, integrate a spot source and set a debt ceiling for any provided ilks\n    function addAsset(\n        bytes6 assetId,\n        address asset\n    ) public auth {\n        // Add asset to cauldron, deploy new Join, and add it to the ladle\n        require (address(asset) != address(0), \"Asset required\");\n        cauldron.addAsset(assetId, asset);\n        AccessControl join = AccessControl(joinFactory.createJoin(asset));  // We need the access control methods of Join\n        bytes4[] memory sigs = new bytes4[](2);\n        sigs[0] = JOIN;\n        sigs[1] = EXIT;\n        join.grantRoles(sigs, address(ladle));\n        join.grantRole(join.ROOT(), msg.sender);\n        // join.renounceRole(join.ROOT(), address(this));  // If Wand gives up ownership it can't create fyToken\n        ladle.addJoin(assetId, address(join));\n    }\n\n    /// @dev Make a base asset out of a generic asset, by adding rate and chi oracles.\n    /// This assumes CompoundMultiOracles, which deliver both rate and chi.\n    function makeBase(bytes6 assetId, IMultiOracleGov oracle, address rateSource, address chiSource) public auth {\n        require (address(oracle) != address(0), \"Oracle required\");\n        require (rateSource != address(0), \"Rate source required\");\n        require (chiSource != address(0), \"Chi source required\");\n\n        oracle.setSource(assetId, RATE, rateSource);\n        oracle.setSource(assetId, CHI, chiSource);\n        cauldron.setRateOracle(assetId, IOracle(address(oracle))); // TODO: Consider adding a registry of chi oracles in cauldron as well\n    }\n\n    /// @dev Make an ilk asset out of a generic asset, by adding a spot oracle against a base asset, collateralization ratio, and debt ceiling.\n    function makeIlk(bytes6 baseId, bytes6 ilkId, IMultiOracleGov oracle, address spotSource, uint32 ratio, uint96 max, uint24 min, uint8 dec) public auth {\n        oracle.setSource(baseId, ilkId, spotSource);\n        cauldron.setSpotOracle(baseId, ilkId, IOracle(address(oracle)), ratio);\n        cauldron.setDebtLimits(baseId, ilkId, max, min, dec);\n    }\n\n    /// @dev Add an existing series to the protocol, by deploying a FYToken, and registering it in the cauldron with the approved ilks\n    /// This must be followed by a call to addPool\n    function addSeries(\n        bytes6 seriesId,\n        bytes6 baseId,\n        uint32 maturity,\n        bytes6[] memory ilkIds,\n        string memory name,\n        string memory symbol\n    ) public auth {\n        address base = cauldron.assets(baseId);\n        require(base != address(0), \"Base not found\");\n\n        IJoin baseJoin = ladle.joins(baseId);\n        require(address(baseJoin) != address(0), \"Join not found\");\n\n        IOracle oracle = cauldron.rateOracles(baseId);\n        require(address(oracle) != address(0), \"Chi oracle not found\");\n\n        FYToken fyToken = new FYToken(\n            baseId,\n            oracle,\n            baseJoin,\n            maturity,\n            name,     // Derive from base and maturity, perhaps\n            symbol    // Derive from base and maturity, perhaps\n        ); // TODO: Use a FYTokenFactory to make Wand deployable at 20000 runs\n\n        // Allow the fyToken to pull from the base join for redemption\n        bytes4[] memory sigs = new bytes4[](1);\n        sigs[0] = EXIT;\n        AccessControl(address(baseJoin)).grantRoles(sigs, address(fyToken));\n\n        // Allow the ladle to issue and cancel fyToken\n        sigs = new bytes4[](2);\n        sigs[0] = MINT;\n        sigs[1] = BURN;\n        fyToken.grantRoles(sigs, address(ladle));\n\n        // Pass ownership of the fyToken to msg.sender\n        fyToken.grantRole(fyToken.ROOT(), msg.sender);\n        fyToken.renounceRole(fyToken.ROOT(), address(this));\n\n        // Add fyToken/series to the Cauldron and approve ilks for the series\n        cauldron.addSeries(seriesId, baseId, fyToken);\n        cauldron.addIlks(seriesId, ilkIds);\n\n        // Create the pool for the base and fyToken\n        poolFactory.createPool(base, address(fyToken));\n        IOwnable pool = IOwnable(poolFactory.calculatePoolAddress(base, address(fyToken)));\n        \n\n        // Pass ownership of pool to msg.sender\n        pool.transferOwnership(msg.sender);\n\n        // Register pool in Ladle\n        ladle.addPool(seriesId, address(pool));\n    }\n}contract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    constructor () {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), owner);\n    }\n\n    /// @dev Throws if called by any account other than the owner.\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /// @dev Transfers ownership of the contract to a new account (`newOwner`).\n    /// Can only be called by the current owner.\n    function transferOwnership(address newOwner) public onlyOwner {\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n}contract CompoundMultiOracle is IOracle, AccessControl {\n    using CastBytes32Bytes6 for bytes32;\n\n    event SourceSet(bytes6 indexed baseId, bytes6 indexed kind, address indexed source);\n\n    uint public constant SCALE_FACTOR = 1; // I think we don't need scaling for rate and chi oracles\n\n    mapping(bytes6 => mapping(bytes6 => address)) public sources;\n\n    /**\n     * @notice Set or reset one source\n     */\n    function setSource(bytes6 base, bytes6 kind, address source) public auth {\n        sources[base][kind] = source;\n        emit SourceSet(base, kind, source);\n    }\n\n    /**\n     * @notice Set or reset an oracle source\n     */\n    function setSources(bytes6[] memory bases, bytes6[] memory kinds, address[] memory sources_) public auth {\n        require(bases.length == kinds.length && kinds.length == sources_.length, \"Mismatched inputs\");\n        for (uint256 i = 0; i < bases.length; i++)\n            setSource(bases[i], kinds[i], sources_[i]);\n    }\n\n    /**\n     * @notice Retrieve the latest price of a given source.\n     * @return price\n     */\n    function _peek(bytes6 base, bytes6 kind) private view returns (uint price, uint updateTime) {\n        uint256 rawPrice;\n        address source = sources[base][kind];\n        require (source != address(0), \"Source not found\");\n\n        if (kind == \"rate\") rawPrice = CTokenInterface(source).borrowIndex();\n        else if (kind == \"chi\") rawPrice = CTokenInterface(source).exchangeRateStored();\n        else revert(\"Unknown oracle type\");\n\n        require(rawPrice > 0, \"Compound price is zero\");\n\n        price = rawPrice * SCALE_FACTOR;\n        updateTime = block.timestamp;\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.\n     * @return value\n     */\n    function peek(bytes32 base, bytes32 kind, uint256 amount) public virtual override view returns (uint256 value, uint256 updateTime) {\n        uint256 price;\n        (price, updateTime) = _peek(base.b6(), kind.b6());\n        value = price * amount / 1e18;\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price. Same as `peek` for this oracle.\n     * @return value\n     */\n    function get(bytes32 base, bytes32 kind, uint256 amount) public virtual override view returns (uint256 value, uint256 updateTime) {\n        uint256 price;\n        (price, updateTime) = _peek(base.b6(), kind.b6());\n        value = price * amount / 1e18;\n    }\n}contract LadleStorage {\n\n    enum Operation {\n        BUILD,               // 0\n        TWEAK,               // 1\n        GIVE,                // 2\n        DESTROY,             // 3\n        STIR,                // 4\n        POUR,                // 5\n        SERVE,               // 6\n        ROLL,                // 7\n        CLOSE,               // 8\n        REPAY,               // 9\n        REPAY_VAULT,         // 10\n        REPAY_LADLE,         // 11\n        RETRIEVE,            // 12\n        FORWARD_PERMIT,      // 13\n        FORWARD_DAI_PERMIT,  // 14\n        JOIN_ETHER,          // 15\n        EXIT_ETHER,          // 16\n        TRANSFER_TO_POOL,    // 17\n        ROUTE,               // 18\n        TRANSFER_TO_FYTOKEN, // 19\n        REDEEM,              // 20\n        MODULE               // 21\n    }\n\n    ICauldron public immutable cauldron;\n    uint256 public borrowingFee;\n\n    mapping (bytes6 => IJoin)                   public joins;            // Join contracts available to manage assets. The same Join can serve multiple assets (ETH-A, ETH-B, etc...)\n    mapping (bytes6 => IPool)                   public pools;            // Pool contracts available to manage series. 12 bytes still free.\n    mapping (address => bool)                   public modules;          // Trusted contracts to execute anything on.\n\n    event JoinAdded(bytes6 indexed assetId, address indexed join);\n    event PoolAdded(bytes6 indexed seriesId, address indexed pool);\n    event ModuleSet(address indexed module, bool indexed set);\n    event FeeSet(uint256 fee);\n\n    constructor (ICauldron cauldron_) {\n        cauldron = cauldron_;\n    }\n}contract ERC20 is IERC20Metadata {\n    uint256                                           internal  _totalSupply;\n    mapping (address => uint256)                      internal  _balanceOf;\n    mapping (address => mapping (address => uint256)) internal  _allowance;\n    string                                            public override name = \"???\";\n    string                                            public override symbol = \"???\";\n    uint8                                             public override decimals = 18;\n\n    /**\n     *  @dev Sets the values for {name}, {symbol} and {decimals}.\n     */\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() external view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address guy) external view virtual override returns (uint256) {\n        return _balanceOf[guy];\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) external view virtual override returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     */\n    function approve(address spender, uint wad) external virtual override returns (bool) {\n        return _setAllowance(msg.sender, spender, wad);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - the caller must have a balance of at least `wad`.\n     */\n    function transfer(address dst, uint wad) external virtual override returns (bool) {\n        return _transfer(msg.sender, dst, wad);\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `src` must have a balance of at least `wad`.\n     * - the caller is not `src`, it must have allowance for ``src``'s tokens of at least\n     * `wad`.\n     */\n    /// if_succeeds {:msg \"TransferFrom - decrease allowance\"} msg.sender != src ==> old(_allowance[src][msg.sender]) >= wad;\n    function transferFrom(address src, address dst, uint wad) external virtual override returns (bool) {\n        _decreaseAllowance(src, wad);\n\n        return _transfer(src, dst, wad);\n    }\n\n    /**\n     * @dev Moves tokens `wad` from `src` to `dst`.\n     * \n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `src` must have a balance of at least `amount`.\n     */\n    /// if_succeeds {:msg \"Transfer - src decrease\"} old(_balanceOf[src]) >= _balanceOf[src];\n    /// if_succeeds {:msg \"Transfer - dst increase\"} _balanceOf[dst] >= old(_balanceOf[dst]);\n    /// if_succeeds {:msg \"Transfer - supply\"} old(_balanceOf[src]) + old(_balanceOf[dst]) == _balanceOf[src] + _balanceOf[dst];\n    function _transfer(address src, address dst, uint wad) internal virtual returns (bool) {\n        require(_balanceOf[src] >= wad, \"ERC20: Insufficient balance\");\n        unchecked { _balanceOf[src] = _balanceOf[src] - wad; }\n        _balanceOf[dst] = _balanceOf[dst] + wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    /**\n     * @dev Sets the allowance granted to `spender` by `owner`.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     */\n    function _setAllowance(address owner, address spender, uint wad) internal virtual returns (bool) {\n        _allowance[owner][spender] = wad;\n        emit Approval(owner, spender, wad);\n\n        return true;\n    }\n\n    /**\n     * @dev Decreases the allowance granted to the caller by `src`, unless src == msg.sender or _allowance[src][msg.sender] == MAX\n     *\n     * Emits an {Approval} event indicating the updated allowance, if the allowance is updated.\n     *\n     * Requirements:\n     *\n     * - `spender` must have allowance for the caller of at least\n     * `wad`, unless src == msg.sender\n     */\n    /// if_succeeds {:msg \"Decrease allowance - underflow\"} old(_allowance[src][msg.sender]) <= _allowance[src][msg.sender];\n    function _decreaseAllowance(address src, uint wad) internal virtual returns (bool) {\n        if (src != msg.sender) {\n            uint256 allowed = _allowance[src][msg.sender];\n            if (allowed != type(uint).max) {\n                require(allowed >= wad, \"ERC20: Insufficient approval\");\n                unchecked { _setAllowance(src, msg.sender, allowed - wad); }\n            }\n        }\n\n        return true;\n    }\n\n    /** @dev Creates `wad` tokens and assigns them to `dst`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     */\n    /// if_succeeds {:msg \"Mint - balance overflow\"} old(_balanceOf[dst]) >= _balanceOf[dst];\n    /// if_succeeds {:msg \"Mint - supply overflow\"} old(_totalSupply) >= _totalSupply;\n    function _mint(address dst, uint wad) internal virtual returns (bool) {\n        _balanceOf[dst] = _balanceOf[dst] + wad;\n        _totalSupply = _totalSupply + wad;\n        emit Transfer(address(0), dst, wad);\n\n        return true;\n    }\n\n    /**\n     * @dev Destroys `wad` tokens from `src`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `src` must have at least `wad` tokens.\n     */\n    /// if_succeeds {:msg \"Burn - balance underflow\"} old(_balanceOf[src]) <= _balanceOf[src];\n    /// if_succeeds {:msg \"Burn - supply underflow\"} old(_totalSupply) <= _totalSupply;\n    function _burn(address src, uint wad) internal virtual returns (bool) {\n        unchecked {\n            require(_balanceOf[src] >= wad, \"ERC20: Insufficient balance\");\n            _balanceOf[src] = _balanceOf[src] - wad;\n            _totalSupply = _totalSupply - wad;\n            emit Transfer(src, address(0), wad);\n        }\n\n        return true;\n    }\n}contract PoolRouter {\n    using TransferHelper for IERC20;\n    using TransferHelper for address payable;\n\n    IPoolFactory public immutable factory;\n    IWETH9 public immutable weth;\n\n    constructor(IPoolFactory factory_, IWETH9 weth_) {\n        factory = factory_;\n        weth = weth_;\n    }\n\n    struct PoolAddresses {\n        address base;\n        address fyToken;\n        address pool;\n    }\n\n    /// @dev Submit a series of calls for execution\n    /// The `bases` and `fyTokens` parameters define the pools that will be target for operations\n    /// Each trio of `target`, `operation` and `data` define one call:\n    ///  - `target` is an index in the `bases` and `fyTokens` arrays, from which contract addresses the target will be determined.\n    ///  - `operation` is a numerical identifier for the call to be executed, from the enum `Operation`\n    ///  - `data` is an abi-encoded group of parameters, to be consumed by the function encoded in `operation`.\n    function batch(\n        PoolDataTypes.Operation[] calldata operations,\n        bytes[] calldata data\n    ) external payable {\n        require(operations.length == data.length, \"Mismatched operation data\");\n        PoolAddresses memory cache;\n\n        for (uint256 i = 0; i < operations.length; i += 1) {\n            PoolDataTypes.Operation operation = operations[i];\n            \n            if (operation == PoolDataTypes.Operation.ROUTE) {\n                (address base, address fyToken, bytes memory poolcall) = abi.decode(data[i], (address, address, bytes));\n                if (cache.base != base || cache.fyToken != fyToken) cache = PoolAddresses(base, fyToken, findPool(base, fyToken));\n                _route(cache, poolcall);\n\n            } else if (operation == PoolDataTypes.Operation.TRANSFER_TO_POOL) {\n                (address base, address fyToken, address token, uint128 wad) = abi.decode(data[i], (address, address, address, uint128));\n                if (cache.base != base || cache.fyToken != fyToken) cache = PoolAddresses(base, fyToken, findPool(base, fyToken));\n                _transferToPool(cache, token, wad);\n\n            } else if (operation == PoolDataTypes.Operation.FORWARD_PERMIT) {\n                (address base, address fyToken, address token, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) = \n                    abi.decode(data[i], (address, address, address, address, uint256, uint256, uint8, bytes32, bytes32));\n                if (cache.base != base || cache.fyToken != fyToken) cache = PoolAddresses(base, fyToken, findPool(base, fyToken));\n                _forwardPermit(cache, token, spender, amount, deadline, v, r, s);\n\n            } else if (operation == PoolDataTypes.Operation.FORWARD_DAI_PERMIT) {\n                        (address base, address fyToken, address spender, uint256 nonce, uint256 deadline, bool allowed, uint8 v, bytes32 r, bytes32 s) = \n                    abi.decode(data[i], (address, address, address, uint256, uint256, bool, uint8, bytes32, bytes32));\n                if (cache.base != base || cache.fyToken != fyToken) cache = PoolAddresses(base, fyToken, findPool(base, fyToken));\n                _forwardDaiPermit(cache, spender, nonce, deadline, allowed, v, r, s);\n\n            } else if (operation == PoolDataTypes.Operation.JOIN_ETHER) {\n                (address base, address fyToken) = abi.decode(data[i], (address, address));\n                if (cache.base != base || cache.fyToken != fyToken) cache = PoolAddresses(base, fyToken, findPool(base, fyToken));\n                _joinEther(cache.pool);\n\n            } else if (operation == PoolDataTypes.Operation.EXIT_ETHER) {\n                (address to) = abi.decode(data[i], (address));\n                _exitEther(to);\n\n            } else {\n                revert(\"Invalid operation\");\n            }\n        }\n    }\n\n    /// @dev Return which pool contract matches the base and fyToken\n    function findPool(address base, address fyToken)\n        private view returns (address pool)\n    {\n        pool = factory.getPool(base, fyToken);\n        require (pool != address(0), \"Pool not found\");\n    }\n\n    /// @dev Allow users to trigger a token transfer to a pool, to be used with multicall\n    function transferToPool(address base, address fyToken, address token, uint128 wad)\n        external payable\n        returns (bool)\n    {\n        return _transferToPool(\n            PoolAddresses(base, fyToken, findPool(base, fyToken)),\n            token, wad\n        );\n    }\n\n    /// @dev Allow users to trigger a token transfer to a pool, to be used with batch\n    function _transferToPool(PoolAddresses memory addresses, address token, uint128 wad)\n        private\n        returns (bool)\n    {\n        require(token == addresses.base || token == addresses.fyToken || token == addresses.pool, \"Mismatched token\");\n        IERC20(token).safeTransferFrom(msg.sender, address(addresses.pool), wad);\n        return true;\n    }\n\n    /// @dev Allow users to route calls to a pool, to be used with batch\n    function _route(PoolAddresses memory addresses, bytes memory data)\n        private\n        returns (bool success, bytes memory result)\n    {\n        (success, result) = addresses.pool.call(data);\n        if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n    }\n\n    // ---- Permit management ----\n\n    /// @dev Execute an ERC2612 permit for the selected asset or fyToken, to be used with batch\n    function _forwardPermit(PoolAddresses memory addresses, address token, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        private\n    {\n        require(token == addresses.base || token == addresses.fyToken || token == addresses.pool, \"Mismatched token\");\n        IERC2612(token).permit(msg.sender, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Execute a Dai-style permit for the selected asset or fyToken, to be used with batch\n    function _forwardDaiPermit(PoolAddresses memory addresses, address spender, uint256 nonce, uint256 deadline, bool allowed, uint8 v, bytes32 r, bytes32 s)\n        private\n    {\n        // Only the base token would ever be Dai\n        DaiAbstract(addresses.base).permit(msg.sender, spender, nonce, deadline, allowed, v, r, s);\n    }\n\n    // ---- Ether management ----\n\n    /// @dev The WETH9 contract will send ether to the PoolRouter on `weth.withdraw` using this function.\n    receive() external payable {\n        require (msg.sender == address(weth), \"Only Weth contract allowed\");\n    }\n\n    /// @dev Accept Ether, wrap it and forward it to the to a pool\n    function _joinEther(address pool)\n        private\n        returns (uint256 ethTransferred)\n    {\n        ethTransferred = address(this).balance;\n\n        weth.deposit{ value: ethTransferred }();   // TODO: Test gas savings using WETH10 `depositTo`\n        IERC20(weth).safeTransfer(pool, ethTransferred);\n    }\n\n    /// @dev Unwrap Wrapped Ether held by this Router, and send the Ether\n    function _exitEther(address to)\n        private\n        returns (uint256 ethTransferred)\n    {\n        ethTransferred = weth.balanceOf(address(this));\n\n        weth.withdraw(ethTransferred);   // TODO: Test gas savings using WETH10 `withdrawTo`\n        payable(to).safeTransferETH(ethTransferred);\n    }\n}contract Witch is AccessControl() {\n    using WMul for uint256;\n    using WDiv for uint256;\n    using WDivUp for uint256;\n    using CastU256U128 for uint256;\n\n    event AuctionTimeSet(uint128 indexed auctionTime);\n    event InitialProportionSet(uint128 indexed initialProportion);\n    event Bought(bytes12 indexed vaultId, address indexed buyer, uint256 ink, uint256 art);\n  \n    uint128 public auctionTime = 4 * 60 * 60; // Time that auctions take to go to minimal price and stay there.\n    uint128 public initialProportion = 5e17;  // Proportion of collateral that is sold at auction start.\n\n    ICauldron immutable public cauldron;\n    ILadle immutable public ladle;\n    mapping(bytes12 => address) public vaultOwners;\n\n    constructor (ICauldron cauldron_, ILadle ladle_) {\n        cauldron = cauldron_;\n        ladle = ladle_;\n    }\n\n    /// @dev Set the auction time to calculate liquidation prices\n    function setAuctionTime(uint128 auctionTime_) public auth {\n        auctionTime = auctionTime_;\n        emit AuctionTimeSet(auctionTime_);\n    }\n\n    /// @dev Set the proportion of the collateral that will be sold at auction start\n    function setInitialProportion(uint128 initialProportion_) public auth {\n        require (initialProportion_ <= 1e18, \"Only at or under 100%\");\n        initialProportion = initialProportion_;\n        emit InitialProportionSet(initialProportion_);\n    }\n\n    /// @dev Put an undercollateralized vault up for liquidation.\n    function grab(bytes12 vaultId) public {\n        DataTypes.Vault memory vault = cauldron.vaults(vaultId);\n        vaultOwners[vaultId] = vault.owner;\n        cauldron.grab(vaultId, address(this));\n    }\n\n    /// @dev Buy an amount of collateral off a vault in liquidation, paying at most `max` underlying.\n    function buy(bytes12 vaultId, uint128 art, uint128 min) public {\n        DataTypes.Balances memory balances_ = cauldron.balances(vaultId);\n\n        require (balances_.art > 0, \"Nothing to buy\");                                      // Cheapest way of failing gracefully if given a non existing vault\n        uint256 elapsed = uint32(block.timestamp) - cauldron.auctions(vaultId);           // Auctions will malfunction on the 7th of February 2106, at 06:28:16 GMT, we should replace this contract before then.\n        uint256 price;\n        {\n            // Price of a collateral unit, in underlying, at the present moment, for a given vault\n            //\n            //                ink                     min(auction, elapsed)\n            // price = 1 / (------- * (p + (1 - p) * -----------------------))\n            //                art                          auction\n            (uint256 auctionTime_, uint256 initialProportion_) = (auctionTime, initialProportion);\n            uint256 term1 = uint256(balances_.ink).wdiv(balances_.art);\n            uint256 dividend2 = auctionTime_ < elapsed ? auctionTime_ : elapsed;\n            uint256 divisor2 = auctionTime_;\n            uint256 term2 = initialProportion_ + (1e18 - initialProportion_).wmul(dividend2.wdiv(divisor2));\n            price = uint256(1e18).wdiv(term1.wmul(term2));\n        }\n        uint256 ink = uint256(art).wdivup(price);                                                    // Calculate collateral to sell. Using divdrup stops rounding from leaving 1 stray wei in vaults.\n        require (ink >= min, \"Not enough bought\");\n\n        ladle.settle(vaultId, msg.sender, ink.u128(), art);                                        // Move the assets\n        if (balances_.art - art == 0) {                                                             // If there is no debt left, return the vault with the collateral to the owner\n            cauldron.give(vaultId, vaultOwners[vaultId]);\n            delete vaultOwners[vaultId];\n        }\n\n        emit Bought(vaultId, msg.sender, ink, art);\n    }\n}contract Ladle is LadleStorage, AccessControl() {\n    using WMul for uint256;\n    using CastU256U128 for uint256;\n    using CastU128I128 for uint128;\n    using TransferHelper for IERC20;\n    using TransferHelper for address payable;\n\n    IWETH9 public immutable weth;\n\n    constructor (ICauldron cauldron, IWETH9 weth_) LadleStorage(cauldron) {\n        weth = weth_;\n    }\n\n    // ---- Data sourcing ----\n    /// @dev Obtains a vault by vaultId from the Cauldron, and verifies that msg.sender is the owner\n    function getOwnedVault(bytes12 vaultId)\n        internal view returns(DataTypes.Vault memory vault)\n    {\n        vault = cauldron.vaults(vaultId);\n        require (vault.owner == msg.sender, \"Only vault owner\");\n    }\n\n    /// @dev Obtains a series by seriesId from the Cauldron, and verifies that it exists\n    function getSeries(bytes6 seriesId)\n        internal view returns(DataTypes.Series memory series)\n    {\n        series = cauldron.series(seriesId);\n        require (series.fyToken != IFYToken(address(0)), \"Series not found\");\n    }\n\n    /// @dev Obtains a join by assetId, and verifies that it exists\n    function getJoin(bytes6 assetId)\n        internal view returns(IJoin join)\n    {\n        join = joins[assetId];\n        require (join != IJoin(address(0)), \"Join not found\");\n    }\n\n    /// @dev Obtains a pool by seriesId, and verifies that it exists\n    function getPool(bytes6 seriesId)\n        internal view returns(IPool pool)\n    {\n        pool = pools[seriesId];\n        require (pool != IPool(address(0)), \"Pool not found\");\n    }\n\n    // ---- Administration ----\n\n    /// @dev Add a new Join for an Asset, or replace an existing one for a new one.\n    /// There can be only one Join per Asset. Until a Join is added, no tokens of that Asset can be posted or withdrawn.\n    function addJoin(bytes6 assetId, IJoin join)\n        external\n        auth\n    {\n        address asset = cauldron.assets(assetId);\n        require (asset != address(0), \"Asset not found\");\n        require (join.asset() == asset, \"Mismatched asset and join\");\n        joins[assetId] = join;\n        emit JoinAdded(assetId, address(join));\n    }\n\n    /// @dev Add a new Pool for a Series, or replace an existing one for a new one.\n    /// There can be only one Pool per Series. Until a Pool is added, it is not possible to borrow Base.\n    function addPool(bytes6 seriesId, IPool pool)\n        external\n        auth\n    {\n        IFYToken fyToken = getSeries(seriesId).fyToken;\n        require (fyToken == pool.fyToken(), \"Mismatched pool fyToken and series\");\n        require (fyToken.underlying() == address(pool.base()), \"Mismatched pool base and series\");\n        pools[seriesId] = pool;\n        emit PoolAdded(seriesId, address(pool));\n    }\n\n    /// @dev Add or remove a module.\n    function setModule(address module, bool set)\n        external\n        auth\n    {\n        modules[module] = set;\n        emit ModuleSet(module, set);\n    }\n\n    /// @dev Set the fee parameter\n    function setFee(uint256 fee)\n        public\n        auth    \n    {\n        borrowingFee = fee;\n        emit FeeSet(fee);\n    }\n\n    // ---- Batching ----\n\n\n    /// @dev Submit a series of calls for execution.\n    /// Unlike `batch`, this function calls private functions, saving a CALL per function.\n    /// It also caches the vault, which is useful in `build` + `pour` and `build` + `serve` combinations.\n    function batch(\n        Operation[] calldata operations,\n        bytes[] calldata data\n    ) external payable {\n        require(operations.length == data.length, \"Mismatched operation data\");\n        bytes12 cachedId;\n        DataTypes.Vault memory vault;\n\n        // Execute all operations in the batch. Conditionals ordered by expected frequency.\n        for (uint256 i = 0; i < operations.length; i += 1) {\n\n            Operation operation = operations[i];\n\n            if (operation == Operation.BUILD) {\n                (bytes12 vaultId, bytes6 seriesId, bytes6 ilkId) = abi.decode(data[i], (bytes12, bytes6, bytes6));\n                (cachedId, vault) = (vaultId, _build(vaultId, seriesId, ilkId));   // Cache the vault that was just built\n            \n            } else if (operation == Operation.FORWARD_PERMIT) {\n                (bytes6 id, bool isAsset, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) =\n                    abi.decode(data[i], (bytes6, bool, address, uint256, uint256, uint8, bytes32, bytes32));\n                _forwardPermit(id, isAsset, spender, amount, deadline, v, r, s);\n            \n            } else if (operation == Operation.JOIN_ETHER) {\n                (bytes6 etherId) = abi.decode(data[i], (bytes6));\n                _joinEther(etherId);\n            \n            } else if (operation == Operation.POUR) {\n                (bytes12 vaultId, address to, int128 ink, int128 art) = abi.decode(data[i], (bytes12, address, int128, int128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _pour(vaultId, vault, to, ink, art);\n            \n            } else if (operation == Operation.SERVE) {\n                (bytes12 vaultId, address to, uint128 ink, uint128 base, uint128 max) = abi.decode(data[i], (bytes12, address, uint128, uint128, uint128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _serve(vaultId, vault, to, ink, base, max);\n\n            } else if (operation == Operation.ROLL) {\n                (bytes12 vaultId, bytes6 newSeriesId, uint8 loan, uint128 max) = abi.decode(data[i], (bytes12, bytes6, uint8, uint128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                (vault,) = _roll(vaultId, vault, newSeriesId, loan, max);\n            \n            } else if (operation == Operation.FORWARD_DAI_PERMIT) {\n                (bytes6 id, bool isAsset, address spender, uint256 nonce, uint256 deadline, bool allowed, uint8 v, bytes32 r, bytes32 s) =\n                    abi.decode(data[i], (bytes6, bool, address, uint256, uint256, bool, uint8, bytes32, bytes32));\n                _forwardDaiPermit(id, isAsset, spender, nonce, deadline, allowed, v, r, s);\n            \n            } else if (operation == Operation.TRANSFER_TO_POOL) {\n                (bytes6 seriesId, bool base, uint128 wad) =\n                    abi.decode(data[i], (bytes6, bool, uint128));\n                IPool pool = getPool(seriesId);\n                _transferToPool(pool, base, wad);\n            \n            } else if (operation == Operation.ROUTE) {\n                (bytes6 seriesId, bytes memory poolCall) =\n                    abi.decode(data[i], (bytes6, bytes));\n                IPool pool = getPool(seriesId);\n                _route(pool, poolCall);\n            \n            } else if (operation == Operation.EXIT_ETHER) {\n                (address to) = abi.decode(data[i], (address));\n                _exitEther(payable(to));\n            \n            } else if (operation == Operation.CLOSE) {\n                (bytes12 vaultId, address to, int128 ink, int128 art) = abi.decode(data[i], (bytes12, address, int128, int128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _close(vaultId, vault, to, ink, art);\n            \n            } else if (operation == Operation.REPAY) {\n                (bytes12 vaultId, address to, int128 ink, uint128 min) = abi.decode(data[i], (bytes12, address, int128, uint128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _repay(vaultId, vault, to, ink, min);\n            \n            } else if (operation == Operation.REPAY_VAULT) {\n                (bytes12 vaultId, address to, int128 ink, uint128 max) = abi.decode(data[i], (bytes12, address, int128, uint128));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _repayVault(vaultId, vault, to, ink, max);\n\n            } else if (operation == Operation.REPAY_LADLE) {\n                (bytes12 vaultId) = abi.decode(data[i], (bytes12));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _repayLadle(vaultId, vault);\n\n            } else if (operation == Operation.RETRIEVE) {\n                (bytes6 assetId, bool isAsset, address to) = abi.decode(data[i], (bytes6, bool, address));\n                _retrieve(assetId, isAsset, to);\n\n            } else if (operation == Operation.TRANSFER_TO_FYTOKEN) {\n                (bytes6 seriesId, uint256 amount) = abi.decode(data[i], (bytes6, uint256));\n                IFYToken fyToken = getSeries(seriesId).fyToken;\n                _transferToFYToken(fyToken, amount);\n            \n            } else if (operation == Operation.REDEEM) {\n                (bytes6 seriesId, address to, uint256 amount) = abi.decode(data[i], (bytes6, address, uint256));\n                IFYToken fyToken = getSeries(seriesId).fyToken;\n                _redeem(fyToken, to, amount);\n            \n            } else if (operation == Operation.STIR) {\n                (bytes12 from, bytes12 to, uint128 ink, uint128 art) = abi.decode(data[i], (bytes12, bytes12, uint128, uint128));\n                _stir(from, to, ink, art);  // Too complicated to use caching here\n            \n            } else if (operation == Operation.TWEAK) {\n                (bytes12 vaultId, bytes6 seriesId, bytes6 ilkId) = abi.decode(data[i], (bytes12, bytes6, bytes6));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                vault = _tweak(vaultId, seriesId, ilkId);\n\n            } else if (operation == Operation.GIVE) {\n                (bytes12 vaultId, address to) = abi.decode(data[i], (bytes12, address));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                vault = _give(vaultId, to);\n                delete vault;   // Clear the cache, since the vault doesn't necessarily belong to msg.sender anymore\n                cachedId = bytes12(0);\n\n            } else if (operation == Operation.DESTROY) {\n                (bytes12 vaultId) = abi.decode(data[i], (bytes12));\n                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n                _destroy(vaultId);\n                delete vault;   // Clear the cache\n                cachedId = bytes12(0);\n            \n            } else if (operation == Operation.MODULE) {\n                (address module, bytes memory moduleCall) = abi.decode(data[i], (address, bytes));\n                _moduleCall(module, moduleCall);\n            \n            }\n        }\n    }\n\n    // ---- Vault management ----\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function _build(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        private\n        returns(DataTypes.Vault memory vault)\n    {\n        return cauldron.build(msg.sender, vaultId, seriesId, ilkId);\n    }\n\n    /// @dev Change a vault series or collateral.\n    function _tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        private\n        returns(DataTypes.Vault memory vault)\n    {\n        // tweak checks that the series and the collateral both exist and that the collateral is approved for the series\n        return cauldron.tweak(vaultId, seriesId, ilkId);\n    }\n\n    /// @dev Give a vault to another user.\n    function _give(bytes12 vaultId, address receiver)\n        private\n        returns(DataTypes.Vault memory vault)\n    {\n        return cauldron.give(vaultId, receiver);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function _destroy(bytes12 vaultId)\n        private\n    {\n        cauldron.destroy(vaultId);\n    }\n\n    // ---- Asset and debt management ----\n\n    /// @dev Move collateral and debt between vaults.\n    function _stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n        private\n        returns (DataTypes.Balances memory, DataTypes.Balances memory)\n    {\n        if (ink > 0) require (cauldron.vaults(from).owner == msg.sender, \"Only origin vault owner\");\n        if (art > 0) require (cauldron.vaults(to).owner == msg.sender, \"Only destination vault owner\");\n        return cauldron.stir(from, to, ink, art);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    /// Borrow only before maturity.\n    function _pour(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, int128 art)\n        private\n        returns (DataTypes.Balances memory balances)\n    {\n        DataTypes.Series memory series;\n        if (art != 0) series = getSeries(vault.seriesId);\n\n        int128 fee;\n        if (art > 0) fee = ((series.maturity - block.timestamp) * uint256(int256(art)).wmul(borrowingFee)).u128().i128();\n\n        // Update accounting\n        balances = cauldron.pour(vaultId, ink, art + fee);\n\n        // Manage collateral\n        if (ink != 0) {\n            IJoin ilkJoin = getJoin(vault.ilkId);\n            if (ink > 0) ilkJoin.join(vault.owner, uint128(ink));\n            if (ink < 0) ilkJoin.exit(to, uint128(-ink));\n        }\n\n        // Manage debt tokens\n        if (art != 0) {\n            if (art > 0) series.fyToken.mint(to, uint128(art));\n            else series.fyToken.burn(msg.sender, uint128(-art));\n        }\n    }\n\n    /// @dev Add collateral and borrow from vault, so that a precise amount of base is obtained by the user.\n    /// The base is obtained by borrowing fyToken and buying base with it in a pool.\n    /// Only before maturity.\n    function _serve(bytes12 vaultId, DataTypes.Vault memory vault, address to, uint128 ink, uint128 base, uint128 max)\n        private\n        returns (DataTypes.Balances memory balances, uint128 art)\n    {\n        IPool pool = getPool(vault.seriesId);\n        \n        art = pool.buyBasePreview(base);\n        balances = _pour(vaultId, vault, address(pool), ink.i128(), art.i128());\n        pool.buyBase(to, base, max);\n    }\n\n    /// @dev Repay vault debt using underlying token at a 1:1 exchange rate, without trading in a pool.\n    /// It can add or remove collateral at the same time.\n    /// The debt to repay is denominated in fyToken, even if the tokens pulled from the user are underlying.\n    /// The debt to repay must be entered as a negative number, as with `pour`.\n    /// Debt cannot be acquired with this function.\n    function _close(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, int128 art)\n        private\n        returns (DataTypes.Balances memory balances)\n    {\n        require (art < 0, \"Only repay debt\");                                          // When repaying debt in `frob`, art is a negative value. Here is the same for consistency.\n\n        // Calculate debt in fyToken terms\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        uint128 amt = _debtInBase(vault.seriesId, series, uint128(-art));\n\n        // Update accounting\n        balances = cauldron.pour(vaultId, ink, art);\n\n        // Manage collateral\n        if (ink != 0) {\n            IJoin ilkJoin = getJoin(vault.ilkId);\n            if (ink > 0) ilkJoin.join(vault.owner, uint128(ink));\n            if (ink < 0) ilkJoin.exit(to, uint128(-ink));\n        }\n\n        // Manage underlying\n        IJoin baseJoin = getJoin(series.baseId);\n        baseJoin.join(msg.sender, amt);\n    }\n\n    /// @dev Calculate a debt amount for a series in base terms\n    function _debtInBase(bytes6 seriesId, DataTypes.Series memory series, uint128 art)\n        private\n        returns (uint128 amt)\n    {\n        if (uint32(block.timestamp) >= series.maturity) {\n            amt = uint256(art).wmul(cauldron.accrual(seriesId)).u128();\n        } else {\n            amt = art;\n        }\n    }\n\n    /// @dev Repay debt by selling base in a pool and using the resulting fyToken\n    /// The base tokens need to be already in the pool, unaccounted for.\n    /// Only before maturity. After maturity use close.\n    function _repay(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, uint128 min)\n        private\n        returns (DataTypes.Balances memory balances, uint128 art)\n    {\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        IPool pool = getPool(vault.seriesId);\n\n        art = pool.sellBase(address(series.fyToken), min);\n        balances = _pour(vaultId, vault, to, ink, -(art.i128()));\n    }\n\n    /// @dev Repay all debt in a vault by buying fyToken from a pool with base.\n    /// The base tokens need to be already in the pool, unaccounted for. The surplus base will be returned to msg.sender.\n    /// Only before maturity. After maturity use close.\n    function _repayVault(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, uint128 max)\n        private\n        returns (DataTypes.Balances memory balances, uint128 base)\n    {\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        IPool pool = getPool(vault.seriesId);\n\n        balances = cauldron.balances(vaultId);\n        base = pool.buyFYToken(address(series.fyToken), balances.art, max);\n        balances = _pour(vaultId, vault, to, ink, -(balances.art.i128()));\n        pool.retrieveBase(msg.sender);\n    }\n\n    /// @dev Change series and debt of a vault.\n    function _roll(bytes12 vaultId, DataTypes.Vault memory vault, bytes6 newSeriesId, uint8 loan, uint128 max)\n        private\n        returns (DataTypes.Vault memory, DataTypes.Balances memory)\n    {\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        DataTypes.Series memory newSeries = getSeries(newSeriesId);\n        DataTypes.Balances memory balances = cauldron.balances(vaultId);\n        \n        uint128 newDebt;\n        {\n            IPool pool = getPool(newSeriesId);\n            IFYToken fyToken = IFYToken(newSeries.fyToken);\n            IJoin baseJoin = getJoin(series.baseId);\n\n            // Calculate debt in fyToken terms\n            uint128 amt = _debtInBase(vault.seriesId, series, balances.art);\n\n            // Mint fyToken to the pool, as a kind of flash loan\n            fyToken.mint(address(pool), amt * loan);                // Loan is the size of the flash loan relative to the debt amount, 2 should be safe most of the time\n\n            // Buy the base required to pay off the debt in series 1, and find out the debt in series 2\n            newDebt = pool.buyBase(address(baseJoin), amt, max);\n            baseJoin.join(address(baseJoin), amt);                  // Repay the old series debt\n\n            pool.retrieveFYToken(address(fyToken));                 // Get the surplus fyToken\n            fyToken.burn(address(fyToken), (amt * loan) - newDebt);    // Burn the surplus\n        }\n\n        newDebt += ((newSeries.maturity - block.timestamp) * uint256(newDebt).wmul(borrowingFee)).u128();  // Add borrowing fee, also stops users form rolling to a mature series\n\n        return cauldron.roll(vaultId, newSeriesId, newDebt.i128() - balances.art.i128()); // Change the series and debt for the vault\n    }\n\n    // ---- Ladle as a token holder ----\n\n    /// @dev Use fyToken in the Ladle to repay debt.\n    function _repayLadle(bytes12 vaultId, DataTypes.Vault memory vault)\n        private\n        returns (DataTypes.Balances memory balances)\n    {\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        balances = cauldron.balances(vaultId);\n        \n        uint256 amount = series.fyToken.balanceOf(address(this));\n        amount = amount <= balances.art ? amount : balances.art;\n\n        // Update accounting\n        balances = cauldron.pour(vaultId, 0, -(amount.u128().i128()));\n        series.fyToken.burn(address(this), amount);\n    }\n\n    /// @dev Retrieve any asset or fyToken in the Ladle\n    function _retrieve(bytes6 id, bool isAsset, address to) \n        private\n        returns (uint256 amount)\n    {\n        IERC20 token = IERC20(findToken(id, isAsset));\n        amount = token.balanceOf(address(this));\n        token.safeTransfer(to, amount);\n    }\n\n    // ---- Liquidations ----\n\n    /// @dev Allow liquidation contracts to move assets to wind down vaults\n    function settle(bytes12 vaultId, address user, uint128 ink, uint128 art)\n        external\n        auth\n    {\n        DataTypes.Vault memory vault = getOwnedVault(vaultId);\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n\n        cauldron.slurp(vaultId, ink, art);                                                  // Remove debt and collateral from the vault\n\n        if (ink != 0) {                                                                     // Give collateral to the user\n            IJoin ilkJoin = getJoin(vault.ilkId);\n            ilkJoin.exit(user, ink);\n        }\n        if (art != 0) {                                                                     // Take underlying from user\n            IJoin baseJoin = getJoin(series.baseId);\n            baseJoin.join(user, art);\n        }\n    }\n\n    // ---- Permit management ----\n\n    /// @dev From an id, which can be an assetId or a seriesId, find the resulting asset or fyToken\n    function findToken(bytes6 id, bool isAsset)\n        private view returns (address token)\n    {\n        token = isAsset ? cauldron.assets(id) : address(getSeries(id).fyToken);\n        require (token != address(0), \"Token not found\");\n    }\n\n    /// @dev Execute an ERC2612 permit for the selected asset or fyToken\n    function _forwardPermit(bytes6 id, bool isAsset, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        private\n    {\n        IERC2612 token = IERC2612(findToken(id, isAsset));\n        token.permit(msg.sender, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Execute a Dai-style permit for the selected asset or fyToken\n    function _forwardDaiPermit(bytes6 id, bool isAsset, address spender, uint256 nonce, uint256 deadline, bool allowed, uint8 v, bytes32 r, bytes32 s)\n        private\n    {\n        DaiAbstract token = DaiAbstract(findToken(id, isAsset));\n        token.permit(msg.sender, spender, nonce, deadline, allowed, v, r, s);\n    }\n\n    // ---- Ether management ----\n\n    /// @dev The WETH9 contract will send ether to BorrowProxy on `weth.withdraw` using this function.\n    receive() external payable { }\n\n    /// @dev Accept Ether, wrap it and forward it to the WethJoin\n    /// This function should be called first in a batch, and the Join should keep track of stored reserves\n    /// Passing the id for a join that doesn't link to a contract implemnting IWETH9 will fail\n    function _joinEther(bytes6 etherId)\n        private\n        returns (uint256 ethTransferred)\n    {\n        ethTransferred = address(this).balance;\n        IJoin wethJoin = getJoin(etherId);\n        weth.deposit{ value: ethTransferred }();   // TODO: Test gas savings using WETH10 `depositTo`\n        IERC20(address(weth)).safeTransfer(address(wethJoin), ethTransferred);\n    }\n\n    /// @dev Unwrap Wrapped Ether held by this Ladle, and send the Ether\n    /// This function should be called last in a batch, and the Ladle should have no reason to keep an WETH balance\n    function _exitEther(address payable to)\n        private\n        returns (uint256 ethTransferred)\n    {\n        ethTransferred = weth.balanceOf(address(this));\n        weth.withdraw(ethTransferred);   // TODO: Test gas savings using WETH10 `withdrawTo`\n        to.safeTransferETH(ethTransferred);\n    }\n\n    // ---- Pool router ----\n\n    /// @dev Allow users to trigger a token transfer to a pool through the ladle, to be used with batch\n    function _transferToPool(IPool pool, bool base, uint128 wad)\n        private\n    {\n        IERC20 token = base ? pool.base() : pool.fyToken();\n        token.safeTransferFrom(msg.sender, address(pool), wad);\n    }\n\n    /// @dev Allow users to route calls to a pool, to be used with batch\n    function _route(IPool pool, bytes memory data)\n        private\n        returns (bool success, bytes memory result)\n    {\n        (success, result) = address(pool).call(data);\n        if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n    }\n\n    // ---- FYToken router ----\n\n    /// @dev Allow users to trigger a token transfer to a pool through the ladle, to be used with batch\n    function _transferToFYToken(IFYToken fyToken, uint256 wad)\n        private\n    {\n        IERC20(fyToken).safeTransferFrom(msg.sender, address(fyToken), wad);\n    }\n\n    /// @dev Allow users to redeem fyToken, to be used with batch.\n    /// If 0 is passed as the amount to redeem, it redeems the fyToken balance of the Ladle instead.\n    function _redeem(IFYToken fyToken, address to, uint256 wad)\n        private\n        returns (uint256)\n    {\n        return fyToken.redeem(to, wad != 0 ? wad : fyToken.balanceOf(address(this)));\n    }\n\n    // ---- Module router ----\n\n    /// @dev Allow users to use functionality coded in a module, to be used with batch\n    function _moduleCall(address module, bytes memory moduleCall)\n        private\n        returns (bool success, bytes memory result)\n    {\n        require (modules[module], \"Unregistered module\");\n        (success, result) = module.delegatecall(moduleCall);\n        if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n    }\n}",
    "bin": []
}