{
    "file_path": "/home/mingyue/sub_contract_content/Web3Bugs/contracts/25",
    "external_functions": [
        [],
        [
            "Cauldron",
            "IFYToken",
            "IOracle"
        ],
        [
            "FYToken",
            "IJoin",
            "IOracle",
            "IERC3156FlashBorrower"
        ],
        [
            "FYTokenFactory",
            "FYToken",
            "IJoin",
            "IOracle",
            "IERC3156FlashBorrower"
        ],
        [
            "Join",
            "IERC20",
            "IERC3156FlashBorrower"
        ],
        [
            "JoinFactory",
            "Join",
            "IERC20",
            "IERC3156FlashBorrower"
        ],
        [
            "Ladle",
            "ICauldron",
            "IJoin",
            "IPool",
            "IFYToken",
            "IERC20",
            "IERC2612",
            "DaiAbstract",
            "IWETH9"
        ],
        [
            "LadleStorage"
        ],
        [
            "IOwnable"
        ],
        [
            "Wand",
            "AccessControl",
            "IJoinFactory",
            "ICauldronGov",
            "ILadleGov",
            "IMultiOracleGov",
            "IPoolFactory",
            "IOwnable",
            "IFYTokenFactory"
        ],
        [
            "Witch",
            "ICauldron",
            "ILadle",
            "IJoin"
        ]
    ],
    "new_contract": "contract Join is IJoin, IERC3156FlashLender, AccessControl() {\n    using TransferHelper for IERC20;\n    using WMul for uint256;\n    using CastU256U128 for uint256;\n\n    event FlashFeeFactorSet(uint256 indexed fee);\n\n    bytes32 constant internal FLASH_LOAN_RETURN = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    uint256 constant FLASH_LOANS_DISABLED = type(uint256).max;\n\n    address public immutable override asset;\n    uint256 public storedBalance;\n    uint256 public flashFeeFactor = FLASH_LOANS_DISABLED; // Fee on flash loans, as a percentage in fixed point with 18 decimals. Flash loans disabled by default.\n\n    constructor(address asset_) {\n        asset = asset_;\n    }\n\n    /// @dev Set the flash loan fee factor\n    function setFlashFeeFactor(uint256 flashFeeFactor_)\n        external\n        auth\n    {\n        flashFeeFactor = flashFeeFactor_;\n        emit FlashFeeFactorSet(flashFeeFactor_);\n    }\n\n    /// @dev Take `amount` `asset` from `user` using `transferFrom`, minus any unaccounted `asset` in this contract.\n    function join(address user, uint128 amount)\n        external override\n        auth\n        returns (uint128)\n    {\n        return _join(user, amount);\n    }\n\n    /// @dev Take `amount` `asset` from `user` using `transferFrom`, minus any unaccounted `asset` in this contract.\n    function _join(address user, uint128 amount)\n        internal\n        returns (uint128)\n    {\n        IERC20 token = IERC20(asset);\n        uint256 _storedBalance = storedBalance;\n        uint256 available = token.balanceOf(address(this)) - _storedBalance; // Fine to panic if this underflows\n        storedBalance = _storedBalance + amount;\n        unchecked { if (available < amount) token.safeTransferFrom(user, address(this), amount - available); }\n        return amount;        \n    }\n\n    /// @dev Transfer `amount` `asset` to `user`\n    function exit(address user, uint128 amount)\n        external override\n        auth\n        returns (uint128)\n    {\n        return _exit(user, amount);\n    }\n\n    /// @dev Transfer `amount` `asset` to `user`\n    function _exit(address user, uint128 amount)\n        internal\n        returns (uint128)\n    {\n        IERC20 token = IERC20(asset);\n        storedBalance -= amount;\n        token.safeTransfer(user, amount);\n        return amount;\n    }\n\n    /// @dev Retrieve any tokens other than the `asset`. Useful for airdropped tokens.\n    function retrieve(IERC20 token, address to)\n        external\n        auth\n    {\n        require(address(token) != address(asset), \"Use exit for asset\");\n        token.safeTransfer(to, token.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev From ERC-3156. The amount of currency available to be lended.\n     * @param token The loan currency. It must be a FYDai contract.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token)\n        external view override\n        returns (uint256)\n    {\n        return token == asset ? storedBalance : 0;\n    }\n\n    /**\n     * @dev From ERC-3156. The fee to be charged for a given loan.\n     * @param token The loan currency. It must be the asset.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount)\n        external view override\n        returns (uint256)\n    {\n        require(token == asset, \"Unsupported currency\");\n        return _flashFee(amount);\n    }\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function _flashFee(uint256 amount) internal view returns (uint256) {\n        return amount.wmul(flashFeeFactor);\n    }\n\n    /**\n     * @dev From ERC-3156. Loan `amount` `asset` to `receiver`, which needs to return them plus fee to this contract within the same transaction.\n     * If the principal + fee are transferred to this contract, they won't be pulled from the receiver.\n     * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n     * @param token The loan currency. Must be a fyDai contract.\n     * @param amount The amount of tokens lent.\n     * @param data A data parameter to be passed on to the `receiver` for any custom use.\n     */\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes memory data)\n        external override\n        returns(bool)\n    {\n        require(token == asset, \"Unsupported currency\");\n        uint128 _amount = amount.u128();\n        uint128 _fee = _flashFee(amount).u128();\n        _exit(address(receiver), _amount);\n\n        require(receiver.onFlashLoan(msg.sender, token, _amount, _fee, data) == FLASH_LOAN_RETURN, \"Non-compliant borrower\");\n\n        _join(address(receiver), _amount + _fee);\n        return true;\n    }\n}contract AccessControl {\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes4 adminRole;\n    }\n\n    mapping (bytes4 => RoleData) private _roles;\n\n    bytes4 public constant ROOT = 0x00000000;\n    bytes4 public constant LOCK = 0xFFFFFFFF; // Used to disable further permissioning of a function\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role\n     *\n     * `ROOT` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes4 indexed role, bytes4 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call.\n     */\n    event RoleGranted(bytes4 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes4 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Give msg.sender the ROOT role and create a LOCK role with itself as the admin role and no members. \n     * Calling setRoleAdmin(msg.sig, LOCK) means no one can grant that msg.sig role anymore.\n     */\n    constructor () {\n        _grantRole(ROOT, msg.sender);   // Grant ROOT to msg.sender\n        _setRoleAdmin(LOCK, LOCK);      // Create the LOCK role by setting itself as its own admin, creating an independent role tree\n    }\n\n    /**\n     * @dev Each function in the contract has its own role, identified by their msg.sig signature.\n     * ROOT can give and remove access to each function, lock any further access being granted to\n     * a specific action, or even create other roles to delegate admin control over a function.\n     */\n    modifier auth() {\n        require (_hasRole(msg.sig, msg.sender), \"Access denied\");\n        _;\n    }\n\n    /**\n     * @dev Allow only if the caller has been granted the admin role of `role`.\n     */\n    modifier admin(bytes4 role) {\n        require (_hasRole(_getRoleAdmin(role), msg.sender), \"Only admin\");\n        _;\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes4 role, address account) external view returns (bool) {\n        return _hasRole(role, account);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes4 role) external view returns (bytes4) {\n        return _getRoleAdmin(role);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n\n     * If ``role``'s admin role is not `adminRole` emits a {RoleAdminChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function setRoleAdmin(bytes4 role, bytes4 adminRole) external virtual admin(role) {\n        _setRoleAdmin(role, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes4 role, address account) external virtual admin(role) {\n        _grantRole(role, account);\n    }\n\n    \n    /**\n     * @dev Grants all of `role` in `roles` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - For each `role` in `roles`, the caller must have ``role``'s admin role.\n     */\n    function grantRoles(bytes4[] memory roles, address account) external virtual {\n        for (uint256 i = 0; i < roles.length; i++) {\n            require (_hasRole(_getRoleAdmin(roles[i]), msg.sender), \"Only admin\");\n            _grantRole(roles[i], account);\n        }\n    }\n\n    /**\n     * @dev Sets LOCK as ``role``'s admin role. LOCK has no members, so this disables admin management of ``role``.\n\n     * Emits a {RoleAdminChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function lockRole(bytes4 role) external virtual admin(role) {\n        _setRoleAdmin(role, LOCK);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes4 role, address account) external virtual admin(role) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes all of `role` in `roles` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - For each `role` in `roles`, the caller must have ``role``'s admin role.\n     */\n    function revokeRoles(bytes4[] memory roles, address account) external virtual {\n        for (uint256 i = 0; i < roles.length; i++) {\n            require (_hasRole(_getRoleAdmin(roles[i]), msg.sender), \"Only admin\");\n            _revokeRole(roles[i], account);\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes4 role, address account) external virtual {\n        require(account == msg.sender, \"Renounce only for self\");\n\n        _revokeRole(role, account);\n    }\n\n    function _hasRole(bytes4 role, address account) internal view returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    function _getRoleAdmin(bytes4 role) internal view returns (bytes4) {\n        return _roles[role].adminRole;\n    }\n\n    function _setRoleAdmin(bytes4 role, bytes4 adminRole) internal virtual {\n        if (_getRoleAdmin(role) != adminRole) {\n            _roles[role].adminRole = adminRole;\n            emit RoleAdminChanged(role, adminRole);\n        }\n    }\n\n    function _grantRole(bytes4 role, address account) internal {\n        if (!_hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, msg.sender);\n        }\n    }\n\n    function _revokeRole(bytes4 role, address account) internal {\n        if (_hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, msg.sender);\n        }\n    }\n}contract Cauldron is AccessControl() {\n    using CauldronMath for uint128;\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU128I128 for uint128;\n    using CastI128U128 for int128;\n    using CastU256U128 for uint256;\n    using CastU256U32 for uint256;\n    using CastU256I256 for uint256;\n\n    event AssetAdded(bytes6 indexed assetId, address indexed asset);\n    event SeriesAdded(bytes6 indexed seriesId, bytes6 indexed baseId, address indexed fyToken);\n    event IlkAdded(bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event SpotOracleAdded(bytes6 indexed baseId, bytes6 indexed ilkId, address indexed oracle, uint32 ratio);\n    event RateOracleAdded(bytes6 indexed baseId, address indexed oracle);\n    event DebtLimitsSet(bytes6 indexed baseId, bytes6 indexed ilkId, uint96 max, uint24 min, uint8 dec);\n\n    event VaultBuilt(bytes12 indexed vaultId, address indexed owner, bytes6 indexed seriesId, bytes6 ilkId);\n    event VaultTweaked(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event VaultDestroyed(bytes12 indexed vaultId);\n    event VaultGiven(bytes12 indexed vaultId, address indexed receiver);\n\n    event VaultPoured(bytes12 indexed vaultId, bytes6 indexed seriesId, bytes6 indexed ilkId, int128 ink, int128 art);\n    event VaultStirred(bytes12 indexed from, bytes12 indexed to, uint128 ink, uint128 art);\n    event VaultRolled(bytes12 indexed vaultId, bytes6 indexed seriesId, uint128 art);\n\n    event SeriesMatured(bytes6 indexed seriesId, uint256 rateAtMaturity);\n\n    // ==== Configuration data ====\n    mapping (bytes6 => address)                                 public assets;          // Underlyings and collaterals available in Cauldron. 12 bytes still free.\n    mapping (bytes6 => DataTypes.Series)                        public series;          // Series available in Cauldron. We can possibly use a bytes6 (3e14 possible series).\n    mapping (bytes6 => mapping(bytes6 => bool))                 public ilks;            // [seriesId][assetId] Assets that are approved as collateral for a series\n\n    mapping (bytes6 => IOracle)                                 public rateOracles;     // Rate (borrowing rate) accruals oracle for the underlying\n    mapping (bytes6 => mapping(bytes6 => DataTypes.SpotOracle)) public spotOracles;     // [assetId][assetId] Spot price oracles\n\n    // ==== Protocol data ====\n    mapping (bytes6 => mapping(bytes6 => DataTypes.Debt))       public debt;            // [baseId][ilkId] Max and sum of debt per underlying and collateral.\n    mapping (bytes6 => uint256)                                 public ratesAtMaturity; // Borrowing rate at maturity for a mature series\n\n    // ==== User data ====\n    mapping (bytes12 => DataTypes.Vault)                        public vaults;          // An user can own one or more Vaults, each one with a bytes12 identifier\n    mapping (bytes12 => DataTypes.Balances)                     public balances;        // Both debt and assets\n\n    // ==== Administration ====\n\n    /// @dev Add a new Asset.\n    function addAsset(bytes6 assetId, address asset)\n        external\n        auth\n    {\n        require (assetId != bytes6(0), \"Asset id is zero\");\n        require (assets[assetId] == address(0), \"Id already used\");\n        assets[assetId] = asset;\n        emit AssetAdded(assetId, address(asset));\n    }\n\n    /// @dev Set the maximum and minimum debt for an underlying and ilk pair. Can be reset.\n    function setDebtLimits(bytes6 baseId, bytes6 ilkId, uint96 max, uint24 min, uint8 dec)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        DataTypes.Debt memory debt_ = debt[baseId][ilkId];\n        debt_.max = max;\n        debt_.min = min;\n        debt_.dec = dec;\n        debt[baseId][ilkId] = debt_;\n        emit DebtLimitsSet(baseId, ilkId, max, min, dec);\n    }\n\n    /// @dev Set a rate oracle. Can be reset.\n    function setRateOracle(bytes6 baseId, IOracle oracle)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        rateOracles[baseId] = oracle;\n        emit RateOracleAdded(baseId, address(oracle));\n    }\n\n    /// @dev Set a spot oracle and its collateralization ratio. Can be reset.\n    function setSpotOracle(bytes6 baseId, bytes6 ilkId, IOracle oracle, uint32 ratio)\n        external\n        auth\n    {\n        require (assets[baseId] != address(0), \"Base not found\");\n        require (assets[ilkId] != address(0), \"Ilk not found\");\n        spotOracles[baseId][ilkId] = DataTypes.SpotOracle({\n            oracle: oracle,\n            ratio: ratio                                                                    // With 6 decimals. 1000000 == 100%\n        });                                                                                 // Allows to replace an existing oracle.\n        emit SpotOracleAdded(baseId, ilkId, address(oracle), ratio);\n    }\n\n    /// @dev Add a new series\n    function addSeries(bytes6 seriesId, bytes6 baseId, IFYToken fyToken)\n        external\n        auth\n    {\n        require (seriesId != bytes6(0), \"Series id is zero\");\n        address base = assets[baseId];\n        require (base != address(0), \"Base not found\");\n        require (fyToken != IFYToken(address(0)), \"Series need a fyToken\");\n        require (fyToken.underlying() == base, \"Mismatched series and base\");\n        require (rateOracles[baseId] != IOracle(address(0)), \"Rate oracle not found\");\n        require (series[seriesId].fyToken == IFYToken(address(0)), \"Id already used\");\n        series[seriesId] = DataTypes.Series({\n            fyToken: fyToken,\n            maturity: fyToken.maturity().u32(),\n            baseId: baseId\n        });\n        emit SeriesAdded(seriesId, baseId, address(fyToken));\n    }\n\n    /// @dev Add a new Ilk (approve an asset as collateral for a series).\n    function addIlks(bytes6 seriesId, bytes6[] calldata ilkIds)\n        external\n        auth\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        require (\n            series_.fyToken != IFYToken(address(0)),\n            \"Series not found\"\n        );\n        for (uint256 i = 0; i < ilkIds.length; i++) {\n            require (\n                spotOracles[series_.baseId][ilkIds[i]].oracle != IOracle(address(0)),\n                \"Spot oracle not found\"\n            );\n            ilks[seriesId][ilkIds[i]] = true;\n            emit IlkAdded(seriesId, ilkIds[i]);\n        }\n    }\n\n    // ==== Vault management ====\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function build(address owner, bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        require (vaultId != bytes12(0), \"Vault id is zero\");\n        require (seriesId != bytes12(0), \"Series id is zero\");\n        require (ilkId != bytes12(0), \"Ilk id is zero\");\n        require (vaults[vaultId].seriesId == bytes6(0), \"Vault already exists\");   // Series can't take bytes6(0) as their id\n        require (ilks[seriesId][ilkId] == true, \"Ilk not added to series\");\n        vault = DataTypes.Vault({\n            owner: owner,\n            seriesId: seriesId,\n            ilkId: ilkId\n        });\n        vaults[vaultId] = vault;\n\n        emit VaultBuilt(vaultId, owner, seriesId, ilkId);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function destroy(bytes12 vaultId)\n        external\n        auth\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        require (balances_.art == 0 && balances_.ink == 0, \"Only empty vaults\");\n        delete vaults[vaultId];\n        emit VaultDestroyed(vaultId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    function _tweak(bytes12 vaultId, DataTypes.Vault memory vault)\n        internal\n    {\n        require (vault.seriesId != bytes6(0), \"Series id is zero\");\n        require (vault.ilkId != bytes6(0), \"Ilk id is zero\");\n        require (ilks[vault.seriesId][vault.ilkId] == true, \"Ilk not added to series\");\n\n        vaults[vaultId] = vault;\n        emit VaultTweaked(vaultId, vault.seriesId, vault.ilkId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    /// We can change the series if there is no debt, or assets if there are no assets\n    function tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        vault = vaults[vaultId];\n        if (seriesId != vault.seriesId) {\n            require (balances_.art == 0, \"Only with no debt\");\n            vault.seriesId = seriesId;\n        }\n        if (ilkId != vault.ilkId) {\n            require (balances_.ink == 0, \"Only with no collateral\");\n            vault.ilkId = ilkId;\n        }\n        _tweak(vaultId, vault);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function _give(bytes12 vaultId, address receiver)\n        internal\n        returns(DataTypes.Vault memory vault)\n    {\n        require (vaultId != bytes12(0), \"Vault id is zero\");\n        vault = vaults[vaultId];\n        vault.owner = receiver;\n        vaults[vaultId] = vault;\n        emit VaultGiven(vaultId, receiver);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function give(bytes12 vaultId, address receiver)\n        external\n        auth\n        returns(DataTypes.Vault memory vault)\n    {\n        vault = _give(vaultId, receiver);\n    }\n\n    // ==== Asset and debt management ====\n\n    function vaultData(bytes12 vaultId, bool getSeries)\n        internal\n        view\n        returns (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_)\n    {\n        vault_ = vaults[vaultId];\n        require (vault_.seriesId != bytes6(0), \"Vault not found\");\n        if (getSeries) series_ = series[vault_.seriesId];\n        balances_ = balances[vaultId];\n    }\n\n    /// @dev Convert a debt amount for a series from base to fyToken terms.\n    /// @notice Think about rounding if using, since we are dividing.\n    function debtFromBase(bytes6 seriesId, uint128 base)\n        external\n        returns (uint128 art)\n    {\n        if (uint32(block.timestamp) >= series[seriesId].maturity) {\n            DataTypes.Series memory series_ = series[seriesId];\n            art = uint256(base).wdiv(_accrual(seriesId, series_)).u128();\n        } else {\n            art = base;\n        }\n    }\n\n    /// @dev Convert a debt amount for a series from fyToken to base terms\n    function debtToBase(bytes6 seriesId, uint128 art)\n        external\n        returns (uint128 base)\n    {\n        if (uint32(block.timestamp) >= series[seriesId].maturity) {\n            DataTypes.Series memory series_ = series[seriesId];\n            base = uint256(art).wmul(_accrual(seriesId, series_)).u128();\n        } else {\n            base = art;\n        }\n    }\n\n    /// @dev Move collateral and debt between vaults.\n    function stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory, DataTypes.Balances memory)\n    {\n        require (from != to, \"Identical vaults\");\n        (DataTypes.Vault memory vaultFrom, , DataTypes.Balances memory balancesFrom) = vaultData(from, false);\n        (DataTypes.Vault memory vaultTo, , DataTypes.Balances memory balancesTo) = vaultData(to, false);\n\n        if (ink > 0) {\n            require (vaultFrom.ilkId == vaultTo.ilkId, \"Different collateral\");\n            balancesFrom.ink -= ink;\n            balancesTo.ink += ink;\n        }\n        if (art > 0) {\n            require (vaultFrom.seriesId == vaultTo.seriesId, \"Different series\");\n            balancesFrom.art -= art;\n            balancesTo.art += art;\n        }\n\n        balances[from] = balancesFrom;\n        balances[to] = balancesTo;\n\n        if (ink > 0) require(_level(vaultFrom, balancesFrom, series[vaultFrom.seriesId]) >= 0, \"Undercollateralized at origin\");\n        if (art > 0) require(_level(vaultTo, balancesTo, series[vaultTo.seriesId]) >= 0, \"Undercollateralized at destination\");\n\n        emit VaultStirred(from, to, ink, art);\n        return (balancesFrom, balancesTo);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    function _pour(\n        bytes12 vaultId,\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_,\n        int128 ink,\n        int128 art\n    )\n        internal returns (DataTypes.Balances memory)\n    {\n        // For now, the collateralization checks are done outside to allow for underwater operation. That might change.\n        if (ink != 0) {\n            balances_.ink = balances_.ink.add(ink);\n        }\n\n        // Modify vault and global debt records. If debt increases, check global limit.\n        if (art != 0) {\n            DataTypes.Debt memory debt_ = debt[series_.baseId][vault_.ilkId];\n            balances_.art = balances_.art.add(art);\n            debt_.sum = debt_.sum.add(art);\n            uint128 dust = debt_.min * uint128(10) ** debt_.dec;\n            uint128 line = debt_.max * uint128(10) ** debt_.dec;\n            require (balances_.art == 0 || balances_.art >= dust, \"Min debt not reached\");\n            if (art > 0) require (debt_.sum <= line, \"Max debt exceeded\");\n            debt[series_.baseId][vault_.ilkId] = debt_;\n        }\n        balances[vaultId] = balances_;\n\n        emit VaultPoured(vaultId, vault_.seriesId, vault_.ilkId, ink, art);\n        return balances_;\n    }\n\n    /// @dev Manipulate a vault, ensuring it is collateralized afterwards.\n    /// To be used by debt management contracts.\n    function pour(bytes12 vaultId, int128 ink, int128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, ink, art);\n\n        if (balances_.art > 0 && (ink < 0 || art > 0))                          // If there is debt and we are less safe\n            require(_level(vault_, balances_, series_) >= 0, \"Undercollateralized\");\n        return balances_;\n    }\n\n    /// @dev Give an uncollateralized vault to another user.\n    /// To be used for liquidation engines.\n    function grab(bytes12 vaultId, address receiver)\n        external\n        auth\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        require(_level(vault_, balances_, series_) < 0, \"Not undercollateralized\");\n        _give(vaultId, receiver);\n    }\n\n    /// @dev Reduce debt and collateral from a vault, ignoring collateralization checks.\n    /// To be used by liquidation engines.\n    function slurp(bytes12 vaultId, uint128 ink, uint128 art)\n        external\n        auth\n        returns (DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, -(ink.i128()), -(art.i128()));\n\n        return balances_;\n    }\n\n    /// @dev Change series and debt of a vault.\n    /// The module calling this function also needs to buy underlying in the pool for the new series, and sell it in pool for the old series.\n    function roll(bytes12 vaultId, bytes6 newSeriesId, int128 art)\n        external\n        auth\n        returns (DataTypes.Vault memory, DataTypes.Balances memory)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory oldSeries_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n        DataTypes.Series memory newSeries_ = series[newSeriesId];\n        require (oldSeries_.baseId == newSeries_.baseId, \"Mismatched bases in series\");\n        \n        // Change the vault series\n        vault_.seriesId = newSeriesId;\n        _tweak(vaultId, vault_);\n\n        // Change the vault balances\n        balances_ = _pour(vaultId, vault_, balances_, newSeries_, 0, art);\n\n        require(_level(vault_, balances_, newSeries_) >= 0, \"Undercollateralized\");\n        emit VaultRolled(vaultId, newSeriesId, balances_.art);\n\n        return (vault_, balances_);\n    }\n\n    // ==== Accounting ====\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function level(bytes12 vaultId)\n        external\n        returns (int256)\n    {\n        (DataTypes.Vault memory vault_, DataTypes.Series memory series_, DataTypes.Balances memory balances_) = vaultData(vaultId, true);\n\n        return _level(vault_, balances_, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function mature(bytes6 seriesId)\n        external\n    {\n        require (ratesAtMaturity[seriesId] == 0, \"Already matured\");\n        DataTypes.Series memory series_ = series[seriesId];\n        _mature(seriesId, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function _mature(bytes6 seriesId, DataTypes.Series memory series_)\n        internal\n    {\n        require (uint32(block.timestamp) >= series_.maturity, \"Only after maturity\");\n        IOracle rateOracle = rateOracles[series_.baseId];\n        (uint256 rateAtMaturity,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n        ratesAtMaturity[seriesId] = rateAtMaturity;\n        emit SeriesMatured(seriesId, rateAtMaturity);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    function accrual(bytes6 seriesId)\n        external\n        returns (uint256)\n    {\n        DataTypes.Series memory series_ = series[seriesId];\n        return _accrual(seriesId, series_);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual(bytes6 seriesId, DataTypes.Series memory series_)\n        private\n        returns (uint256 accrual_)\n    {\n        uint256 rateAtMaturity = ratesAtMaturity[seriesId];\n        if (rateAtMaturity == 0) {  // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.\n            _mature(seriesId, series_);\n        } else {\n            IOracle rateOracle = rateOracles[series_.baseId];\n            (uint256 rate,) = rateOracle.get(series_.baseId, bytes32(\"rate\"), 1e18);\n            accrual_ = rate.wdiv(rateAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function _level(\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_\n    )\n        internal\n        returns (int256)\n    {\n        DataTypes.SpotOracle memory spotOracle_ = spotOracles[series_.baseId][vault_.ilkId];\n        uint256 ratio = uint256(spotOracle_.ratio) * 1e12;   // Normalized to 18 decimals\n        (uint256 inkValue,) = spotOracle_.oracle.get(series_.baseId, vault_.ilkId, balances_.ink);    // ink * spot\n\n        if (uint32(block.timestamp) >= series_.maturity) {\n            uint256 accrual_ = _accrual(vault_.seriesId, series_);\n            return inkValue.i256() - uint256(balances_.art).wmul(accrual_).wmul(ratio).i256();\n        }\n\n        return inkValue.i256() - uint256(balances_.art).wmul(ratio).i256();\n    }\n}contract FYToken is IFYToken, IERC3156FlashLender, AccessControl(), ERC20Permit, Constants {\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU256U128 for uint256;\n    using CastU256U32 for uint256;\n\n    event SeriesMatured(uint256 chiAtMaturity);\n    event Redeemed(address indexed from, address indexed to, uint256 amount, uint256 redeemed);\n    event OracleSet(address indexed oracle);\n\n    uint256 constant CHI_NOT_SET = type(uint256).max;\n\n    uint256 constant internal MAX_TIME_TO_MATURITY = 126144000; // seconds in four years\n    bytes32 constant internal FLASH_LOAN_RETURN = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    IOracle public oracle;                                      // Oracle for the savings rate.\n    IJoin public immutable join;                                // Source of redemption funds.\n    address public immutable override underlying;\n    bytes6 public immutable underlyingId;                             // Needed to access the oracle\n    uint256 public immutable override maturity;\n    uint256 public chiAtMaturity = CHI_NOT_SET;           // Spot price (exchange rate) between the base and an interest accruing token at maturity \n\n    constructor(\n        bytes6 underlyingId_,\n        IOracle oracle_, // Underlying vs its interest-bearing version\n        IJoin join_,\n        uint256 maturity_,\n        string memory name,\n        string memory symbol\n    ) ERC20Permit(name, symbol, SafeERC20Namer.tokenDecimals(address(IJoin(join_).asset()))) { // The join asset is this fyToken's underlying, from which we inherit the decimals\n        uint256 now_ = block.timestamp;\n        require(\n            maturity_ > now_ &&\n            maturity_ < now_ + MAX_TIME_TO_MATURITY &&\n            maturity_ < type(uint32).max,\n            \"Invalid maturity\"\n        );\n\n        underlyingId = underlyingId_;\n        join = join_;\n        maturity = maturity_;\n        underlying = address(IJoin(join_).asset());\n        oracle = oracle_;\n        emit OracleSet(address(oracle_));\n    }\n\n    modifier afterMaturity() {\n        require(\n            uint32(block.timestamp) >= maturity,\n            \"Only after maturity\"\n        );\n        _;\n    }\n\n    modifier beforeMaturity() {\n        require(\n            uint32(block.timestamp) < maturity,\n            \"Only before maturity\"\n        );\n        _;\n    }\n\n    /// @dev Set the oracle parameter\n    function setOracle(IOracle oracle_)\n        external\n        auth    \n    {\n        oracle = oracle_;\n        emit OracleSet(address(oracle_));\n    }\n\n    /// @dev Mature the fyToken by recording the chi.\n    /// If called more than once, it will revert.\n    function mature()\n        external override\n        afterMaturity\n    {\n        require (chiAtMaturity == CHI_NOT_SET, \"Already matured\");\n        _mature();\n    }\n\n    /// @dev Mature the fyToken by recording the chi.\n    function _mature() \n        private\n        returns (uint256 _chiAtMaturity)\n    {\n        (_chiAtMaturity,) = oracle.get(underlyingId, CHI, 1e18);\n        chiAtMaturity = _chiAtMaturity;\n        emit SeriesMatured(_chiAtMaturity);\n    }\n\n    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.\n    function accrual()\n        external\n        afterMaturity\n        returns (uint256)\n    {\n        return _accrual();\n    }\n\n    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual()\n        private\n        returns (uint256 accrual_)\n    {\n        if (chiAtMaturity == CHI_NOT_SET) {  // After maturity, but chi not yet recorded. Let's record it, and accrual is then 1.\n            _mature();\n        } else {\n            (uint256 chi,) = oracle.get(underlyingId, CHI, 1e18);\n            accrual_ = chi.wdiv(chiAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18;     // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Burn the fyToken after maturity for an amount that increases according to `chi`\n    function redeem(address to, uint256 amount)\n        external override\n        afterMaturity\n        returns (uint256 redeemed)\n    {\n        _burn(msg.sender, amount);\n        redeemed = amount.wmul(_accrual());\n        join.exit(to, redeemed.u128());\n        \n        emit Redeemed(msg.sender, to, amount, redeemed);\n    }\n\n    /// @dev Mint fyTokens.\n    function mint(address to, uint256 amount)\n        external override\n        beforeMaturity\n        auth\n    {\n        _mint(to, amount);\n    }\n\n    /// @dev Burn fyTokens. The user needs to have either transferred the tokens to this contract, or have approved this contract to take them. \n    function burn(address from, uint256 amount)\n        external override\n        auth\n    {\n        _burn(from, amount);\n    }\n\n    /// @dev Burn fyTokens. \n    /// Any tokens locked in this contract will be burned first and subtracted from the amount to burn from the user's wallet.\n    /// This feature allows someone to transfer fyToken to this contract to enable a `burn`, potentially saving the cost of `approve` or `permit`.\n    function _burn(address from, uint256 amount)\n        internal override\n        returns (bool)\n    {\n        // First use any tokens locked in this contract\n        uint256 available = _balanceOf[address(this)];\n        if (available >= amount) {\n            return super._burn(address(this), amount);\n        } else {\n            if (available > 0 ) super._burn(address(this), available);\n            unchecked { _decreaseAllowance(from, amount - available); }\n            unchecked { return super._burn(from, amount - available); }\n        }\n    }\n\n    /**\n     * @dev From ERC-3156. The amount of currency available to be lended.\n     * @param token The loan currency. It must be a FYDai contract.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token)\n        external view override\n        beforeMaturity\n        returns (uint256)\n    {\n        return token == address(this) ? type(uint256).max - _totalSupply : 0;\n    }\n\n    /**\n     * @dev From ERC-3156. The fee to be charged for a given loan.\n     * @param token The loan currency. It must be a FYDai.\n     * param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256)\n        external view override\n        beforeMaturity\n        returns (uint256)\n    {\n        require(token == address(this), \"Unsupported currency\");\n        return 0;\n    }\n\n    /**\n     * @dev From ERC-3156. Loan `amount` fyDai to `receiver`, which needs to return them plus fee to this contract within the same transaction.\n     * Note that if the initiator and the borrower are the same address, no approval is needed for this contract to take the principal + fee from the borrower.\n     * If the borrower transfers the principal + fee to this contract, they will be burnt here instead of pulled from the borrower.\n     * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n     * @param token The loan currency. Must be a fyDai contract.\n     * @param amount The amount of tokens lent.\n     * @param data A data parameter to be passed on to the `receiver` for any custom use.\n     */\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes memory data)\n        external override\n        beforeMaturity\n        returns(bool)\n    {\n        require(token == address(this), \"Unsupported currency\");\n        _mint(address(receiver), amount);\n        require(receiver.onFlashLoan(msg.sender, token, amount, 0, data) == FLASH_LOAN_RETURN, \"Non-compliant borrower\");\n        _burn(address(receiver), amount);\n        return true;\n    }\n}\nabstract contract ERC20Permit is ERC20, IERC2612 {\n    mapping (address => uint256) public override nonces;\n\n    bytes32 public immutable PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    uint256 public immutable deploymentChainId;\n\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_, decimals_) {\n        uint256 chainId;\n        assembly {chainId := chainid()}\n        deploymentChainId = chainId;\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(chainId);\n    }\n\n    /// @dev Calculate the DOMAIN_SEPARATOR.\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(version())),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    /// @dev Return the DOMAIN_SEPARATOR.\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        uint256 chainId;\n        assembly {chainId := chainid()}\n        return chainId == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\n    }\n\n    /// @dev Setting the version as a function so that it can be overriden\n    function version() public pure virtual returns(string memory) { return \"1\"; }\n\n    /**\n     * @dev See {IERC2612-permit}.\n     *\n     * In cases where the free option is not a concern, deadline can simply be\n     * set to uint(-1), so it should be seen as an optional parameter\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external virtual override {\n        require(deadline >= block.timestamp, \"ERC20Permit: expired deadline\");\n\n        uint256 chainId;\n        assembly {chainId := chainid()}\n\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                PERMIT_TYPEHASH,\n                owner,\n                spender,\n                amount,\n                nonces[owner]++,\n                deadline\n            )\n        );\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                chainId == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId),\n                hashStruct\n            )\n        );\n\n        address signer = ecrecover(hash, v, r, s);\n        require(\n            signer != address(0) && signer == owner,\n            \"ERC20Permit: invalid signature\"\n        );\n\n        _setAllowance(owner, spender, amount);\n    }\n}\ncontract FYTokenFactory is IFYTokenFactory, AccessControl {\n\n  /// @dev Deploys a new fyToken.\n  /// @return fyToken The fyToken address.\n  function createFYToken(\n    bytes6 baseId,\n    IOracle oracle,\n    IJoin baseJoin,\n    uint32 maturity,\n    string memory name,\n    string memory symbol\n  )\n    external override\n    auth\n    returns (address)\n  {\n    FYToken fyToken = new FYToken(\n      baseId,\n      oracle,\n      baseJoin,\n      maturity,\n      name,     // Derive from base and maturity, perhaps\n      symbol    // Derive from base and maturity, perhaps\n    );\n\n    fyToken.grantRole(fyToken.ROOT(), msg.sender);\n    fyToken.renounceRole(fyToken.ROOT(), address(this));\n    \n    emit FYTokenCreated(address(fyToken), baseJoin.asset(), maturity);\n\n    return address(fyToken);\n  }\n}contract JoinFactory is IJoinFactory, AccessControl {\n\n  /// @dev Deploys a new join.\n  /// @param asset Address of the asset token.\n  /// @return join The join address.\n  function createJoin(address asset)\n    external override\n    auth\n    returns (address)\n  {\n    Join join = new Join(asset);\n\n    join.grantRole(join.ROOT(), msg.sender);\n    join.renounceRole(join.ROOT(), address(this));\n    \n    emit JoinCreated(asset, address(join));\n\n    return address(join);\n  }\n}contract Wand is AccessControl, Constants {\n    using CastBytes32Bytes6 for bytes32;\n\n    event Point(bytes32 indexed param, address value);\n\n    bytes4 public constant JOIN = bytes4(keccak256(\"join(address,uint128)\"));\n    bytes4 public constant EXIT = bytes4(keccak256(\"exit(address,uint128)\"));\n    bytes4 public constant MINT = bytes4(keccak256(\"mint(address,uint256)\"));\n    bytes4 public constant BURN = bytes4(keccak256(\"burn(address,uint256)\"));\n\n    ICauldronGov public cauldron;\n    ILadleGov public ladle;\n    address public witch;\n    IPoolFactory public poolFactory;\n    IJoinFactory public joinFactory;\n    IFYTokenFactory public fyTokenFactory;\n\n    constructor (\n        ICauldronGov cauldron_,\n        ILadleGov ladle_,\n        address witch_,\n        IPoolFactory poolFactory_,\n        IJoinFactory joinFactory_,\n        IFYTokenFactory fyTokenFactory_\n    ) {\n        cauldron = cauldron_;\n        ladle = ladle_;\n        witch = witch_;\n        poolFactory = poolFactory_;\n        joinFactory = joinFactory_;\n        fyTokenFactory = fyTokenFactory_;\n    }\n\n    /// @dev Point to a different cauldron, ladle, witch, poolFactory, joinFactory or fyTokenFactory\n    function point(bytes32 param, address value) external auth {\n        if (param == \"cauldron\") cauldron = ICauldronGov(value);\n        else if (param == \"ladle\") ladle = ILadleGov(value);\n        else if (param == \"witch\") witch = value;\n        else if (param == \"poolFactory\") poolFactory = IPoolFactory(value);\n        else if (param == \"joinFactory\") joinFactory = IJoinFactory(value);\n        else if (param == \"fyTokenFactory\") fyTokenFactory = IFYTokenFactory(value);\n        else revert(\"Unrecognized parameter\");\n        emit Point(param, value);\n    }\n\n    /// @dev Add an existing asset to the protocol, meaning:\n    ///  - Add the asset to the cauldron\n    ///  - Deploy a new Join, and integrate it with the Ladle\n    ///  - If the asset is a base, integrate its rate source\n    ///  - If the asset is a base, integrate a spot source and set a debt ceiling for any provided ilks\n    function addAsset(\n        bytes6 assetId,\n        address asset\n    ) external auth {\n        // Add asset to cauldron, deploy new Join, and add it to the ladle\n        require (address(asset) != address(0), \"Asset required\");\n        cauldron.addAsset(assetId, asset);\n        AccessControl join = AccessControl(joinFactory.createJoin(asset));  // We need the access control methods of Join\n        bytes4[] memory sigs = new bytes4[](2);\n        sigs[0] = JOIN;\n        sigs[1] = EXIT;\n        join.grantRoles(sigs, address(ladle));\n        join.grantRole(join.ROOT(), msg.sender);\n        // join.renounceRole(join.ROOT(), address(this));  // Wand requires ongoing rights to set up permissions to joins\n        ladle.addJoin(assetId, address(join));\n    }\n\n    /// @dev Make a base asset out of a generic asset, by adding rate and chi oracles.\n    /// This assumes CompoundMultiOracles, which deliver both rate and chi.\n    function makeBase(bytes6 assetId, IMultiOracleGov oracle, address rateSource, address chiSource) external auth {\n        require (address(oracle) != address(0), \"Oracle required\");\n        require (rateSource != address(0), \"Rate source required\");\n        require (chiSource != address(0), \"Chi source required\");\n\n        oracle.setSource(assetId, RATE.b6(), rateSource);\n        oracle.setSource(assetId, CHI.b6(), chiSource);\n        cauldron.setRateOracle(assetId, IOracle(address(oracle)));\n        \n        AccessControl baseJoin = AccessControl(address(ladle.joins(assetId)));\n        baseJoin.grantRole(JOIN, witch); // Give the Witch permission to join base\n    }\n\n    /// @dev Make an ilk asset out of a generic asset, by adding a spot oracle against a base asset, collateralization ratio, and debt ceiling.\n    function makeIlk(bytes6 baseId, bytes6 ilkId, IMultiOracleGov oracle, address spotSource, uint32 ratio, uint96 max, uint24 min, uint8 dec) external auth {\n        oracle.setSource(baseId, ilkId, spotSource);\n        cauldron.setSpotOracle(baseId, ilkId, IOracle(address(oracle)), ratio);\n        cauldron.setDebtLimits(baseId, ilkId, max, min, dec);\n\n        AccessControl ilkJoin = AccessControl(address(ladle.joins(ilkId)));\n        ilkJoin.grantRole(EXIT, witch); // Give the Witch permission to exit ilk\n    }\n\n    /// @dev Add an existing series to the protocol, by deploying a FYToken, and registering it in the cauldron with the approved ilks\n    /// This must be followed by a call to addPool\n    function addSeries(\n        bytes6 seriesId,\n        bytes6 baseId,\n        uint32 maturity,\n        bytes6[] memory ilkIds,\n        string memory name,\n        string memory symbol\n    ) external auth {\n        address base = cauldron.assets(baseId);\n        require(base != address(0), \"Base not found\");\n\n        IJoin baseJoin = ladle.joins(baseId);\n        require(address(baseJoin) != address(0), \"Join not found\");\n\n        IOracle oracle = cauldron.rateOracles(baseId);\n        require(address(oracle) != address(0), \"Chi oracle not found\");\n\n        AccessControl fyToken = AccessControl(fyTokenFactory.createFYToken(\n            baseId,\n            oracle,\n            baseJoin,\n            maturity,\n            name,     // Derive from base and maturity, perhaps\n            symbol    // Derive from base and maturity, perhaps\n        ));\n\n        // Allow the fyToken to pull from the base join for redemption\n        bytes4[] memory sigs = new bytes4[](1);\n        sigs[0] = EXIT;\n        AccessControl(address(baseJoin)).grantRoles(sigs, address(fyToken));\n\n        // Allow the ladle to issue and cancel fyToken\n        sigs = new bytes4[](2);\n        sigs[0] = MINT;\n        sigs[1] = BURN;\n        fyToken.grantRoles(sigs, address(ladle));\n\n        // Pass ownership of the fyToken to msg.sender\n        fyToken.grantRole(fyToken.ROOT(), msg.sender);\n        fyToken.renounceRole(fyToken.ROOT(), address(this));\n\n        // Add fyToken/series to the Cauldron and approve ilks for the series\n        cauldron.addSeries(seriesId, baseId, IFYToken(address(fyToken)));\n        cauldron.addIlks(seriesId, ilkIds);\n\n        // Create the pool for the base and fyToken\n        poolFactory.createPool(base, address(fyToken));\n        IOwnable pool = IOwnable(poolFactory.calculatePoolAddress(base, address(fyToken)));\n        \n\n        // Pass ownership of pool to msg.sender\n        pool.transferOwnership(msg.sender);\n\n        // Register pool in Ladle\n        ladle.addPool(seriesId, address(pool));\n    }\n}contract LadleStorage {\n    ICauldron public immutable cauldron;\n    uint256 public borrowingFee;\n\n    mapping (bytes6 => IJoin)                   public joins;            // Join contracts available to manage assets. The same Join can serve multiple assets (ETH-A, ETH-B, etc...)\n    mapping (bytes6 => IPool)                   public pools;            // Pool contracts available to manage series. 12 bytes still free.\n    mapping (address => bool)                   public modules;          // Trusted contracts to execute anything on.\n\n    event JoinAdded(bytes6 indexed assetId, address indexed join);\n    event PoolAdded(bytes6 indexed seriesId, address indexed pool);\n    event ModuleSet(address indexed module, bool indexed set);\n    event FeeSet(uint256 fee);\n\n    constructor (ICauldron cauldron_) {\n        cauldron = cauldron_;\n    }\n}contract ERC20 is IERC20Metadata {\n    uint256                                           internal  _totalSupply;\n    mapping (address => uint256)                      internal  _balanceOf;\n    mapping (address => mapping (address => uint256)) internal  _allowance;\n    string                                            public override name = \"???\";\n    string                                            public override symbol = \"???\";\n    uint8                                             public override decimals = 18;\n\n    /**\n     *  @dev Sets the values for {name}, {symbol} and {decimals}.\n     */\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() external view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address guy) external view virtual override returns (uint256) {\n        return _balanceOf[guy];\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) external view virtual override returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     */\n    function approve(address spender, uint wad) external virtual override returns (bool) {\n        return _setAllowance(msg.sender, spender, wad);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - the caller must have a balance of at least `wad`.\n     */\n    function transfer(address dst, uint wad) external virtual override returns (bool) {\n        return _transfer(msg.sender, dst, wad);\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `src` must have a balance of at least `wad`.\n     * - the caller is not `src`, it must have allowance for ``src``'s tokens of at least\n     * `wad`.\n     */\n    /// if_succeeds {:msg \"TransferFrom - decrease allowance\"} msg.sender != src ==> old(_allowance[src][msg.sender]) >= wad;\n    function transferFrom(address src, address dst, uint wad) external virtual override returns (bool) {\n        _decreaseAllowance(src, wad);\n\n        return _transfer(src, dst, wad);\n    }\n\n    /**\n     * @dev Moves tokens `wad` from `src` to `dst`.\n     * \n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `src` must have a balance of at least `amount`.\n     */\n    /// if_succeeds {:msg \"Transfer - src decrease\"} old(_balanceOf[src]) >= _balanceOf[src];\n    /// if_succeeds {:msg \"Transfer - dst increase\"} _balanceOf[dst] >= old(_balanceOf[dst]);\n    /// if_succeeds {:msg \"Transfer - supply\"} old(_balanceOf[src]) + old(_balanceOf[dst]) == _balanceOf[src] + _balanceOf[dst];\n    function _transfer(address src, address dst, uint wad) internal virtual returns (bool) {\n        require(_balanceOf[src] >= wad, \"ERC20: Insufficient balance\");\n        unchecked { _balanceOf[src] = _balanceOf[src] - wad; }\n        _balanceOf[dst] = _balanceOf[dst] + wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    /**\n     * @dev Sets the allowance granted to `spender` by `owner`.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     */\n    function _setAllowance(address owner, address spender, uint wad) internal virtual returns (bool) {\n        _allowance[owner][spender] = wad;\n        emit Approval(owner, spender, wad);\n\n        return true;\n    }\n\n    /**\n     * @dev Decreases the allowance granted to the caller by `src`, unless src == msg.sender or _allowance[src][msg.sender] == MAX\n     *\n     * Emits an {Approval} event indicating the updated allowance, if the allowance is updated.\n     *\n     * Requirements:\n     *\n     * - `spender` must have allowance for the caller of at least\n     * `wad`, unless src == msg.sender\n     */\n    /// if_succeeds {:msg \"Decrease allowance - underflow\"} old(_allowance[src][msg.sender]) <= _allowance[src][msg.sender];\n    function _decreaseAllowance(address src, uint wad) internal virtual returns (bool) {\n        if (src != msg.sender) {\n            uint256 allowed = _allowance[src][msg.sender];\n            if (allowed != type(uint).max) {\n                require(allowed >= wad, \"ERC20: Insufficient approval\");\n                unchecked { _setAllowance(src, msg.sender, allowed - wad); }\n            }\n        }\n\n        return true;\n    }\n\n    /** @dev Creates `wad` tokens and assigns them to `dst`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     */\n    /// if_succeeds {:msg \"Mint - balance overflow\"} old(_balanceOf[dst]) >= _balanceOf[dst];\n    /// if_succeeds {:msg \"Mint - supply overflow\"} old(_totalSupply) >= _totalSupply;\n    function _mint(address dst, uint wad) internal virtual returns (bool) {\n        _balanceOf[dst] = _balanceOf[dst] + wad;\n        _totalSupply = _totalSupply + wad;\n        emit Transfer(address(0), dst, wad);\n\n        return true;\n    }\n\n    /**\n     * @dev Destroys `wad` tokens from `src`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `src` must have at least `wad` tokens.\n     */\n    /// if_succeeds {:msg \"Burn - balance underflow\"} old(_balanceOf[src]) <= _balanceOf[src];\n    /// if_succeeds {:msg \"Burn - supply underflow\"} old(_totalSupply) <= _totalSupply;\n    function _burn(address src, uint wad) internal virtual returns (bool) {\n        unchecked {\n            require(_balanceOf[src] >= wad, \"ERC20: Insufficient balance\");\n            _balanceOf[src] = _balanceOf[src] - wad;\n            _totalSupply = _totalSupply - wad;\n            emit Transfer(src, address(0), wad);\n        }\n\n        return true;\n    }\n}contract Constants {\n    bytes32 CHI = \"chi\";\n    bytes32 RATE = \"rate\";\n}contract Witch is AccessControl() {\n    using WMul for uint256;\n    using WDiv for uint256;\n    using WDivUp for uint256;\n    using CastU256U128 for uint256;\n    using CastU256U32 for uint256;\n\n    event IlkSet(bytes6 indexed ilkId, uint32 duration, uint64 initialOffer, uint128 dust);\n    event Bought(bytes12 indexed vaultId, address indexed buyer, uint256 ink, uint256 art);\n    event Auctioned(bytes12 indexed vaultId, uint256 indexed start);\n  \n    struct Auction {\n        address owner;\n        uint32 start;\n    }\n\n    struct Ilk {\n        uint32 duration;      // Time that auctions take to go to minimal price and stay there.\n        uint64 initialOffer;  // Proportion of collateral that is sold at auction start (1e18 = 100%)\n        uint128 dust;         // Minimum collateral that must be left when buying, unless buying all\n    }\n\n    // uint32 public duration = 4 * 60 * 60; // Time that auctions take to go to minimal price and stay there.\n    // uint64 public initialOffer = 5e17;  // Proportion of collateral that is sold at auction start (1e18 = 100%)\n    // uint128 public dust;                     // Minimum collateral that must be left when buying, unless buying all\n\n    ICauldron immutable public cauldron;\n    ILadle immutable public ladle;\n    mapping(bytes12 => Auction) public auctions;\n    mapping(bytes6 => Ilk) public ilks;\n\n    constructor (ICauldron cauldron_, ILadle ladle_) {\n        cauldron = cauldron_;\n        ladle = ladle_;\n    }\n\n    /// @dev Set the auction duration to calculate liquidation prices\n    /* function setDuration(uint32 duration_) external auth {\n        duration = duration_;\n        emit DurationSet(duration_);\n    }\n\n    /// @dev Set the proportion of the collateral that will be sold at auction start\n    function setInitialOffer(uint64 initialOffer_) external auth {\n        require (initialOffer_ <= 1e18, \"Only at or under 100%\");\n        initialOffer = initialOffer_;\n        emit InitialOfferSet(initialOffer_);\n    }\n\n    /// @dev Set the minimum collateral that must be left when buying, unless buying all\n    function setDust(uint128 dust_) external auth {\n        dust = dust_;\n        emit DustSet(dust_);\n    } */\n\n    /// @dev Set:\n    ///  - the auction duration to calculate liquidation prices\n    ///  - the proportion of the collateral that will be sold at auction start\n    ///  - the minimum collateral that must be left when buying, unless buying all\n    function setIlk(bytes6 ilkId, uint32 duration, uint64 initialOffer, uint128 dust) external auth {\n        require (initialOffer <= 1e18, \"Only at or under 100%\");\n        ilks[ilkId] = Ilk({\n            duration: duration,\n            initialOffer: initialOffer,\n            dust: dust\n        });\n        emit IlkSet(ilkId, duration, initialOffer, dust);\n    }\n\n    /// @dev Put an undercollateralized vault up for liquidation.\n    function auction(bytes12 vaultId)\n        external\n    {\n        require (auctions[vaultId].start == 0, \"Vault already under auction\");\n        DataTypes.Vault memory vault = cauldron.vaults(vaultId);\n        auctions[vaultId] = Auction({\n            owner: vault.owner,\n            start: block.timestamp.u32()\n        });\n        cauldron.grab(vaultId, address(this));\n        emit Auctioned(vaultId, block.timestamp.u32());\n    }\n\n    /// @dev Pay `base` of the debt in a vault in liquidation, getting at least `min` collateral.\n    function buy(bytes12 vaultId, uint128 base, uint128 min)\n        external\n        returns (uint256 ink)\n    {\n        DataTypes.Balances memory balances_ = cauldron.balances(vaultId);\n        DataTypes.Vault memory vault_ = cauldron.vaults(vaultId);\n        DataTypes.Series memory series_ = cauldron.series(vault_.seriesId);\n        Auction memory auction_ = auctions[vaultId];\n        Ilk memory ilk_ = ilks[vault_.ilkId];\n\n        require (balances_.art > 0, \"Nothing to buy\");                                      // Cheapest way of failing gracefully if given a non existing vault\n        uint256 art = cauldron.debtFromBase(vault_.seriesId, base);\n        {\n            uint256 elapsed = uint32(block.timestamp) - auction_.start;                      // Auctions will malfunction on the 7th of February 2106, at 06:28:16 GMT, we should replace this contract before then.\n            uint256 price = inkPrice(balances_, ilk_.initialOffer, ilk_.duration, elapsed);\n            ink = uint256(art).wmul(price);                                                    // Calculate collateral to sell. Using divdrup stops rounding from leaving 1 stray wei in vaults.\n            require (ink >= min, \"Not enough bought\");\n            require (ink == balances_.ink || balances_.ink - ink >= ilk_.dust, \"Leaves dust\");\n        }\n\n        cauldron.slurp(vaultId, ink.u128(), art.u128());                                            // Remove debt and collateral from the vault\n        settle(msg.sender, vault_.ilkId, series_.baseId, ink.u128(), base);                   // Move the assets\n        if (balances_.art - art == 0) {                                                             // If there is no debt left, return the vault with the collateral to the owner\n            cauldron.give(vaultId, auction_.owner);\n            delete auctions[vaultId];\n        }\n\n        emit Bought(vaultId, msg.sender, ink, art);\n    }\n\n\n    /// @dev Pay all debt from a vault in liquidation, getting at least `min` collateral.\n    function payAll(bytes12 vaultId, uint128 min)\n        external\n        returns (uint256 ink)\n    {\n        DataTypes.Balances memory balances_ = cauldron.balances(vaultId);\n        DataTypes.Vault memory vault_ = cauldron.vaults(vaultId);\n        DataTypes.Series memory series_ = cauldron.series(vault_.seriesId);\n        Auction memory auction_ = auctions[vaultId];\n        Ilk memory ilk_ = ilks[vault_.ilkId];\n\n        require (balances_.art > 0, \"Nothing to buy\");                                      // Cheapest way of failing gracefully if given a non existing vault\n        {\n            uint256 elapsed = uint32(block.timestamp) - auction_.start;                      // Auctions will malfunction on the 7th of February 2106, at 06:28:16 GMT, we should replace this contract before then.\n            uint256 price = inkPrice(balances_, ilk_.initialOffer, ilk_.duration, elapsed);\n            ink = uint256(balances_.art).wmul(price);                                                    // Calculate collateral to sell. Using divdrup stops rounding from leaving 1 stray wei in vaults.\n            require (ink >= min, \"Not enough bought\");\n            require (ink == balances_.ink || balances_.ink - ink >= ilk_.dust, \"Leaves dust\");\n        }\n\n        cauldron.slurp(vaultId, ink.u128(), balances_.art);                                                     // Remove debt and collateral from the vault\n        settle(msg.sender, vault_.ilkId, series_.baseId, ink.u128(), cauldron.debtToBase(vault_.seriesId, balances_.art));                                        // Move the assets\n        cauldron.give(vaultId, auction_.owner);\n\n        emit Bought(vaultId, msg.sender, ink, balances_.art); // Still the initially read `art` value, not the updated one\n    }\n\n    /// @dev Move base from the buyer to the protocol, and collateral from the protocol to the buyer\n    function settle(address user, bytes6 ilkId, bytes6 baseId, uint128 ink, uint128 art)\n        private\n    {\n        if (ink != 0) {                                                                     // Give collateral to the user\n            IJoin ilkJoin = ladle.joins(ilkId);\n            require (ilkJoin != IJoin(address(0)), \"Join not found\");\n            ilkJoin.exit(user, ink);\n        }\n        if (art != 0) {                                                                     // Take underlying from user\n            IJoin baseJoin = ladle.joins(baseId);\n            require (baseJoin != IJoin(address(0)), \"Join not found\");\n            baseJoin.join(user, art);\n        }    \n    }\n\n    /// @dev Price of a collateral unit, in underlying, at the present moment, for a given vault\n    ///            ink                     min(auction, elapsed)\n    /// price = (------- * (p + (1 - p) * -----------------------))\n    ///            art                          auction\n    function inkPrice(DataTypes.Balances memory balances, uint256 initialOffer_, uint256 duration_, uint256 elapsed)\n        private pure\n        returns (uint256 price)\n    {\n            uint256 term1 = uint256(balances.ink).wdiv(balances.art);\n            uint256 dividend2 = duration_ < elapsed ? duration_ : elapsed;\n            uint256 divisor2 = duration_;\n            uint256 term2 = initialOffer_ + (1e18 - initialOffer_).wmul(dividend2.wdiv(divisor2));\n            price = term1.wmul(term2);\n    }\n}contract Ladle is LadleStorage, AccessControl() {\n    using WMul for uint256;\n    using CastU256U128 for uint256;\n    using CastU128I128 for uint128;\n    using TransferHelper for IERC20;\n    using TransferHelper for address payable;\n\n    bytes12 cachedVaultId;\n\n    IWETH9 public immutable weth;\n\n    constructor (ICauldron cauldron, IWETH9 weth_) LadleStorage(cauldron) {\n        weth = weth_;\n    }\n\n    // ---- Data sourcing ----\n    /// @dev Obtains a vault by vaultId from the Cauldron, and verifies that msg.sender is the owner\n    /// If bytes(0) is passed as the vaultId it tries to load a vault from the cache\n    function getVault(bytes12 vaultId_)\n        internal view\n        returns (bytes12 vaultId, DataTypes.Vault memory vault)\n    {\n        if (vaultId_ == bytes12(0)) { // We use the cache\n            require (cachedVaultId != bytes12(0), \"Vault not cached\");\n            vaultId = cachedVaultId;\n        } else {\n            vaultId = vaultId_;\n        }\n        vault = cauldron.vaults(vaultId);\n        require (vault.owner == msg.sender, \"Only vault owner\");\n    } \n    /// @dev Obtains a series by seriesId from the Cauldron, and verifies that it exists\n    function getSeries(bytes6 seriesId)\n        internal view returns(DataTypes.Series memory series)\n    {\n        series = cauldron.series(seriesId);\n        require (series.fyToken != IFYToken(address(0)), \"Series not found\");\n    }\n\n    /// @dev Obtains a join by assetId, and verifies that it exists\n    function getJoin(bytes6 assetId)\n        internal view returns(IJoin join)\n    {\n        join = joins[assetId];\n        require (join != IJoin(address(0)), \"Join not found\");\n    }\n\n    /// @dev Obtains a pool by seriesId, and verifies that it exists\n    function getPool(bytes6 seriesId)\n        internal view returns(IPool pool)\n    {\n        pool = pools[seriesId];\n        require (pool != IPool(address(0)), \"Pool not found\");\n    }\n\n    // ---- Administration ----\n\n    /// @dev Add a new Join for an Asset, or replace an existing one for a new one.\n    /// There can be only one Join per Asset. Until a Join is added, no tokens of that Asset can be posted or withdrawn.\n    function addJoin(bytes6 assetId, IJoin join)\n        external\n        auth\n    {\n        address asset = cauldron.assets(assetId);\n        require (asset != address(0), \"Asset not found\");\n        require (join.asset() == asset, \"Mismatched asset and join\");\n        joins[assetId] = join;\n        emit JoinAdded(assetId, address(join));\n    }\n\n    /// @dev Add a new Pool for a Series, or replace an existing one for a new one.\n    /// There can be only one Pool per Series. Until a Pool is added, it is not possible to borrow Base.\n    function addPool(bytes6 seriesId, IPool pool)\n        external\n        auth\n    {\n        IFYToken fyToken = getSeries(seriesId).fyToken;\n        require (fyToken == pool.fyToken(), \"Mismatched pool fyToken and series\");\n        require (fyToken.underlying() == address(pool.base()), \"Mismatched pool base and series\");\n        pools[seriesId] = pool;\n        emit PoolAdded(seriesId, address(pool));\n    }\n\n    /// @dev Add or remove a module.\n    function setModule(address module, bool set)\n        external\n        auth\n    {\n        modules[module] = set;\n        emit ModuleSet(module, set);\n    }\n\n    /// @dev Set the fee parameter\n    function setFee(uint256 fee)\n        external\n        auth\n    {\n        borrowingFee = fee;\n        emit FeeSet(fee);\n    }\n\n    // ---- Batching ----\n\n    /// @dev Allows batched call to self (this contract).\n    /// @param calls An array of inputs for each call.\n    function batch(bytes[] calldata calls) external payable returns(bytes[] memory results) {\n        results = new bytes[](calls.length);\n        for (uint256 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n            if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n            results[i] = result;\n        }\n\n        // build would have populated the cache, this deletes it\n        cachedVaultId = bytes12(0);\n    }\n\n    // ---- Vault management ----\n\n    /// @dev Generate a vaultId. A keccak256 is cheaper than using a counter with a SSTORE, even accounting for eventual collision retries.\n    function _generateVaultId(uint8 salt) private view returns (bytes12) {\n        return bytes12(keccak256(abi.encodePacked(msg.sender, block.timestamp, salt)));\n    }\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function build(bytes6 seriesId, bytes6 ilkId, uint8 salt)\n        external payable\n        returns(bytes12, DataTypes.Vault memory)\n    {\n        return _build(seriesId, ilkId, salt);\n    }\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    // TODO: Include a function that doesn't cache the vault\n    function _build(bytes6 seriesId, bytes6 ilkId, uint8 salt)\n        private\n        returns(bytes12, DataTypes.Vault memory)\n    {\n        bytes12 vaultId = _generateVaultId(salt);\n        try cauldron.build(msg.sender, vaultId, seriesId, ilkId) returns (DataTypes.Vault memory vault) {\n            // Store the vault data in the cache\n            cachedVaultId = vaultId;\n            return (vaultId, vault);\n        } catch Error (string memory) {\n            return _build(seriesId, ilkId, salt + 1);\n        }\n    }\n\n    /// @dev Change a vault series or collateral.\n    function tweak(bytes12 vaultId_, bytes6 seriesId, bytes6 ilkId)\n        external payable\n        returns(DataTypes.Vault memory vault)\n    {\n        (bytes12 vaultId, ) = getVault(vaultId_); // getVault verifies the ownership as well\n        // tweak checks that the series and the collateral both exist and that the collateral is approved for the series\n        vault = cauldron.tweak(vaultId, seriesId, ilkId);\n    }\n\n    /// @dev Give a vault to another user.\n    function give(bytes12 vaultId_, address receiver)\n        external payable\n        returns(DataTypes.Vault memory vault)\n    {\n        (bytes12 vaultId, ) = getVault(vaultId_);\n        vault = cauldron.give(vaultId, receiver);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function destroy(bytes12 vaultId_)\n        external payable\n    {\n        (bytes12 vaultId, ) = getVault(vaultId_);\n        cauldron.destroy(vaultId);\n    }\n\n    // ---- Asset and debt management ----\n\n    /// @dev Move collateral and debt between vaults.\n    function stir(bytes12 from, bytes12 to, uint128 ink, uint128 art)\n        external payable\n    {\n        if (ink > 0) require (cauldron.vaults(from).owner == msg.sender, \"Only origin vault owner\");\n        if (art > 0) require (cauldron.vaults(to).owner == msg.sender, \"Only destination vault owner\");\n        cauldron.stir(from, to, ink, art);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    /// Borrow only before maturity.\n    function _pour(bytes12 vaultId, DataTypes.Vault memory vault, address to, int128 ink, int128 art)\n        private\n    {\n        DataTypes.Series memory series;\n        if (art != 0) series = getSeries(vault.seriesId);\n\n        int128 fee;\n        if (art > 0) fee = ((series.maturity - block.timestamp) * uint256(int256(art)).wmul(borrowingFee)).u128().i128();\n\n        // Update accounting\n        cauldron.pour(vaultId, ink, art + fee);\n\n        // Manage collateral\n        if (ink != 0) {\n            IJoin ilkJoin = getJoin(vault.ilkId);\n            if (ink > 0) ilkJoin.join(vault.owner, uint128(ink));\n            if (ink < 0) ilkJoin.exit(to, uint128(-ink));\n        }\n\n        // Manage debt tokens\n        if (art != 0) {\n            if (art > 0) series.fyToken.mint(to, uint128(art));\n            else series.fyToken.burn(msg.sender, uint128(-art));\n        }\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    /// Borrow only before maturity.\n    function pour(bytes12 vaultId_, address to, int128 ink, int128 art)\n        external payable\n    {\n        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);\n        _pour(vaultId, vault, to, ink, art);\n    }\n\n    /// @dev Add collateral and borrow from vault, so that a precise amount of base is obtained by the user.\n    /// The base is obtained by borrowing fyToken and buying base with it in a pool.\n    /// Only before maturity.\n    function serve(bytes12 vaultId_, address to, uint128 ink, uint128 base, uint128 max)\n        external payable\n        returns (uint128 art)\n    {\n        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);\n        IPool pool = getPool(vault.seriesId);\n        \n        art = pool.buyBasePreview(base);\n        _pour(vaultId, vault, address(pool), ink.i128(), art.i128());\n        pool.buyBase(to, base, max);\n    }\n\n    /// @dev Repay vault debt using underlying token at a 1:1 exchange rate, without trading in a pool.\n    /// It can add or remove collateral at the same time.\n    /// The debt to repay is denominated in fyToken, even if the tokens pulled from the user are underlying.\n    /// The debt to repay must be entered as a negative number, as with `pour`.\n    /// Debt cannot be acquired with this function.\n    function close(bytes12 vaultId_, address to, int128 ink, int128 art)\n        external payable\n        returns (uint128 base)\n    {\n        require (art < 0, \"Only repay debt\");                                          // When repaying debt in `frob`, art is a negative value. Here is the same for consistency.\n\n        // Calculate debt in fyToken terms\n        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        base = cauldron.debtToBase(vault.seriesId, uint128(-art));\n\n        // Update accounting\n        cauldron.pour(vaultId, ink, art);\n\n        // Manage collateral\n        if (ink != 0) {\n            IJoin ilkJoin = getJoin(vault.ilkId);\n            if (ink > 0) ilkJoin.join(vault.owner, uint128(ink));\n            if (ink < 0) ilkJoin.exit(to, uint128(-ink));\n        }\n\n        // Manage underlying\n        IJoin baseJoin = getJoin(series.baseId);\n        baseJoin.join(msg.sender, base);\n    }\n\n    /// @dev Repay debt by selling base in a pool and using the resulting fyToken\n    /// The base tokens need to be already in the pool, unaccounted for.\n    /// Only before maturity. After maturity use close.\n    function repay(bytes12 vaultId_, address to, int128 ink, uint128 min)\n        external payable\n        returns (uint128 art)\n    {\n        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        IPool pool = getPool(vault.seriesId);\n\n        art = pool.sellBase(address(series.fyToken), min);\n        _pour(vaultId, vault, to, ink, -(art.i128()));\n    }\n\n    /// @dev Repay all debt in a vault by buying fyToken from a pool with base.\n    /// The base tokens need to be already in the pool, unaccounted for. The surplus base will be returned to msg.sender.\n    /// Only before maturity. After maturity use close.\n    function repayVault(bytes12 vaultId_, address to, int128 ink, uint128 max)\n        external payable\n        returns (uint128 base)\n    {\n        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        IPool pool = getPool(vault.seriesId);\n\n        DataTypes.Balances memory balances = cauldron.balances(vaultId);\n        base = pool.buyFYToken(address(series.fyToken), balances.art, max);\n        _pour(vaultId, vault, to, ink, -(balances.art.i128()));\n        pool.retrieveBase(msg.sender);\n    }\n\n    /// @dev Change series and debt of a vault.\n    function roll(bytes12 vaultId_, bytes6 newSeriesId, uint8 loan, uint128 max)\n        external payable\n        returns (DataTypes.Vault memory vault, uint128 newDebt)\n    {\n        bytes12 vaultId;\n        (vaultId, vault) = getVault(vaultId_);\n        DataTypes.Balances memory balances = cauldron.balances(vaultId);\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        DataTypes.Series memory newSeries = getSeries(newSeriesId);\n        \n        \n        {\n            IPool pool = getPool(newSeriesId);\n            IFYToken fyToken = IFYToken(newSeries.fyToken);\n            IJoin baseJoin = getJoin(series.baseId);\n\n            // Calculate debt in fyToken terms\n            uint128 base = cauldron.debtToBase(vault.seriesId, balances.art);\n\n            // Mint fyToken to the pool, as a kind of flash loan\n            fyToken.mint(address(pool), base * loan);                // Loan is the size of the flash loan relative to the debt amount, 2 should be safe most of the time\n\n            // Buy the base required to pay off the debt in series 1, and find out the debt in series 2\n            newDebt = pool.buyBase(address(baseJoin), base, max);\n            baseJoin.join(address(baseJoin), base);                  // Repay the old series debt\n\n            pool.retrieveFYToken(address(fyToken));                 // Get the surplus fyToken\n            fyToken.burn(address(fyToken), (base * loan) - newDebt);    // Burn the surplus\n        }\n\n        newDebt += ((newSeries.maturity - block.timestamp) * uint256(newDebt).wmul(borrowingFee)).u128();  // Add borrowing fee, also stops users form rolling to a mature series\n\n        (vault,) = cauldron.roll(vaultId, newSeriesId, newDebt.i128() - balances.art.i128()); // Change the series and debt for the vault\n\n        return (vault, newDebt);\n    }\n\n    // ---- Ladle as a token holder ----\n\n    /// @dev Use fyToken in the Ladle to repay debt.\n    function repayLadle(bytes12 vaultId_)\n        external payable\n        returns (uint256 repaid)\n    {\n        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        DataTypes.Balances memory balances = cauldron.balances(vaultId);\n        \n        uint256 amount = series.fyToken.balanceOf(address(this));\n        repaid = amount <= balances.art ? amount : balances.art;\n\n        // Update accounting\n        cauldron.pour(vaultId, 0, -(repaid.u128().i128()));\n        series.fyToken.burn(address(this), repaid);\n    }\n\n    /// @dev Retrieve any asset or fyToken in the Ladle\n    function retrieve(bytes6 id, bool isAsset, address to) \n        external payable\n        returns (uint256 amount)\n    {\n        IERC20 token = IERC20(findToken(id, isAsset));\n        amount = token.balanceOf(address(this));\n        token.safeTransfer(to, amount);\n    }\n\n    // ---- Permit management ----\n\n    /// @dev From an id, which can be an assetId or a seriesId, find the resulting asset or fyToken\n    function findToken(bytes6 id, bool isAsset)\n        private view returns (address token)\n    {\n        token = isAsset ? cauldron.assets(id) : address(getSeries(id).fyToken);\n        require (token != address(0), \"Token not found\");\n    }\n\n    /// @dev Execute an ERC2612 permit for the selected asset or fyToken\n    function forwardPermit(bytes6 id, bool isAsset, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external payable\n    {\n        IERC2612 token = IERC2612(findToken(id, isAsset));\n        token.permit(msg.sender, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Execute a Dai-style permit for the selected asset or fyToken\n    function forwardDaiPermit(bytes6 id, bool isAsset, address spender, uint256 nonce, uint256 deadline, bool allowed, uint8 v, bytes32 r, bytes32 s)\n        external payable\n    {\n        DaiAbstract token = DaiAbstract(findToken(id, isAsset));\n        token.permit(msg.sender, spender, nonce, deadline, allowed, v, r, s);\n    }\n\n    // ---- Ether management ----\n\n    /// @dev The WETH9 contract will send ether to BorrowProxy on `weth.withdraw` using this function.\n    receive() external payable { \n        require (msg.sender == address(weth), \"Only receive from WETH\");\n    }\n\n    /// @dev Accept Ether, wrap it and forward it to the WethJoin\n    /// This function should be called first in a batch, and the Join should keep track of stored reserves\n    /// Passing the id for a join that doesn't link to a contract implemnting IWETH9 will fail\n    function joinEther(bytes6 etherId)\n        external payable\n        returns (uint256 ethTransferred)\n    {\n        ethTransferred = address(this).balance;\n        IJoin wethJoin = getJoin(etherId);\n        weth.deposit{ value: ethTransferred }();\n        IERC20(address(weth)).safeTransfer(address(wethJoin), ethTransferred);\n    }\n\n    /// @dev Unwrap Wrapped Ether held by this Ladle, and send the Ether\n    /// This function should be called last in a batch, and the Ladle should have no reason to keep an WETH balance\n    function exitEther(address payable to)\n        external payable\n        returns (uint256 ethTransferred)\n    {\n        ethTransferred = weth.balanceOf(address(this));\n        weth.withdraw(ethTransferred);\n        to.safeTransferETH(ethTransferred);\n    }\n\n    // ---- Pool router ----\n\n    /// @dev Allow users to trigger a token transfer to a pool through the ladle, to be used with batch\n    function transferToPool(bytes6 seriesId, bool isBase, uint128 wad)\n        external payable\n    {\n        IPool pool = getPool(seriesId);\n        IERC20 token = isBase ? pool.base() : pool.fyToken();\n        token.safeTransferFrom(msg.sender, address(pool), wad);\n    }\n\n    /// @dev Allow users to route calls to a pool, to be used with batch\n    function route(bytes6 seriesId, bytes memory data)\n        external payable\n        returns (bytes memory result)\n    {\n        address pool = address(getPool(seriesId));\n        bool success;\n        (success, result) = pool.call(data);\n        if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n    }\n\n    // ---- FYToken router ----\n\n    /// @dev Allow users to trigger a token transfer to a fyToken through the ladle, to be used with batch\n    function transferToFYToken(bytes6 seriesId, uint256 wad)\n        external payable\n    {\n        address fyToken = address(getSeries(seriesId).fyToken);\n        IERC20(fyToken).safeTransferFrom(msg.sender, address(fyToken), wad);\n    }\n\n    /// @dev Allow users to redeem fyToken, to be used with batch.\n    /// If 0 is passed as the amount to redeem, it redeems the fyToken balance of the Ladle instead.\n    function redeem(bytes6 seriesId, address to, uint256 wad)\n        external payable\n        returns (uint256)\n    {\n        IFYToken fyToken = getSeries(seriesId).fyToken;\n        return fyToken.redeem(to, wad != 0 ? wad : fyToken.balanceOf(address(this)));\n    }\n\n    // ---- Module router ----\n\n    /// @dev Allow users to use functionality coded in a module, to be used with batch\n    /// @notice Modules must not do any changes to the vault (owner, seriesId, ilkId),\n    /// it would be disastrous in combination with batch vault caching \n    function moduleCall(address module, bytes memory data)\n        external payable\n        returns (bytes memory result)\n    {\n        require (modules[module], \"Unregistered module\");\n        bool success;\n        (success, result) = module.delegatecall(data);\n        if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n    }\n}",
    "bin": []
}