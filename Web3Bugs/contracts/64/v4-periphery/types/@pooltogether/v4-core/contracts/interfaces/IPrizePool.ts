/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../../../common";

export interface IPrizePoolInterface extends utils.Interface {
  functions: {
    "award(address,uint256)": FunctionFragment;
    "awardBalance()": FunctionFragment;
    "awardExternalERC20(address,address,uint256)": FunctionFragment;
    "awardExternalERC721(address,address,uint256[])": FunctionFragment;
    "balance()": FunctionFragment;
    "canAwardExternal(address)": FunctionFragment;
    "captureAwardBalance()": FunctionFragment;
    "compLikeDelegate(address,address)": FunctionFragment;
    "depositTo(address,uint256)": FunctionFragment;
    "depositToAndDelegate(address,uint256,address)": FunctionFragment;
    "getAccountedBalance()": FunctionFragment;
    "getBalanceCap()": FunctionFragment;
    "getLiquidityCap()": FunctionFragment;
    "getPrizeStrategy()": FunctionFragment;
    "getTicket()": FunctionFragment;
    "getToken()": FunctionFragment;
    "isControlled(address)": FunctionFragment;
    "setBalanceCap(uint256)": FunctionFragment;
    "setLiquidityCap(uint256)": FunctionFragment;
    "setPrizeStrategy(address)": FunctionFragment;
    "setTicket(address)": FunctionFragment;
    "transferExternalERC20(address,address,uint256)": FunctionFragment;
    "withdrawFrom(address,uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "award"
      | "awardBalance"
      | "awardExternalERC20"
      | "awardExternalERC721"
      | "balance"
      | "canAwardExternal"
      | "captureAwardBalance"
      | "compLikeDelegate"
      | "depositTo"
      | "depositToAndDelegate"
      | "getAccountedBalance"
      | "getBalanceCap"
      | "getLiquidityCap"
      | "getPrizeStrategy"
      | "getTicket"
      | "getToken"
      | "isControlled"
      | "setBalanceCap"
      | "setLiquidityCap"
      | "setPrizeStrategy"
      | "setTicket"
      | "transferExternalERC20"
      | "withdrawFrom"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "award",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "awardBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "awardExternalERC20",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "awardExternalERC721",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(functionFragment: "balance", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "canAwardExternal",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "captureAwardBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "compLikeDelegate",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "depositTo",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "depositToAndDelegate",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getAccountedBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBalanceCap",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getLiquidityCap",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getPrizeStrategy",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getTicket", values?: undefined): string;
  encodeFunctionData(functionFragment: "getToken", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "isControlled",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setBalanceCap",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setLiquidityCap",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPrizeStrategy",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setTicket",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferExternalERC20",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawFrom",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(functionFragment: "award", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "awardBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "awardExternalERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "awardExternalERC721",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "balance", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "canAwardExternal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "captureAwardBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "compLikeDelegate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "depositTo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "depositToAndDelegate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAccountedBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBalanceCap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLiquidityCap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPrizeStrategy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getTicket", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isControlled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setBalanceCap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setLiquidityCap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPrizeStrategy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setTicket", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferExternalERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawFrom",
    data: BytesLike
  ): Result;

  events: {
    "AwardCaptured(uint256)": EventFragment;
    "Awarded(address,address,uint256)": EventFragment;
    "AwardedExternalERC20(address,address,uint256)": EventFragment;
    "AwardedExternalERC721(address,address,uint256[])": EventFragment;
    "BalanceCapSet(uint256)": EventFragment;
    "ControlledTokenAdded(address)": EventFragment;
    "Deposited(address,address,address,uint256)": EventFragment;
    "ErrorAwardingExternalERC721(bytes)": EventFragment;
    "LiquidityCapSet(uint256)": EventFragment;
    "PrizeStrategySet(address)": EventFragment;
    "TicketSet(address)": EventFragment;
    "TransferredExternalERC20(address,address,uint256)": EventFragment;
    "Withdrawal(address,address,address,uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AwardCaptured"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Awarded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AwardedExternalERC20"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AwardedExternalERC721"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BalanceCapSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ControlledTokenAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Deposited"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "ErrorAwardingExternalERC721"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LiquidityCapSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PrizeStrategySet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TicketSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferredExternalERC20"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Withdrawal"): EventFragment;
}

export interface AwardCapturedEventObject {
  amount: BigNumber;
}
export type AwardCapturedEvent = TypedEvent<
  [BigNumber],
  AwardCapturedEventObject
>;

export type AwardCapturedEventFilter = TypedEventFilter<AwardCapturedEvent>;

export interface AwardedEventObject {
  winner: string;
  token: string;
  amount: BigNumber;
}
export type AwardedEvent = TypedEvent<
  [string, string, BigNumber],
  AwardedEventObject
>;

export type AwardedEventFilter = TypedEventFilter<AwardedEvent>;

export interface AwardedExternalERC20EventObject {
  winner: string;
  token: string;
  amount: BigNumber;
}
export type AwardedExternalERC20Event = TypedEvent<
  [string, string, BigNumber],
  AwardedExternalERC20EventObject
>;

export type AwardedExternalERC20EventFilter =
  TypedEventFilter<AwardedExternalERC20Event>;

export interface AwardedExternalERC721EventObject {
  winner: string;
  token: string;
  tokenIds: BigNumber[];
}
export type AwardedExternalERC721Event = TypedEvent<
  [string, string, BigNumber[]],
  AwardedExternalERC721EventObject
>;

export type AwardedExternalERC721EventFilter =
  TypedEventFilter<AwardedExternalERC721Event>;

export interface BalanceCapSetEventObject {
  balanceCap: BigNumber;
}
export type BalanceCapSetEvent = TypedEvent<
  [BigNumber],
  BalanceCapSetEventObject
>;

export type BalanceCapSetEventFilter = TypedEventFilter<BalanceCapSetEvent>;

export interface ControlledTokenAddedEventObject {
  token: string;
}
export type ControlledTokenAddedEvent = TypedEvent<
  [string],
  ControlledTokenAddedEventObject
>;

export type ControlledTokenAddedEventFilter =
  TypedEventFilter<ControlledTokenAddedEvent>;

export interface DepositedEventObject {
  operator: string;
  to: string;
  token: string;
  amount: BigNumber;
}
export type DepositedEvent = TypedEvent<
  [string, string, string, BigNumber],
  DepositedEventObject
>;

export type DepositedEventFilter = TypedEventFilter<DepositedEvent>;

export interface ErrorAwardingExternalERC721EventObject {
  error: string;
}
export type ErrorAwardingExternalERC721Event = TypedEvent<
  [string],
  ErrorAwardingExternalERC721EventObject
>;

export type ErrorAwardingExternalERC721EventFilter =
  TypedEventFilter<ErrorAwardingExternalERC721Event>;

export interface LiquidityCapSetEventObject {
  liquidityCap: BigNumber;
}
export type LiquidityCapSetEvent = TypedEvent<
  [BigNumber],
  LiquidityCapSetEventObject
>;

export type LiquidityCapSetEventFilter = TypedEventFilter<LiquidityCapSetEvent>;

export interface PrizeStrategySetEventObject {
  prizeStrategy: string;
}
export type PrizeStrategySetEvent = TypedEvent<
  [string],
  PrizeStrategySetEventObject
>;

export type PrizeStrategySetEventFilter =
  TypedEventFilter<PrizeStrategySetEvent>;

export interface TicketSetEventObject {
  ticket: string;
}
export type TicketSetEvent = TypedEvent<[string], TicketSetEventObject>;

export type TicketSetEventFilter = TypedEventFilter<TicketSetEvent>;

export interface TransferredExternalERC20EventObject {
  to: string;
  token: string;
  amount: BigNumber;
}
export type TransferredExternalERC20Event = TypedEvent<
  [string, string, BigNumber],
  TransferredExternalERC20EventObject
>;

export type TransferredExternalERC20EventFilter =
  TypedEventFilter<TransferredExternalERC20Event>;

export interface WithdrawalEventObject {
  operator: string;
  from: string;
  token: string;
  amount: BigNumber;
  redeemed: BigNumber;
}
export type WithdrawalEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  WithdrawalEventObject
>;

export type WithdrawalEventFilter = TypedEventFilter<WithdrawalEvent>;

export interface IPrizePool extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IPrizePoolInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    award(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    awardBalance(overrides?: CallOverrides): Promise<[BigNumber]>;

    awardExternalERC20(
      to: PromiseOrValue<string>,
      externalToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    awardExternalERC721(
      to: PromiseOrValue<string>,
      externalToken: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    balance(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    canAwardExternal(
      externalToken: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    captureAwardBalance(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    compLikeDelegate(
      compLike: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositTo(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositToAndDelegate(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      delegate: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getAccountedBalance(overrides?: CallOverrides): Promise<[BigNumber]>;

    getBalanceCap(overrides?: CallOverrides): Promise<[BigNumber]>;

    getLiquidityCap(overrides?: CallOverrides): Promise<[BigNumber]>;

    getPrizeStrategy(overrides?: CallOverrides): Promise<[string]>;

    getTicket(overrides?: CallOverrides): Promise<[string]>;

    getToken(overrides?: CallOverrides): Promise<[string]>;

    isControlled(
      controlledToken: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    setBalanceCap(
      balanceCap: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setLiquidityCap(
      liquidityCap: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPrizeStrategy(
      _prizeStrategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setTicket(
      ticket: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferExternalERC20(
      to: PromiseOrValue<string>,
      externalToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawFrom(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  award(
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  awardBalance(overrides?: CallOverrides): Promise<BigNumber>;

  awardExternalERC20(
    to: PromiseOrValue<string>,
    externalToken: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  awardExternalERC721(
    to: PromiseOrValue<string>,
    externalToken: PromiseOrValue<string>,
    tokenIds: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  balance(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  canAwardExternal(
    externalToken: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  captureAwardBalance(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  compLikeDelegate(
    compLike: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositTo(
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositToAndDelegate(
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    delegate: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getAccountedBalance(overrides?: CallOverrides): Promise<BigNumber>;

  getBalanceCap(overrides?: CallOverrides): Promise<BigNumber>;

  getLiquidityCap(overrides?: CallOverrides): Promise<BigNumber>;

  getPrizeStrategy(overrides?: CallOverrides): Promise<string>;

  getTicket(overrides?: CallOverrides): Promise<string>;

  getToken(overrides?: CallOverrides): Promise<string>;

  isControlled(
    controlledToken: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  setBalanceCap(
    balanceCap: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setLiquidityCap(
    liquidityCap: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPrizeStrategy(
    _prizeStrategy: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setTicket(
    ticket: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferExternalERC20(
    to: PromiseOrValue<string>,
    externalToken: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawFrom(
    from: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    award(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    awardBalance(overrides?: CallOverrides): Promise<BigNumber>;

    awardExternalERC20(
      to: PromiseOrValue<string>,
      externalToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    awardExternalERC721(
      to: PromiseOrValue<string>,
      externalToken: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    balance(overrides?: CallOverrides): Promise<BigNumber>;

    canAwardExternal(
      externalToken: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    captureAwardBalance(overrides?: CallOverrides): Promise<BigNumber>;

    compLikeDelegate(
      compLike: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    depositTo(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    depositToAndDelegate(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      delegate: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    getAccountedBalance(overrides?: CallOverrides): Promise<BigNumber>;

    getBalanceCap(overrides?: CallOverrides): Promise<BigNumber>;

    getLiquidityCap(overrides?: CallOverrides): Promise<BigNumber>;

    getPrizeStrategy(overrides?: CallOverrides): Promise<string>;

    getTicket(overrides?: CallOverrides): Promise<string>;

    getToken(overrides?: CallOverrides): Promise<string>;

    isControlled(
      controlledToken: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    setBalanceCap(
      balanceCap: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    setLiquidityCap(
      liquidityCap: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPrizeStrategy(
      _prizeStrategy: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setTicket(
      ticket: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    transferExternalERC20(
      to: PromiseOrValue<string>,
      externalToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawFrom(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {
    "AwardCaptured(uint256)"(amount?: null): AwardCapturedEventFilter;
    AwardCaptured(amount?: null): AwardCapturedEventFilter;

    "Awarded(address,address,uint256)"(
      winner?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null
    ): AwardedEventFilter;
    Awarded(
      winner?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null
    ): AwardedEventFilter;

    "AwardedExternalERC20(address,address,uint256)"(
      winner?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null
    ): AwardedExternalERC20EventFilter;
    AwardedExternalERC20(
      winner?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null
    ): AwardedExternalERC20EventFilter;

    "AwardedExternalERC721(address,address,uint256[])"(
      winner?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      tokenIds?: null
    ): AwardedExternalERC721EventFilter;
    AwardedExternalERC721(
      winner?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      tokenIds?: null
    ): AwardedExternalERC721EventFilter;

    "BalanceCapSet(uint256)"(balanceCap?: null): BalanceCapSetEventFilter;
    BalanceCapSet(balanceCap?: null): BalanceCapSetEventFilter;

    "ControlledTokenAdded(address)"(
      token?: PromiseOrValue<string> | null
    ): ControlledTokenAddedEventFilter;
    ControlledTokenAdded(
      token?: PromiseOrValue<string> | null
    ): ControlledTokenAddedEventFilter;

    "Deposited(address,address,address,uint256)"(
      operator?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null
    ): DepositedEventFilter;
    Deposited(
      operator?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null
    ): DepositedEventFilter;

    "ErrorAwardingExternalERC721(bytes)"(
      error?: null
    ): ErrorAwardingExternalERC721EventFilter;
    ErrorAwardingExternalERC721(
      error?: null
    ): ErrorAwardingExternalERC721EventFilter;

    "LiquidityCapSet(uint256)"(liquidityCap?: null): LiquidityCapSetEventFilter;
    LiquidityCapSet(liquidityCap?: null): LiquidityCapSetEventFilter;

    "PrizeStrategySet(address)"(
      prizeStrategy?: PromiseOrValue<string> | null
    ): PrizeStrategySetEventFilter;
    PrizeStrategySet(
      prizeStrategy?: PromiseOrValue<string> | null
    ): PrizeStrategySetEventFilter;

    "TicketSet(address)"(
      ticket?: PromiseOrValue<string> | null
    ): TicketSetEventFilter;
    TicketSet(ticket?: PromiseOrValue<string> | null): TicketSetEventFilter;

    "TransferredExternalERC20(address,address,uint256)"(
      to?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null
    ): TransferredExternalERC20EventFilter;
    TransferredExternalERC20(
      to?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null
    ): TransferredExternalERC20EventFilter;

    "Withdrawal(address,address,address,uint256,uint256)"(
      operator?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null,
      redeemed?: null
    ): WithdrawalEventFilter;
    Withdrawal(
      operator?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null,
      redeemed?: null
    ): WithdrawalEventFilter;
  };

  estimateGas: {
    award(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    awardBalance(overrides?: CallOverrides): Promise<BigNumber>;

    awardExternalERC20(
      to: PromiseOrValue<string>,
      externalToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    awardExternalERC721(
      to: PromiseOrValue<string>,
      externalToken: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    balance(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    canAwardExternal(
      externalToken: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    captureAwardBalance(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    compLikeDelegate(
      compLike: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositTo(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositToAndDelegate(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      delegate: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getAccountedBalance(overrides?: CallOverrides): Promise<BigNumber>;

    getBalanceCap(overrides?: CallOverrides): Promise<BigNumber>;

    getLiquidityCap(overrides?: CallOverrides): Promise<BigNumber>;

    getPrizeStrategy(overrides?: CallOverrides): Promise<BigNumber>;

    getTicket(overrides?: CallOverrides): Promise<BigNumber>;

    getToken(overrides?: CallOverrides): Promise<BigNumber>;

    isControlled(
      controlledToken: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setBalanceCap(
      balanceCap: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setLiquidityCap(
      liquidityCap: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPrizeStrategy(
      _prizeStrategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setTicket(
      ticket: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferExternalERC20(
      to: PromiseOrValue<string>,
      externalToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawFrom(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    award(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    awardBalance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    awardExternalERC20(
      to: PromiseOrValue<string>,
      externalToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    awardExternalERC721(
      to: PromiseOrValue<string>,
      externalToken: PromiseOrValue<string>,
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    balance(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    canAwardExternal(
      externalToken: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    captureAwardBalance(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    compLikeDelegate(
      compLike: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositTo(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositToAndDelegate(
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      delegate: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getAccountedBalance(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBalanceCap(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getLiquidityCap(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getPrizeStrategy(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getTicket(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isControlled(
      controlledToken: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setBalanceCap(
      balanceCap: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setLiquidityCap(
      liquidityCap: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPrizeStrategy(
      _prizeStrategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setTicket(
      ticket: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferExternalERC20(
      to: PromiseOrValue<string>,
      externalToken: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawFrom(
      from: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
